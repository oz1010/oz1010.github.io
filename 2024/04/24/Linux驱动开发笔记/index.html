<!doctype html><html lang=zh-CN><meta charset=UTF-8><meta content="width=device-width" name=viewport><meta content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/icon-180.png rel=apple-touch-icon sizes=180x180><link href=/images/icon-32.png rel=icon sizes=32x32 type=image/png><link href=/images/icon-16.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/oz1010_logo.svg rel=mask-icon><style>:root{--body-bg-color:#f5f7f9;--content-bg-color:#fff;--card-bg-color:#f5f5f5;--text-color:#555;--selection-bg:#262a30;--selection-color:#eee;--blockquote-color:#666;--link-color:#555;--link-hover-color:#222;--brand-color:#fff;--brand-hover-color:#fff;--table-row-odd-bg-color:#f9f9f9;--table-row-hover-bg-color:#f5f5f5;--menu-item-bg-color:#f5f5f5;--theme-color:#222;--btn-default-bg:#fff;--btn-default-color:#555;--btn-default-border-color:#555;--btn-default-hover-bg:#222;--btn-default-hover-color:#fff;--btn-default-hover-border-color:#222;--highlight-background:#f6f6f6;--highlight-foreground:#2f3337;--highlight-gutter-background:#e2e2e2;--highlight-gutter-foreground:#42464a;color-scheme:light}html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{margin:.67em 0;font-size:2em}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace;font-size:1em}a{background:0 0}abbr[title]{border-bottom:none;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace;font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:100%;line-height:1.15}button,input{overflow:visible}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted buttontext}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;white-space:normal;max-width:100%;padding:0;display:table}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}details{display:block}summary{display:list-item}template,[hidden]{display:none}::selection{background:var(--selection-bg);color:var(--selection-color)}html,body{height:100%}body{background:var(--body-bg-color);box-sizing:border-box;color:var(--text-color);min-height:100%;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:1em;line-height:2;transition:padding .2s ease-in-out;position:relative}h1,h2,h3,h4,h5,h6{margin:30px 0 15px;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-weight:700;line-height:1.5}h1{font-size:1.5em}h2{font-size:1.375em}h3{font-size:1.25em}h4{font-size:1.125em}h5{font-size:1em}h6{font-size:.875em}a{color:var(--link-color);cursor:pointer;overflow-wrap:break-word;border-bottom:1px solid #999;outline:0;text-decoration:none}a:hover{border-bottom-color:var(--link-hover-color);color:var(--link-hover-color)}iframe,img,video,embed{max-width:100%;margin-left:auto;margin-right:auto;display:block}hr{background-image:repeating-linear-gradient(-45deg,#ddd,#ddd 4px,#0000 4px 8px);border:0;height:3px;margin:40px 0}blockquote{color:var(--blockquote-color);border-left:4px solid #ddd;margin:0;padding:0 15px}blockquote cite:before{content:"-";padding:0 5px}dt{font-weight:700}dd{margin:0;padding:0}.table-container{overflow:auto}table{border-collapse:collapse;border-spacing:0;width:100%;margin:0 0 20px;font-size:.875em}tbody tr:nth-of-type(odd){background:var(--table-row-odd-bg-color)}tbody tr:hover{background:var(--table-row-hover-bg-color)}caption,th,td{padding:8px}th,td{border:1px solid #ddd;border-bottom-width:3px}th{padding-bottom:10px;font-weight:700}td{border-bottom-width:1px}.btn{background:var(--btn-default-bg);border:2px solid var(--btn-default-border-color);color:var(--btn-default-color);border-radius:2px;padding:0 20px;font-size:.875em;line-height:2;transition:background-color .2s ease-in-out;display:inline-block}.btn:hover{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.btn+.btn{margin:0 0 8px 8px}.btn .fa-fw{text-align:left;width:1.28571em}.toggle{line-height:0}.toggle .toggle-line{background:#fff;width:100%;height:2px;transition:left .4s,opacity .4s,top .4s,transform .4s,width .4s;display:block;position:relative;top:0;left:0}.toggle .toggle-line:first-child{margin-top:1px}.toggle .toggle-line:not(:first-child){margin-top:4px}.toggle.toggle-arrow :first-child{width:50%;top:2px;left:50%;transform:rotate(45deg)}.toggle.toggle-arrow :last-child{width:50%;top:-2px;left:50%;transform:rotate(-45deg)}.toggle.toggle-close :nth-child(2){opacity:0}.toggle.toggle-close :first-child{top:6px;transform:rotate(45deg)}.toggle.toggle-close :last-child{top:-6px;transform:rotate(-45deg)}pre code.hljs{padding:1em;display:block;overflow-x:auto}code.hljs{padding:3px 5px}.hljs{color:#2f3337;background:#f6f6f6}.hljs-subst{color:#2f3337}.hljs-comment{color:#656e77}.hljs-keyword,.hljs-selector-tag,.hljs-meta .hljs-keyword,.hljs-doctag,.hljs-section,.hljs-attr{color:#015692}.hljs-attribute{color:#803378}.hljs-name,.hljs-type,.hljs-number,.hljs-selector-id,.hljs-quote,.hljs-template-tag{color:#b75501}.hljs-selector-class{color:#015692}.hljs-string,.hljs-regexp,.hljs-symbol,.hljs-variable,.hljs-template-variable,.hljs-link,.hljs-selector-attr{color:#54790d}.hljs-meta,.hljs-selector-pseudo{color:#015692}.hljs-built_in,.hljs-title,.hljs-literal{color:#b75501}.hljs-bullet,.hljs-code{color:#535a60}.hljs-meta .hljs-string{color:#54790d}.hljs-deletion{color:#c02d2e}.hljs-addition{color:#2f6f44}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.highlight:hover .copy-btn,.code-container:hover .copy-btn{opacity:1}.code-container{position:relative}.code-lang{opacity:.1;pointer-events:none;font-size:40px;line-height:1;position:absolute;right:5px}.copy-btn{color:#333;cursor:pointer;opacity:0;background:#fff;border:0;padding:2px 6px;font-size:.8125em;line-height:1.6;transition:opacity .2s ease-in-out;position:absolute;top:0;right:0}code,kbd,figure.highlight,pre{background:var(--highlight-background);color:var(--highlight-foreground)}figure.highlight,pre{margin:0 auto 20px;line-height:1.6}figure.highlight figcaption,pre .caption{background:var(--highlight-gutter-background);color:var(--highlight-foreground);padding:.5em;font-size:.875em;line-height:1.2;display:flow-root}figure.highlight figcaption a,pre .caption a{color:var(--highlight-foreground);float:right}figure.highlight figcaption a:hover,pre .caption a:hover{border-bottom-color:var(--highlight-foreground)}pre,code{font-family:consolas,Menlo,monospace,PingFang SC,Microsoft YaHei}code{overflow-wrap:break-word;border-radius:3px;padding:2px 4px;font-size:.875em}kbd{white-space:nowrap;border:2px solid #ccc;border-radius:.2em;padding:.1em .3em;font-family:inherit;box-shadow:.1em .1em .2em #0000001a}figure.highlight{position:relative;overflow:auto}figure.highlight pre{border:0;margin:0;padding:10px 0}figure.highlight table{border:0;width:auto;margin:0}figure.highlight td{border:0;padding:0}figure.highlight .gutter{-webkit-user-select:none;user-select:none}figure.highlight .gutter pre{background:var(--highlight-gutter-background);color:var(--highlight-gutter-foreground);text-align:right;padding-left:10px;padding-right:10px}figure.highlight .code pre{width:100%;padding-left:10px}figure.highlight .marked{background:#0000004d}pre .caption{margin-bottom:10px}.gist table{width:auto}.gist table td{border:0}pre{padding:10px;overflow:auto}pre code{text-shadow:none;background:0 0;padding:0}.blockquote-center{text-align:center;border-left:0;margin:40px 0;padding:0;position:relative}.blockquote-center:before,.blockquote-center:after{opacity:.6;width:100%;line-height:1;position:absolute;left:0}.blockquote-center:before{text-align:left;content:"";border-top:1px solid #ccc;font-family:"Font Awesome 6 Free";font-weight:900;top:-20px}.blockquote-center:after{text-align:right;content:"";border-bottom:1px solid #ccc;font-family:"Font Awesome 6 Free";font-weight:900;bottom:-20px}.blockquote-center p,.blockquote-center div{text-align:center}.group-picture{margin-bottom:20px}.group-picture .group-picture-row{gap:3px;margin-bottom:3px;display:flex}.group-picture .group-picture-column{flex:1}.group-picture .group-picture-column img{object-fit:cover;width:100%;height:100%;margin:0}.post-body .label{color:#555;padding:0 2px}.post-body .label.default{background:#f0f0f0}.post-body .label.primary{background:#efe6f7}.post-body .label.info{background:#e5f2f8}.post-body .label.success{background:#e7f4e9}.post-body .label.warning{background:#fcf6e1}.post-body .label.danger{background:#fae8eb}.post-body .link-grid{grid-gap:1.5rem;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:1.5rem;margin-bottom:20px;padding:1rem;display:grid}.post-body .link-grid .link-grid-container{border:solid #ddd;min-width:0;min-height:5rem;padding:.5rem;transition:background .3s;position:relative;box-shadow:1rem 1rem .5rem #00000080}.post-body .link-grid .link-grid-container:hover{background:var(--card-bg-color);animation:.5s next-shake}.post-body .link-grid .link-grid-container:active{transform:translate(.2rem,.2rem);box-shadow:.5rem .5rem .25rem #00000080}.post-body .link-grid .link-grid-container .link-grid-image{box-sizing:border-box;border:1px solid #ddd;border-radius:50%;width:5rem;height:5rem;padding:3px;position:absolute}.post-body .link-grid .link-grid-container p{margin:0 1rem 0 6rem}.post-body .link-grid .link-grid-container p:first-of-type{font-size:1.2em}.post-body .link-grid .link-grid-container p:last-of-type{opacity:.7;font-size:.8em;line-height:1.3rem}.post-body .link-grid .link-grid-container a{border:0;width:100%;height:100%;position:absolute;top:0;left:0}@keyframes next-shake{0%{transform:translate(1pt,1pt)rotate(0)}10%{transform:translate(-1pt,-2pt)rotate(-1deg)}20%{transform:translate(-3pt)rotate(1deg)}30%{transform:translate(3pt,2pt)rotate(0)}40%{transform:translate(1pt,-1pt)rotate(1deg)}50%{transform:translate(-1pt,2pt)rotate(-1deg)}60%{transform:translate(-3pt,1pt)rotate(0)}70%{transform:translate(3pt,1pt)rotate(-1deg)}80%{transform:translate(-1pt,-1pt)rotate(1deg)}90%{transform:translate(1pt,2pt)rotate(0)}to{transform:translate(1pt,-2pt)rotate(-1deg)}}.post-body .note{border:1px solid #eee;border-left-width:5px;border-radius:3px;margin-bottom:20px;padding:1em;position:relative}.post-body .note summary{cursor:pointer;outline:0}.post-body .note summary p{display:inline}.post-body .note h2,.post-body .note h3,.post-body .note h4,.post-body .note h5,.post-body .note h6{border-bottom:initial;margin:0;padding-top:0}.post-body .note :first-child{margin-top:0}.post-body .note :last-child{margin-bottom:0}.post-body .note.default{border-left-color:#777}.post-body .note.default h2,.post-body .note.default h3,.post-body .note.default h4,.post-body .note.default h5,.post-body .note.default h6{color:#777}.post-body .note.primary{border-left-color:#6f42c1}.post-body .note.primary h2,.post-body .note.primary h3,.post-body .note.primary h4,.post-body .note.primary h5,.post-body .note.primary h6{color:#6f42c1}.post-body .note.info{border-left-color:#428bca}.post-body .note.info h2,.post-body .note.info h3,.post-body .note.info h4,.post-body .note.info h5,.post-body .note.info h6{color:#428bca}.post-body .note.success{border-left-color:#5cb85c}.post-body .note.success h2,.post-body .note.success h3,.post-body .note.success h4,.post-body .note.success h5,.post-body .note.success h6{color:#5cb85c}.post-body .note.warning{border-left-color:#f0ad4e}.post-body .note.warning h2,.post-body .note.warning h3,.post-body .note.warning h4,.post-body .note.warning h5,.post-body .note.warning h6{color:#f0ad4e}.post-body .note.danger{border-left-color:#d9534f}.post-body .note.danger h2,.post-body .note.danger h3,.post-body .note.danger h4,.post-body .note.danger h5,.post-body .note.danger h6{color:#d9534f}.post-body .tabs{margin-bottom:20px}.post-body .tabs,.tabs-comment{padding-top:10px}.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{background:var(--content-bg-color);z-index:5;flex-wrap:wrap;justify-content:center;margin:0;padding:0;display:flex;position:sticky;top:0}@media (width<=413px){.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{margin-bottom:5px;display:block}}.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border:1px solid #0000;border-top-width:3px;border-bottom-color:#ddd;border-radius:0;flex-grow:1;list-style-type:none}@media (width<=413px){.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border:1px solid #0000;border-left-width:3px;border-radius:0}}.post-body .tabs ul.nav-tabs li.tab a,.tabs-comment ul.nav-tabs li.tab a{border-bottom:initial;text-align:center;padding:.25em .75em;line-height:1.8;transition:all .2s ease-out;display:block}.post-body .tabs ul.nav-tabs li.tab a i[class^=fa],.tabs-comment ul.nav-tabs li.tab a i[class^=fa]{width:1.28571em}.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#fc6423 #ddd #0000}@media (width<=413px){.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#ddd #ddd #ddd #fc6423}}.post-body .tabs ul.nav-tabs li.tab.active a,.tabs-comment ul.nav-tabs li.tab.active a{cursor:default}.post-body .tabs .tab-content,.tabs-comment .tab-content{border:1px solid #ddd;border-top-color:#0000;border-radius:0}@media (width<=413px){.post-body .tabs .tab-content,.tabs-comment .tab-content{border-top-color:#ddd;border-radius:0}}.post-body .tabs .tab-content .tab-pane,.tabs-comment .tab-content .tab-pane{padding:20px 20px 0}.post-body .tabs .tab-content .tab-pane:not(.active),.tabs-comment .tab-content .tab-pane:not(.active){display:none}.pagination .prev,.pagination .next,.pagination .page-number,.pagination .space{margin:-1px 10px 0;padding:0 10px;display:inline-block}@media (width<=767px){.pagination .prev,.pagination .next,.pagination .page-number,.pagination .space{margin:0 5px}}.pagination .page-number.current{color:var(--content-bg-color);background:#ccc;border-color:#ccc}.pagination{text-align:center;border-top:1px solid #eee;margin:120px 0 0}.pagination .prev,.pagination .next,.pagination .page-number{border-top:1px solid #eee;border-bottom:0;transition:border-color .2s ease-in-out}.pagination .prev:hover,.pagination .next:hover,.pagination .page-number:hover{border-top-color:var(--link-hover-color)}@media (width<=767px){.pagination{border-top:0}.pagination .prev,.pagination .next,.pagination .page-number{border-top:0;border-bottom:1px solid #eee}.pagination .prev:hover,.pagination .next:hover,.pagination .page-number:hover{border-bottom-color:var(--link-hover-color)}}.pagination .space{margin:0;padding:0}.comments{margin-top:60px;overflow:hidden}.comment-button-group{flex-wrap:wrap;justify-content:center;margin:1em 0;display:flex}.comment-button-group .comment-button{margin:.1em .2em}.comment-button-group .comment-button.active{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.comment-position{display:none}.comment-position.active{display:block}.tabs-comment{margin-top:4em;padding-top:0}.tabs-comment .comments{margin-top:0;padding-top:0}.headband{background:var(--theme-color);height:3px}@media (width<=991px){.headband{display:none}}.site-brand-container{flex-shrink:0;padding:0 10px;display:flex}.use-motion .column,.use-motion .site-brand-container .toggle{opacity:0}.site-meta{text-align:center;flex-grow:1}@media (width<=767px){.site-meta{text-align:center}}.custom-logo-image{margin-top:20px}@media (width<=991px){.custom-logo-image{display:none}}.brand{color:var(--brand-color);border-bottom:0;padding:0;display:inline-block}.brand:hover{color:var(--brand-hover-color)}.site-title{margin:0;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:1.375em;font-weight:400;line-height:1.5}.site-subtitle{color:#ddd;margin:10px 10px 0;font-size:.8125em}.use-motion .site-title,.use-motion .site-subtitle,.use-motion .custom-logo-image{opacity:0;position:relative;top:-10px}.site-nav-toggle,.site-nav-right{display:none}@media (width<=767px){.site-nav-toggle,.site-nav-right{flex-direction:column;justify-content:center;display:flex}}.site-nav-toggle .toggle,.site-nav-right .toggle{color:var(--text-color);width:22px;padding:10px}.site-nav-toggle .toggle .toggle-line,.site-nav-right .toggle .toggle-line{background:var(--text-color);border-radius:1px}@media (width<=767px){.site-nav{--scroll-height:0;visibility:hidden;height:0;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height);visibility:unset}}.menu{text-align:center;margin:0;padding:1em 0}.menu-item{margin:0 10px;list-style:none;display:inline-block}@media (width<=767px){.menu-item{margin-top:10px;display:block}.menu-item.menu-item-search{display:none}}.menu-item a{border-bottom:0;font-size:.8125em;transition:border-color .2s ease-in-out;display:block}.menu-item a:hover,.menu-item a.menu-item-active{background:var(--menu-item-bg-color)}.menu-item i[class^=fa]{margin-right:8px}.menu-item .badge{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-weight:700;line-height:1}.use-motion .menu-item{visibility:hidden}@media (width<=991px){.sidebar{left:-320px}.sidebar-active .sidebar{left:0}.sidebar{z-index:20;background:#222;width:320px;max-height:100vh;transition:left .2s ease-out,right .2s ease-out;position:fixed;top:0;bottom:0;overflow-y:auto;box-shadow:inset 0 2px 6px #000}.sidebar a{color:#999;border-bottom-color:#555}.sidebar a:hover{color:#eee;border-bottom-color:#eee}.links-of-author:not(:first-child){margin-top:15px}.links-of-author a{vertical-align:middle;border-bottom-color:#555;margin-bottom:10px;margin-right:10px;display:inline-block}.links-of-author a:before{content:" ";background:#3b93ac;border-radius:50%;width:4px;height:4px;margin-right:3px;display:inline-block;transform:translateY(-2px)}.links-of-blogroll-item{padding:0 5px}.popular-posts .popular-posts-item .popular-posts-link:hover{background:0 0}.sidebar-dimmer{opacity:0;visibility:hidden;z-index:10;background:#000;width:100%;height:100%;transition:visibility .4s,opacity .4s;position:fixed;top:0;left:0}.sidebar-active .sidebar-dimmer{opacity:.7;visibility:visible}}.sidebar-inner{color:#999;text-align:center;flex-direction:column;justify-content:center;padding:18px 10px;display:flex}.sidebar-toggle{cursor:pointer;opacity:.6;z-index:30;background:#222;width:16px;height:16px;padding:5px;position:fixed;bottom:61px;left:30px}@media (width<=991px){.sidebar-toggle{left:20px}}.sidebar-toggle:hover{opacity:.8}@media (width<=991px){.sidebar-toggle{opacity:.8}}.sidebar-toggle:hover .toggle-line{background:#fc6423}@media (any-hover:hover){body:not(.sidebar-active) .sidebar-toggle:hover :first-child{width:50%;top:2px;left:50%;transform:rotate(45deg)}body:not(.sidebar-active) .sidebar-toggle:hover :last-child{width:50%;top:-2px;left:50%;transform:rotate(-45deg)}}.sidebar-active .sidebar-toggle :nth-child(2){opacity:0}.sidebar-active .sidebar-toggle :first-child{top:6px;transform:rotate(45deg)}.sidebar-active .sidebar-toggle :last-child{top:-6px;transform:rotate(-45deg)}.sidebar-nav{pointer-events:none;visibility:hidden;height:0;margin:0;padding-left:0;font-size:.875em;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}.sidebar-nav-active .sidebar-nav{pointer-events:unset;height:calc(2em + 1px);visibility:unset}.sidebar-nav li{color:var(--text-color);cursor:pointer;border-bottom:1px solid #0000;transition:border-bottom-color .2s ease-in-out,color .2s ease-in-out;display:inline-block}.sidebar-nav li.sidebar-nav-overview{margin-left:10px}.sidebar-nav li:hover{color:#fc6423}.sidebar-toc-active .sidebar-nav-toc,.sidebar-overview-active .sidebar-nav-overview{color:#fc6423;border-bottom-color:#fc6423;transition-delay:.2s}.sidebar-toc-active .sidebar-nav-toc:hover,.sidebar-overview-active .sidebar-nav-overview:hover{color:#fc6423}.sidebar-panel-container{flex:1;align-items:start;padding-top:0;transition:padding-top .2s ease-in-out;display:grid;overflow:hidden auto}.sidebar-nav-active .sidebar-panel-container{padding-top:20px}.sidebar-panel{opacity:0;pointer-events:none;visibility:hidden;grid-area:1/1;height:0;transition:opacity .2s ease-in-out,transform .2s ease-in-out,visibility .2s ease-in-out;animation:.2s ease-in-out deactivate-sidebar-panel;overflow:hidden;transform:translateY(0)}.sidebar-nav-active .sidebar-panel,.sidebar-overview-active .sidebar-panel.post-toc-wrap{transform:translateY(-20px)}.sidebar-overview-active:not(.sidebar-nav-active) .sidebar-panel.post-toc-wrap{transition-delay:0s,.2s,0s}.sidebar-overview-active .sidebar-panel.site-overview-wrap,.sidebar-toc-active .sidebar-panel.post-toc-wrap{opacity:1;pointer-events:unset;height:auto;visibility:unset;transition-delay:.2s,.2s,0s;animation-name:activate-sidebar-panel;transform:translateY(0)}.sidebar-panel.site-overview-wrap{flex-direction:column;justify-content:flex-start;gap:10px;display:flex}@keyframes deactivate-sidebar-panel{0%{height:var(--inactive-panel-height,0)}to{height:var(--active-panel-height,0)}}@keyframes activate-sidebar-panel{0%{height:var(--inactive-panel-height,auto)}to{height:var(--active-panel-height,auto)}}.post-toc{font-size:.875em}.post-toc ol{text-align:left;margin:0;padding:0 2px 0 10px;list-style:none}.post-toc ol>:last-child{margin-bottom:5px}.post-toc ol>ol{padding-left:0}.post-toc ol a{transition:all .2s ease-in-out}.post-toc .nav-item{text-overflow:ellipsis;white-space:nowrap;line-height:1.8;overflow:hidden}.post-toc .nav .active>a{color:#fc6423;border-bottom-color:#fc6423}.post-toc .nav .active-current>a,.post-toc .nav .active-current>a:hover{color:#fc6423}.site-author-image{border:1px solid #eee;border-radius:50%;max-width:120px;padding:2px}.site-author-name{color:var(--text-color);margin:0;font-weight:600}.site-description{color:#999;margin-top:0;font-size:.8125em}.site-state{flex-wrap:wrap;justify-content:center;line-height:1.4;display:flex}.site-state-item{padding:0 15px}.site-state-item a{border-bottom:0;display:block}.site-state-item-count{font-size:1em;font-weight:600;display:block}.site-state-item-name{color:#999;font-size:.8125em}.sidebar .sidebar-button:not(:first-child){margin-top:15px}.sidebar .sidebar-button button{color:#fc6423;cursor:pointer;background:0 0;border:1px solid #fc6423;border-radius:4px;padding:0 15px;line-height:2}.sidebar .sidebar-button button:hover{color:#fff;background:#fc6423}.sidebar .sidebar-button button i[class^=fa]{margin-right:5px}.links-of-author a{font-size:.8125em}.links-of-author i[class^=fa]{margin-right:2px}.cc-license .cc-opacity{opacity:.7;border-bottom:0}.cc-license .cc-opacity:hover{opacity:.9}.cc-license img{display:inline-block}.links-of-blogroll{font-size:.8125em}.links-of-blogroll-title{font-size:.875em;font-weight:600}.links-of-blogroll-list{flex-flow:column wrap;justify-content:center;gap:5px;margin:5px 0 0;padding:0;list-style:none;display:flex}.links-of-blogroll-item{max-width:100%}.links-of-blogroll-item a{box-sizing:border-box;text-overflow:ellipsis;white-space:nowrap;max-width:100%;display:inline-block;overflow:hidden}.footer{color:#999;padding:20px 0;font-size:.875em;transition:left .2s ease-in-out,right .2s ease-in-out}.footer.footer-fixed{position:absolute;bottom:0;left:0;right:0}.footer-inner{box-sizing:border-box;text-align:center;flex-direction:column;justify-content:center;width:calc(100% - 20px);margin:0 auto;display:flex}@media (width<=767px){.footer-inner{width:auto}}@media (width>=1200px){.footer-inner{width:1160px}}@media (width>=1600px){.footer-inner{width:73%}}.use-motion .footer{opacity:0}.languages{font-size:1.125em;display:inline-block;position:relative}.languages .lang-select-label span{margin:0 .5em}.languages .lang-select{opacity:0;width:100%;height:100%;position:absolute;top:0;left:0}.with-love{color:red;margin:0 5px;display:inline-block}@keyframes icon-animate{0%,to{transform:scale(1)}10%,30%{transform:scale(.9)}20%,40%,60%,80%{transform:scale(1.1)}50%,70%{transform:scale(1.1)}}.back-to-top{color:#fff;cursor:pointer;opacity:.6;z-index:30;background:#222;align-items:center;height:26px;font-size:12px;transition:bottom .2s ease-in-out;display:flex;position:fixed;bottom:-100px;left:30px}.back-to-top span{margin-right:8px}.back-to-top .fa{text-align:center;width:26px}@media (width<=991px){.back-to-top{left:20px}}.back-to-top:hover{opacity:.8}@media (width<=991px){.back-to-top{opacity:.8}}.back-to-top:hover{color:#fc6423}.back-to-top.back-to-top-on{bottom:30px}.rtl.post-body p,.rtl.post-body a,.rtl.post-body h1,.rtl.post-body h2,.rtl.post-body h3,.rtl.post-body h4,.rtl.post-body h5,.rtl.post-body h6,.rtl.post-body li,.rtl.post-body ul,.rtl.post-body ol{direction:rtl;font-family:UKIJ Ekran}.rtl.post-title{font-family:UKIJ Ekran}.post-button{text-align:center;margin-top:40px}.use-motion .post-block,.use-motion .pagination,.use-motion .comments,.use-motion .post-header,.use-motion .post-body,.use-motion .collection-header{visibility:hidden}.posts-collapse .post-content{margin-bottom:35px;margin-left:35px;position:relative}@media (width<=767px){.posts-collapse .post-content{margin-left:0;margin-right:0}}.posts-collapse .post-content .collection-title{font-size:1.125em;position:relative}.posts-collapse .post-content .collection-title:before{content:" ";background:#999;border:1px solid #fff;border-radius:50%;width:10px;height:10px;margin-top:-4px;margin-left:-6px;position:absolute;top:50%}.posts-collapse .post-content .collection-year{margin:60px 0;font-size:1.5em;font-weight:700;position:relative}.posts-collapse .post-content .collection-year .collection-year-count{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-size:.75em;font-weight:700;line-height:1}.posts-collapse .post-content .collection-year:before{content:" ";background:#bbb;border-radius:50%;width:8px;height:8px;margin-top:-4px;margin-left:-4px;position:absolute;top:50%}.posts-collapse .post-content .collection-header{margin-left:20px;display:block}.posts-collapse .post-content .collection-header small{color:#bbb;margin-left:5px}.posts-collapse .post-content .post-header{border-bottom:1px dashed #ccc;margin:30px 2px 0;padding-left:15px;transition:border .2s ease-in-out;position:relative}.posts-collapse .post-content .post-header:before{content:" ";background:#bbb;border:1px solid #fff;border-radius:50%;width:6px;height:6px;transition:background .2s ease-in-out;position:absolute;top:.75em;left:-6px}.posts-collapse .post-content .post-header:hover{border-bottom-color:#666}.posts-collapse .post-content .post-header:hover:before{background:#222}.posts-collapse .post-content .post-meta-container{margin-right:10px;font-size:.75em;display:inline}.posts-collapse .post-content .post-title{display:inline}.posts-collapse .post-content .post-title a{color:var(--link-color);border-bottom:0}.posts-collapse .post-content .post-title .fa{margin-left:5px;font-size:.875em}.posts-collapse .post-content:before{content:" ";background:#f5f5f5;width:4px;height:100%;margin-left:-2px;position:absolute;top:1.25em}.post-body{overflow-wrap:break-word;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif}@media (width>=1200px){.post-body{font-size:1.125em}}@media (width>=992px){.post-body{text-align:justify}}@media (width<=991px){.post-body{text-align:justify}}.post-body h1 .header-anchor,.post-body h2 .header-anchor,.post-body h3 .header-anchor,.post-body h4 .header-anchor,.post-body h5 .header-anchor,.post-body h6 .header-anchor,.post-body h1 .headerlink,.post-body h2 .headerlink,.post-body h3 .headerlink,.post-body h4 .headerlink,.post-body h5 .headerlink,.post-body h6 .headerlink{color:inherit;float:right;opacity:0;border-bottom-style:none;margin-left:10px;font-size:.875em}.post-body h1 .header-anchor:before,.post-body h2 .header-anchor:before,.post-body h3 .header-anchor:before,.post-body h4 .header-anchor:before,.post-body h5 .header-anchor:before,.post-body h6 .header-anchor:before,.post-body h1 .headerlink:before,.post-body h2 .headerlink:before,.post-body h3 .headerlink:before,.post-body h4 .headerlink:before,.post-body h5 .headerlink:before,.post-body h6 .headerlink:before{content:"";font-family:"Font Awesome 6 Free";font-weight:900}.post-body h1:hover .header-anchor,.post-body h2:hover .header-anchor,.post-body h3:hover .header-anchor,.post-body h4:hover .header-anchor,.post-body h5:hover .header-anchor,.post-body h6:hover .header-anchor,.post-body h1:hover .headerlink,.post-body h2:hover .headerlink,.post-body h3:hover .headerlink,.post-body h4:hover .headerlink,.post-body h5:hover .headerlink,.post-body h6:hover .headerlink{opacity:.5}.post-body h1:hover .header-anchor:hover,.post-body h2:hover .header-anchor:hover,.post-body h3:hover .header-anchor:hover,.post-body h4:hover .header-anchor:hover,.post-body h5:hover .header-anchor:hover,.post-body h6:hover .header-anchor:hover,.post-body h1:hover .headerlink:hover,.post-body h2:hover .headerlink:hover,.post-body h3:hover .headerlink:hover,.post-body h4:hover .headerlink:hover,.post-body h5:hover .headerlink:hover,.post-body h6:hover .headerlink:hover{opacity:1}.post-body .exturl .fa{margin-left:4px;font-size:.875em}.post-body figure:not(.highlight) figcaption{color:#999;text-align:center;margin:-15px auto 15px;font-size:.875em;font-weight:700;line-height:1}.post-body iframe,.post-body img,.post-body video,.post-body embed{margin-bottom:20px}.post-body .video-container{width:100%;height:0;margin-bottom:20px;padding-top:75%;position:relative;overflow:hidden}.post-body .video-container iframe,.post-body .video-container object,.post-body .video-container embed{width:100%;height:100%;margin:0;position:absolute;top:0;left:0}.post-gallery{min-height:200px;display:flex}.post-gallery .post-gallery-image{flex:1}.post-gallery .post-gallery-image:not(:first-child){clip-path:polygon(40px 0,100% 0,100% 100%,0 100%);margin-left:-20px}.post-gallery .post-gallery-image:not(:last-child){margin-right:-20px}.post-gallery .post-gallery-image img{object-fit:cover;opacity:1;width:100%;height:100%}.posts-expand .post-gallery{margin-bottom:60px}.posts-collapse .post-gallery{margin:15px 0}.posts-expand .post-header{text-align:center;margin-bottom:60px;font-size:1.125em}.posts-expand .post-title{margin:initial;overflow-wrap:break-word;font-size:1.5em;font-weight:400}.posts-expand .post-title-link{color:var(--link-color);border-bottom:0;max-width:100%;display:inline-block;position:relative}.posts-expand .post-title-link:before{background:var(--link-color);content:"";width:100%;height:2px;transition:transform .2s ease-in-out;position:absolute;bottom:0;left:0;transform:scaleX(0)}.posts-expand .post-title-link:hover:before{transform:scaleX(1)}.posts-expand .post-title-link .fa{margin-left:5px;font-size:.875em}.post-sticky-flag{margin-right:8px;display:inline-block;transform:rotate(30deg)}.posts-expand .post-meta-container{color:#999;margin-top:3px;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:.75em}.posts-expand .post-meta-container .post-description{margin-top:2px;font-size:.875em}.posts-expand .post-meta-container time{border-bottom:1px dashed #999}.post-meta{flex-wrap:wrap;justify-content:center;display:flex}:not(.post-meta-break)+.post-meta-item:before{content:"|";margin:0 .5em}.post-meta-item-icon{margin-right:3px}@media (width<=991px){.post-meta-item-text{display:none}}.post-meta-break{flex-basis:100%;height:0}.post-nav{border-top:1px solid #eee;justify-content:space-between;gap:30px;margin-top:1em;padding:10px 5px 0;display:flex}.post-nav-item{flex:1}.post-nav-item a{border-bottom:0;font-size:.875em;line-height:1.6;display:block}.post-nav-item a:active{top:2px}.post-nav-item .fa{font-size:.75em}.post-nav-item:first-child .fa{margin-right:5px}.post-nav-item:last-child{text-align:right}.post-nav-item:last-child .fa{margin-left:5px}.post-footer{flex-direction:column;justify-content:center;display:flex}.post-eof{background:#ccc;width:8%;height:1px;margin:80px auto 60px}.post-block:last-of-type .post-eof{display:none}.post-copyright ul{background:var(--card-bg-color);border-left:3px solid #ff2a2a;margin:1em 0 0;padding:.5em 1em;list-style:none;position:relative;overflow:hidden}.post-copyright ul:after{content:"";opacity:.1;font-family:"Font Awesome 6 Brands";font-size:200px;position:absolute;top:-150px;right:-50px}.post-tags{text-align:center;margin-top:40px}.post-tags a{font-size:.8125em;display:inline-block}.post-tags a:not(:last-child){margin-right:10px}.social-like{border-top:1px solid #eee;flex-wrap:wrap;justify-content:center;margin-top:1em;padding-top:1em;font-size:.875em;display:flex}.social-like a{border-bottom:none}.reward-container{text-align:center;margin:1em 0 0;padding:1em 0}.reward-container button{color:#fc6423;cursor:pointer;vertical-align:text-top;background:0 0;border:2px solid #fc6423;border-radius:2px;outline:0;padding:0 15px;line-height:2}.reward-container button:hover{color:#fff;background:#fc6423}.post-reward{padding-top:20px;display:none}.post-reward.active{display:block}.post-reward div{display:inline-block}.post-reward div span{display:block}.post-reward img{width:180px;max-width:100%;margin:.8em 2em 0;display:inline-block}@keyframes next-roll{0%{transform:rotate(30deg)}to{transform:rotate(-30deg)}}.category-all-page .category-all-title{text-align:center}.category-all-page .category-all{margin-top:20px}.category-all-page .category-list{margin:0;padding:0;list-style:none}.category-all-page .category-list-item{margin:5px 10px}.category-all-page .category-list-count{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-size:.75em;font-weight:700;line-height:1}.category-all-page .category-list-child{padding-left:10px}.event-list hr{background:#222;margin:20px 0 45px}.event-list hr:after{color:#fff;content:"NOW";background:#222;padding:0 5px;font-weight:700;display:inline-block}.event-list .event{--event-background:#222;--event-foreground:#bbb;--event-title:#fff;background:var(--event-background);padding:15px}.event-list .event .event-summary{color:var(--event-title);border-bottom:0;margin:0;padding:0 0 0 35px;position:relative}.event-list .event .event-summary:before{background:var(--event-title);content:" ";border-radius:50%;width:12px;height:12px;margin-top:-6px;animation:1s ease-in-out infinite alternate dot-flash;position:absolute;top:50%;left:0}.event-list .event:nth-of-type(odd) .event-summary:before{animation-delay:.5s}.event-list .event:not(:last-child){margin-bottom:20px}.event-list .event .event-relative-time{color:var(--event-foreground);padding-left:12px;font-size:12px;font-weight:400;display:inline-block}.event-list .event .event-details{color:var(--event-foreground);padding:6px 0 6px 35px;line-height:18px;display:block}.event-list .event .event-details:before{color:var(--event-foreground);width:14px;margin-right:9px;font-family:"Font Awesome 6 Free";font-weight:900;display:inline-block}.event-list .event .event-details.event-location:before{content:""}.event-list .event .event-details.event-duration:before{content:""}.event-list .event .event-details.event-description:before{content:""}.event-list .event-past{--event-background:#f5f5f5;--event-foreground:#999;--event-title:#222}@keyframes dot-flash{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}ul.breadcrumb{text-align:center;margin:1em 0;padding:0 2em;font-size:.75em;list-style:none}ul.breadcrumb li{display:inline}ul.breadcrumb li:not(:first-child):before{content:"/ ";padding:.5em;font-weight:400}ul.breadcrumb li:last-child{font-weight:700}.tag-cloud{text-align:center}.tag-cloud a{margin:10px;display:inline-block}.tag-cloud-0{color:#aaa;border-bottom-color:#aaa}.tag-cloud-1{color:#9a9a9a;border-bottom-color:#9a9a9a}.tag-cloud-2{color:#8b8b8b;border-bottom-color:#8b8b8b}.tag-cloud-3{color:#7c7c7c;border-bottom-color:#7c7c7c}.tag-cloud-4{color:#6c6c6c;border-bottom-color:#6c6c6c}.tag-cloud-5{color:#5d5d5d;border-bottom-color:#5d5d5d}.tag-cloud-6{color:#4e4e4e;border-bottom-color:#4e4e4e}.tag-cloud-7{color:#3e3e3e;border-bottom-color:#3e3e3e}.tag-cloud-8{color:#2f2f2f;border-bottom-color:#2f2f2f}.tag-cloud-9{color:#202020;border-bottom-color:#202020}.tag-cloud-10{color:#111;border-bottom-color:#111}.utterances{max-width:unset}.search-active{margin-right:var(--dialog-scrollgutter,0);overflow:hidden}.search-pop-overlay{visibility:hidden;z-index:40;background:0 0;width:100%;height:100%;transition:visibility .4s,background .4s;display:flex;position:fixed;top:0;left:0}.search-active .search-pop-overlay{visibility:visible;background:#0000004d}.search-popup{background:var(--card-bg-color);border-radius:5px;width:700px;height:80%;margin:auto;transition:transform .4s;transform:scale(0)}.search-active .search-popup{transform:scale(1)}@media (width<=767px){.search-popup{border-radius:0;width:100%;height:100%}}.search-popup .search-icon,.search-popup .popup-btn-close{color:#999;padding:0 10px;font-size:18px}.search-popup .popup-btn-close{cursor:pointer}.search-popup .popup-btn-close:hover .fa{color:#222}.search-popup .search-header{background:#eee;border-top-left-radius:5px;border-top-right-radius:5px;padding:5px;display:flex}.search-popup input.search-input{background:0 0;border:0;outline:0;width:100%}.search-popup input.search-input::-webkit-search-cancel-button{display:none}.search-popup .search-result-container{flex-direction:column;height:calc(100% - 55px);padding:5px 25px;display:flex;overflow:auto}.search-popup .search-result-container hr{flex-shrink:0;margin:5px 0 10px}.search-popup .search-result-container hr:first-child{display:none}.search-popup .search-result-list{margin:0 5px;padding:0}.search-popup a.search-result-title{font-weight:700}.search-popup p.search-result{border-bottom:1px dashed #ccc;margin:0 0 10px;padding:5px 0}.search-popup .search-input-container{flex-grow:1;padding:2px}.search-popup .search-result-icon{color:#ccc;margin:auto}mark.search-keyword{color:#ff2a2a;background:0 0;border-bottom:1px dashed #ff2a2a;font-weight:700}.use-motion .animated{visibility:inherit;animation-fill-mode:none}.use-motion .sidebar .animated{animation-fill-mode:both}header.header{background:var(--content-bg-color);border-radius:initial;box-shadow:initial}@media (width<=991px){header.header{border-radius:initial}}.main{justify-content:space-between;align-items:stretch;width:calc(100% - 20px);margin:0 auto;display:flex}@media (width<=767px){.main{width:auto}}@media (width>=1200px){.main{width:1160px}}@media (width>=1600px){.main{width:73%}}@media (width<=991px){.main{width:auto;display:block}}.main-inner{border-radius:initial;box-sizing:border-box;width:calc(100% - 252px)}@media (width<=991px){.main-inner{border-radius:initial;width:100%}}.footer-inner{padding-left:252px}@media (width<=991px){.footer-inner{width:auto;padding-left:0;padding-right:0}}.column{width:240px}@media (width<=991px){.column{width:auto}}.site-brand-container{background:var(--theme-color)}@media (width<=991px){.site-nav-on .site-brand-container{box-shadow:0 0 16px #00000080}}.site-meta{padding:20px 0}@media (width>=768px) and (width<=991px){.site-nav-toggle,.site-nav-right{flex-direction:column;justify-content:center;display:flex}}.site-nav-toggle .toggle,.site-nav-right .toggle{color:#fff}.site-nav-toggle .toggle .toggle-line,.site-nav-right .toggle .toggle-line{background:#fff}@media (width>=768px) and (width<=991px){.site-nav{--scroll-height:0;visibility:hidden;height:0;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height);visibility:unset}}.menu .menu-item{margin:0;display:block}.menu .menu-item a{align-items:center;padding:5px 20px;transition-property:background-color;display:flex;position:relative}.menu .menu-item a .badge{margin-left:auto}@media (width<=991px){.menu .menu-item.menu-item-search{display:none}}.sub-menu{margin:0;padding:6px 0}.sub-menu .menu-item{display:inline-block}.sub-menu .menu-item a{padding:initial;background:0 0;margin:5px 10px}.sub-menu .menu-item a:hover{color:#fc6423;background:0 0}.sub-menu .menu-item-active{color:#fc6423;border-bottom-color:#fc6423}.sub-menu .menu-item-active:hover{border-bottom-color:#fc6423}@media (width>=992px){.sidebar{position:sticky;top:12px}.sidebar-toggle{display:none}.sidebar-inner{background:var(--content-bg-color);border-radius:initial;box-shadow:initial;box-sizing:border-box;color:var(--text-color);visibility:hidden;max-height:calc(100vh - 24px);margin-top:12px}.site-state-item{padding:0 10px}.sidebar .sidebar-button{border-top:1px dotted #ccc;border-bottom:1px dotted #ccc}.sidebar .sidebar-button button{color:#fc6423;border:0;width:100%;display:block}.sidebar .sidebar-button button:hover{color:#e34603;background:0 0;border:0}.links-of-author{flex-wrap:wrap;justify-content:center;display:flex}.links-of-author-item{width:50%;margin:5px 0 0}.links-of-author-item a{box-sizing:border-box;text-overflow:ellipsis;white-space:nowrap;border-bottom:0;border-radius:4px;max-width:100%;padding:0 5px;display:inline-block;overflow:hidden}.links-of-author-item a:hover{background:var(--body-bg-color)}.links-of-blogroll-item a{padding:0 5px}}.main-inner{background:var(--content-bg-color);box-shadow:initial;padding:40px}@media (width<=991px){.main-inner{padding:20px}}.sub-menu{border-bottom:1px solid #ddd}.post-block:first-of-type{padding-top:40px}@media (width<=767px){.pagination{margin-bottom:10px}}</style><link integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css rel=stylesheet><link integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css rel=stylesheet><script integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js></script><script class=next-config data-name=main type=application/json>{"hostname":"oz1010.github.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"stackoverflow-light","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":100,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script defer src=/js/config.js></script><meta content="环境搭建 Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令uname -r。 对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交叉编译工具变量CROSS_COMPILE为指定的工具。 对于通用内核来说，可以使用包管理工具直接下载内核，例如在Ubuntu系统中使用命令sudo apt-get install -y linux-hea" name=description><meta content=article property=og:type><meta content=Linux驱动开发笔记 property=og:title><meta content=https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/index.html property=og:url><meta content="oz1010's blog" property=og:site_name><meta content="环境搭建 Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令uname -r。 对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交叉编译工具变量CROSS_COMPILE为指定的工具。 对于通用内核来说，可以使用包管理工具直接下载内核，例如在Ubuntu系统中使用命令sudo apt-get install -y linux-hea" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-04-24T01:47:35.000Z property=article:published_time><meta content=2025-10-13T08:54:27.235Z property=article:modified_time><meta content=oz1010 property=article:author><meta content=summary name=twitter:card><link href=https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","path":"2024/04/24/Linux驱动开发笔记/","title":"Linux驱动开发笔记"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Linux驱动开发笔记 | oz1010's blog</title><script integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script defer src=/js/utils.js></script><script defer src=/js/motion.js></script><script defer src=/js/sidebar.js></script><script defer src=/js/next-boot.js></script><script integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js></script><script defer src=/js/third-party/search/local-search.js></script><script defer src=/js/third-party/pace.js></script><noscript><link href=/css/noscript.css rel=stylesheet></noscript><link title="oz1010's blog" href=/atom.xml rel=alternate type=application/atom+xml><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>oz1010's blog</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>记录生活或技能</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>4</span></a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>16</span></a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>42</span></a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA><span class=nav-number>1.</span> <span class=nav-text>环境搭建</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B><span class=nav-number>2.</span> <span class=nav-text>驱动简介</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6><span class=nav-number>2.1.</span> <span class=nav-text>基本框架</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8><span class=nav-number>3.</span> <span class=nav-text>字符设备驱动</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0><span class=nav-number>3.1.</span> <span class=nav-text>关键函数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E5%A4%87%E5%8F%B7><span class=nav-number>3.1.1.</span> <span class=nav-text>设备号</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A9%B1%E5%8A%A8%E5%86%85%E5%AD%98><span class=nav-number>3.1.2.</span> <span class=nav-text>驱动内存</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87><span class=nav-number>3.1.3.</span> <span class=nav-text>字符设备</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B6%E4%BB%96%E5%AE%8F><span class=nav-number>3.1.4.</span> <span class=nav-text>其他宏</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%BC%93%E5%AD%98%E8%AE%BE%E5%A4%87><span class=nav-number>3.2.</span> <span class=nav-text>简单的模拟缓存设备</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E><span class=nav-number>4.</span> <span class=nav-text>阻塞和非阻塞</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E5%92%8C%E5%BC%82%E6%AD%A5io><span class=nav-number>5.</span> <span class=nav-text>异步通知和异步I/O</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5><span class=nav-number>5.1.</span> <span class=nav-text>异步通知</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BC%82%E6%AD%A5io><span class=nav-number>5.2.</span> <span class=nav-text>异步I/O</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%B8%AD%E6%96%AD%E4%B8%8E%E6%97%B6%E9%92%9F><span class=nav-number>6.</span> <span class=nav-text>中断与时钟</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-1><span class=nav-number>6.1.</span> <span class=nav-text>关键函数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A1%B6%E5%8D%8A%E9%83%A8><span class=nav-number>6.1.1.</span> <span class=nav-text>顶半部</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%95%E5%8D%8A%E9%83%A8><span class=nav-number>6.1.2.</span> <span class=nav-text>底半部</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8><span class=nav-number>6.2.</span> <span class=nav-text>内核定时器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E6%97%B6%E5%99%A8><span class=nav-number>6.2.1.</span> <span class=nav-text>定时器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97><span class=nav-number>6.2.2.</span> <span class=nav-text>工作队列</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%86%85%E6%A0%B8%E5%BB%B6%E6%97%B6><span class=nav-number>6.3.</span> <span class=nav-text>内核延时</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%9F%AD%E5%BB%B6%E6%97%B6><span class=nav-number>6.3.1.</span> <span class=nav-text>短延时</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%86%85%E5%AD%98%E4%B8%8Eio%E8%AE%BF%E9%97%AE><span class=nav-number>7.</span> <span class=nav-text>内存与I/O访问</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86><span class=nav-number>7.1.</span> <span class=nav-text>Linux内存管理</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%86%85%E5%AD%98%E5%AD%98%E5%8F%96><span class=nav-number>7.2.</span> <span class=nav-text>内存存取</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7><span class=nav-number>7.2.1.</span> <span class=nav-text>用户空间动态申请</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7><span class=nav-number>7.2.2.</span> <span class=nav-text>内核空间动态申请</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#io%E7%AB%AF%E5%8F%A3%E5%92%8Cio%E5%86%85%E5%AD%98><span class=nav-number>7.3.</span> <span class=nav-text>I/O端口和I/O内存</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#io%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE><span class=nav-number>7.3.1.</span> <span class=nav-text>I/O端口访问</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#io%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE><span class=nav-number>7.3.2.</span> <span class=nav-text>I/O内存访问</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BEio%E7%AB%AF%E5%8F%A3%E5%92%8Cio%E5%86%85%E5%AD%98><span class=nav-number>7.3.3.</span> <span class=nav-text>申请释放I/O端口和I/O内存</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#io%E7%AB%AF%E5%8F%A3%E5%92%8Cio%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B><span class=nav-number>7.3.4.</span> <span class=nav-text>I/O端口和I/O内存访问流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4><span class=nav-number>7.3.5.</span> <span class=nav-text>设备地址映射到用户空间</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#io%E5%86%85%E5%AD%98%E9%9D%99%E6%80%81%E6%98%A0%E5%B0%84><span class=nav-number>7.4.</span> <span class=nav-text>I/O内存静态映射</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#dma><span class=nav-number>7.5.</span> <span class=nav-text>DMA</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#dma%E4%B8%8Ecache%E4%B8%80%E8%87%B4%E6%80%A7><span class=nav-number>7.5.1.</span> <span class=nav-text>DMA与Cache一致性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#linux%E4%B8%8B%E7%9A%84dma%E7%BC%96%E7%A8%8B><span class=nav-number>7.5.2.</span> <span class=nav-text>Linux下的DMA编程</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3><span class=nav-number>8.</span> <span class=nav-text>Linux设备驱动的软件架构思想</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B0%86globalfifo%E4%BD%9C%E4%B8%BAplatform%E8%AE%BE%E5%A4%87><span class=nav-number>8.0.1.</span> <span class=nav-text>将globalfifo作为platform设备</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3><span class=nav-number>8.1.</span> <span class=nav-text>设备驱动分层思想</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8><span class=nav-number>9.</span> <span class=nav-text>Linux块设备驱动</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84><span class=nav-number>9.1.</span> <span class=nav-text>Linux块设备驱动结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#gendisk><span class=nav-number>9.1.1.</span> <span class=nav-text>gendisk</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#biorequest%E5%92%8Crequest_queue><span class=nav-number>9.1.2.</span> <span class=nav-text>bio、request和request_queue</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#io%E8%B0%83%E5%BA%A6%E5%99%A8><span class=nav-number>9.1.3.</span> <span class=nav-text>I/O调度器</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#linux%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96><span class=nav-number>9.2.</span> <span class=nav-text>Linux块设备驱动初始化</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9D%97%E8%AE%BE%E5%A4%87%E7%9A%84%E6%89%93%E5%BC%80%E9%87%8A%E6%94%BE><span class=nav-number>9.3.</span> <span class=nav-text>块设备的打开释放</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9D%97%E8%AE%BE%E5%A4%87ioctl%E5%87%BD%E6%95%B0><span class=nav-number>9.4.</span> <span class=nav-text>块设备ioctl函数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84io%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86><span class=nav-number>9.5.</span> <span class=nav-text>块设备驱动的I/O请求处理</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9E%E4%BE%8Bvmem_disk%E9%A9%B1%E5%8A%A8><span class=nav-number>9.6.</span> <span class=nav-text>实例：vmem_disk驱动</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#vmem_disk%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86><span class=nav-number>9.6.1.</span> <span class=nav-text>vmem_disk硬件原理</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E9%A1%B9><span class=nav-number>10.</span> <span class=nav-text>驱动开发常用项</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%A9%B1%E5%8A%A8%E5%B1%9E%E6%80%A7%E9%A1%B9><span class=nav-number>10.1.</span> <span class=nav-text>驱动属性项</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-1><span class=nav-number>10.2.</span> <span class=nav-text>工作队列</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%99%84%E5%BD%95><span class=nav-number>11.</span> <span class=nav-text>附录</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>11.1.</span> <span class=nav-text>常用命令</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%82%E8%80%83><span class=nav-number>11.2.</span> <span class=nav-text>参考</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=oz1010 class=site-author-image itemprop=image src=/images/avatar.jpg><p class=site-author-name itemprop=name>oz1010<div class=site-description itemprop=description>普通而有趣的技术员</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>42</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>16</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>4</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/oz1010" href=https://github.com/oz1010 target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a rel="noopener me" title="E-Mail → mailto:alfdxl@163.com" href=mailto:alfdxl@163.com target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span></div><div class="cc-license animated" itemprop=license><a class=cc-opacity href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><img alt="Creative Commons" src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Linux驱动开发笔记 | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Linux驱动开发笔记</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-24 09:47:35" datetime=2024-04-24T09:47:35+08:00>2024-04-24</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-10-13 16:54:27" datetime=2025-10-13T16:54:27+08:00 itemprop=dateModified>2025-10-13</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> ， <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/Driver/ itemprop=url rel=index><span itemprop=name>Driver</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>9.5k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>35 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=环境搭建>环境搭建</h1><p>Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令<code>uname -r</code>。<p>对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交叉编译工具变量<code>CROSS_COMPILE</code>为指定的工具。<p>对于通用内核来说，可以使用包管理工具直接下载内核，例如在Ubuntu系统中使用命令<code>sudo apt-get install -y linux-headers-$(uname -r)</code>。默认内核安装路径在<code>/lib/modules/$(uname -r)</code>。编译驱动时，需要将内核路径指定到<code>/lib/modules/$(uname -r)/build</code>。对应的头文件在路径<code>/usr/src/linux-headers-$(uname -r)/include</code>中。<p>对于wsl来说，与通用内核类似，只是内核需要单独从<a href=https://github.com/microsoft/WSL2-Linux-Kernel/releases rel=noopener target=_blank>微软wsl2内核仓库</a>下载。然后手动进行编译安装。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装编译wsl特供内核依赖</span></span><br><span class=line><span class=built_in>sudo</span> apt-get install -y libelf-dev build-essential pkg-config bison build-essential flex libssl-dev libelf-dev bc dwarves</span><br><span class=line></span><br><span class=line><span class=comment># 解压进入到目录</span></span><br><span class=line>tar -xvf WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1.tar.gz</span><br><span class=line><span class=built_in>cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1</span><br><span class=line><span class=built_in>cp</span> Microsoft/config-wsl .config</span><br><span class=line></span><br><span class=line><span class=comment># 编译安装</span></span><br><span class=line><span class=built_in>sudo</span> make scripts</span><br><span class=line><span class=built_in>sudo</span> make modules -j$(<span class=built_in>nproc</span>)</span><br><span class=line><span class=built_in>sudo</span> make modules_install</span><br><span class=line></span><br><span class=line><span class=built_in>cd</span> ..</span><br></pre></table></figure><h1 id=驱动简介>驱动简介</h1><p>Linux驱动可以使用多种方式加载到系统中。<h2 id=基本框架>基本框架</h2><p><code>hello.c</code>文件的内容如下<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/module.h></span> <span class=comment>// 包含内核编程最常用的函数声明，如printk</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/kernel.h></span> <span class=comment>// 包含模块编程相关的宏定义，如：MODULE_LICENSE</span></span></span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>init初始化函数在模块被插入进内核时调用，主要作用为驱动功能做好预备工作被称为模块的入口函数</span></span><br><span class=line><span class=comment>  </span></span><br><span class=line><span class=comment>__init的作用 : </span></span><br><span class=line><span class=comment>  1. 一个宏，展开后为：__attribute__ ((__section__ (".init.text"))) 实际是gcc的一个特殊链接标记</span></span><br><span class=line><span class=comment>  2. 指示链接器将该函数放置在 .init.text区段</span></span><br><span class=line><span class=comment>  3. 在模块插入时方便内核从ko文件指定位置读取入口函数的指令到特定内存位置</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=type>int</span> __init <span class="title function_">hello_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>	<span class=comment>// 具体初始化逻辑</span></span><br><span class=line>    printk(<span class=string>"hello module init.\n"</span>);</span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>module_init 宏</span></span><br><span class=line><span class=comment>1. 用法：module_init(模块入口函数名) </span></span><br><span class=line><span class=comment>2. 动态加载模块，对应函数被调用</span></span><br><span class=line><span class=comment>3. 静态加载模块，内核启动过程中对应函数被调用</span></span><br><span class=line><span class=comment>4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.initcall段），方便系统初始化统一调用。</span></span><br><span class=line><span class=comment>5. 对于动态加载的模块，由于内核模块的默认入口函数名是init_module,用该宏可以给对应模块入口函数起别名</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>module_init(hello_init);</span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>exit退出函数在模块从内核中被移除时调用，主要作用做些init函数的反操作被称为模块的出口函数</span></span><br><span class=line><span class=comment>  </span></span><br><span class=line><span class=comment>__exit的作用：</span></span><br><span class=line><span class=comment>  1. 一个宏，展开后为：__attribute__ ((__section__ (".exit.text"))) 实际也是gcc的一个特殊链接标记</span></span><br><span class=line><span class=comment>  2. 指示链接器将该函数放置在 .exit.text区段</span></span><br><span class=line><span class=comment>  3. 在模块插入时方便内核从ko文件指定位置读取出口函数的指令到另一个特定内存位置</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=type>void</span> __exit <span class="title function_">hello_exit</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>	<span class=comment>// 具体反初始化逻辑</span></span><br><span class=line>    printk(<span class=string>"hello module exit.\n"</span>);</span><br><span class=line>}</span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>module_exit宏</span></span><br><span class=line><span class=comment>  1. 用法：module_exit(模块出口函数名)</span></span><br><span class=line><span class=comment>  2. 动态加载的模块在卸载时，对应函数被调用</span></span><br><span class=line><span class=comment>  3. 静态加载的模块可以认为在系统退出时，对应函数被调用，实际上对应函数被忽略</span></span><br><span class=line><span class=comment>  4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.exitcall段），方便系统必要时统一调用，实际上该宏在静态加载时没有意义，因为静态编译的驱动无法卸载。</span></span><br><span class=line><span class=comment>  5. 对于动态加载的模块，由于内核模块的默认出口函数名是cleanup_module,用该宏可以给对应模块出口函数起别名</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>module_exit(hello_exit);</span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>MODULE_LICENSE(字符串常量);</span></span><br><span class=line><span class=comment>字符串常量内容为源码的许可证协议 可以是"GPL" "GPL v2"  "GPL and additional rights"  "Dual BSD/GPL"  "Dual MIT/GPL" "Dual MPL/GPL"等, "GPL"最常用</span></span><br><span class=line><span class=comment>其本质也是一个宏，宏体也是一个特殊链接标记，指示链接器在ko文件指定位置说明本模块源码遵循的许可证</span></span><br><span class=line><span class=comment>在模块插入到内核时，内核会检查新模块的许可证是不是也遵循GPL协议，如果发现不遵循GPL，则在插入模块时打印抱怨信息：</span></span><br><span class=line><span class=comment>	myhello：module license 'unspecified' taints kernel</span></span><br><span class=line><span class=comment>	Disabling lock debugging due to kernel taint</span></span><br><span class=line><span class=comment>也会导致新模块没法使用一些内核其它模块提供的高级功能</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>MODULE_LICENSE(<span class=string>"GPL"</span>);</span><br><span class=line></span><br></pre></table></figure><p><code>Makefile</code>文件的内容如下<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(KERNELRELEASE)</span>,)</span><br><span class=line> </span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(ARCH)</span>,arm)</span><br><span class=line>KERNELDIR ?= /root/ldd4/linux-4.14.334</span><br><span class=line><span class=comment># OBJECTDIR ?= /root/ldd4/objects/vexpress-v2p-ca9</span></span><br><span class=line>ROOTFS ?= /root/ldd4/rootfs-arm32</span><br><span class=line>CROSS_COMPILE ?= arm-linux-gnueabi-</span><br><span class=line><span class=keyword>else</span></span><br><span class=line>KERNELDIR ?= /lib/modules/<span class=variable>$(<span class=built_in>shell</span> uname -r)</span>/build</span><br><span class=line><span class=keyword>endif</span></span><br><span class=line>PWD := <span class=variable>$(<span class=built_in>shell</span> pwd)</span></span><br><span class=line> </span><br><span class=line><span class=section>modules:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules</span><br><span class=line> </span><br><span class=line><span class=section>modules_install:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules INSTALL_MOD_PATH=<span class=variable>$(ROOTFS)</span> modules_install</span><br><span class=line> </span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf  *.o  *.ko  .*.cmd  *.mod*  modules.order  Module.symvers   .tmp_versions</span><br><span class=line> </span><br><span class=line><span class=keyword>else</span></span><br><span class=line>	obj-m += hello.o</span><br><span class=line></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line></span><br></pre></table></figure><p>驱动编译成功后，使用附录中的常用命令进行测试。<h1 id=字符设备驱动>字符设备驱动</h1><p>Linux字符设备会涉及到关键数据结构<code>cdev</code>及<code>file_operations</code>结构体的操作方法。<p><code>cdev</code>定义在文件<code>include/linux/cdev.h</code>中，主要描述设备驱动基本信息。<p><code>file_operations</code>定义在文件<code>include/linux/fs.h</code>中，主要描述设备驱动提供的基本接口函数，比如open、read、write、llseek、unlocked_ioctl等基本操作函数。<h2 id=关键函数>关键函数</h2><p>初始化基本流程为：注册设备号->申请驱动内存->初始化与新增字符设备描述符<p>注销基本流程为：删除字符设备描述符->释放驱动内存->删除设备号<h3 id=设备号>设备号</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> u32 <span class=type>dev_t</span>;</span><br><span class=line><span class=comment>// 生成设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MKDEV(ma,minor) (((ma) &lt;&lt; 20) | (mi))</span></span><br><span class=line><span class=comment>// 获取主设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS))</span></span><br><span class=line><span class=comment>// 获取次设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MINOR(dev)	((unsigned int) ((dev) & MINORMASK))</span></span><br></pre></table></figure><p><code>dev_t</code>为设备编号类型，为32位无符号整数。<ul><li>ma为主设备号major<li>mi为次设备号minor</ul><p>在创建设备节点时，通过设备号来绑定驱动模块。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 静态注册设备号</span></span><br><span class=line><span class=type>int</span> <span class="title function_">register_chrdev_region</span><span class=params>(<span class=type>dev_t</span> dev, <span class=type>unsigned</span> count, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 动态申请设备号</span></span><br><span class=line><span class=type>int</span> <span class="title function_">alloc_chrdev_region</span><span class=params>(<span class=type>dev_t</span> *dev, <span class=type>unsigned</span> minor, <span class=type>unsigned</span> count, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 注销设备号</span></span><br><span class=line><span class=type>void</span> <span class="title function_">unregister_chrdev_region</span><span class=params>(<span class=type>dev_t</span> dev, <span class=type>unsigned</span> count)</span>;</span><br></pre></table></figure><ul><li>dev为设备编号，动态申请时通过指针传值方式返回<li>minor为需要分配的起始次设备号<li>count为需要分配的设备数量，主设备号一样，次设备号依次累加<li>name为设备驱动名称，可以在<code>/proc/devices</code>中查看</ul><h3 id=驱动内存>驱动内存</h3><p>值得注意的是，设备驱动运行在内核空间，因此内存需要使用内核内存管理函数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请内存并置零。</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kzalloc</span><span class=params>(<span class=type>size_t</span> size, <span class=type>gfp_t</span> flags)</span>;</span><br><span class=line><span class=comment>// 内存释放</span></span><br><span class=line><span class=type>void</span> <span class="title function_">kfree</span><span class=params>(<span class=type>const</span> <span class=type>void</span> *p)</span></span><br></pre></table></figure><ul><li>size申请内存大小<li>flags内存标志位，这里使用GFP_KERNEL<li>p内存指针指向待释放的内存</ul><h3 id=字符设备>字符设备</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 初始化字符设备描述符</span></span><br><span class=line><span class=type>void</span> <span class="title function_">cdev_init</span><span class=params>(<span class=keyword>struct</span> cdev *cdev, <span class=type>const</span> <span class=keyword>struct</span> file_operations *ops)</span>;</span><br><span class=line><span class=comment>// 新增字符设备描述符</span></span><br><span class=line><span class=type>int</span> <span class="title function_">cdev_add</span><span class=params>(<span class=keyword>struct</span> cdev *cdev, <span class=type>dev_t</span> dev, <span class=type>unsigned</span> count)</span>;</span><br><span class=line><span class=comment>// 删除字符设备描述符</span></span><br><span class=line><span class=type>void</span> <span class="title function_">cdev_del</span><span class=params>(<span class=keyword>struct</span> cdev *cdev)</span>;</span><br></pre></table></figure><ul><li>cdev字符设备描述符<li>ops文件操作描述符<li>dev设备编号</ul><h3 id=其他宏>其他宏</h3><table><thead><tr class=header><th>名称<th>作用<th>必选<tbody><tr class=odd><td>module_init<td>导出设备驱动的初始化函数<td>✅<tr class=even><td>module_exit<td>导出设备驱动的退出函数<td>✅<tr class=odd><td>module_param<td>导出设备驱动参数<td>❌<tr class=even><td>MODULE_LICENSE<td>声明许可信息<td>✅<tr class=odd><td>MODULE_AUTHOR<td>声明作者信息<td>❌<tr class=even><td>MODULE_DESCRIPTION<td>声明描述信息<td>❌</table><h2 id=简单的模拟缓存设备>简单的模拟缓存设备</h2><p>支持最多创建10个设备节点，每个节点可以读取或写入数据。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br><span class=line>165</span><br><span class=line>166</span><br><span class=line>167</span><br><span class=line>168</span><br><span class=line>169</span><br><span class=line>170</span><br><span class=line>171</span><br><span class=line>172</span><br><span class=line>173</span><br><span class=line>174</span><br><span class=line>175</span><br><span class=line>176</span><br><span class=line>177</span><br><span class=line>178</span><br><span class=line>179</span><br><span class=line>180</span><br><span class=line>181</span><br><span class=line>182</span><br><span class=line>183</span><br><span class=line>184</span><br><span class=line>185</span><br><span class=line>186</span><br><span class=line>187</span><br><span class=line>188</span><br><span class=line>189</span><br><span class=line>190</span><br><span class=line>191</span><br><span class=line>192</span><br><span class=line>193</span><br><span class=line>194</span><br><span class=line>195</span><br><span class=line>196</span><br><span class=line>197</span><br><span class=line>198</span><br><span class=line>199</span><br><span class=line>200</span><br><span class=line>201</span><br><span class=line>202</span><br><span class=line>203</span><br><span class=line>204</span><br><span class=line>205</span><br><span class=line>206</span><br><span class=line>207</span><br><span class=line>208</span><br><span class=line>209</span><br><span class=line>210</span><br><span class=line>211</span><br><span class=line>212</span><br><span class=line>213</span><br><span class=line>214</span><br><span class=line>215</span><br><span class=line>216</span><br><span class=line>217</span><br><span class=line>218</span><br><span class=line>219</span><br><span class=line>220</span><br><span class=line>221</span><br><span class=line>222</span><br><span class=line>223</span><br><span class=line>224</span><br><span class=line>225</span><br><span class=line>226</span><br><span class=line>227</span><br><span class=line>228</span><br><span class=line>229</span><br><span class=line>230</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/module.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/fs.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/init.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/cdev.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/slab.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/uaccess.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_SIZE 0x1000</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MAJOR 230</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MINOR 0</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> DEVICE_NUM 10</span></span><br><span class=line></span><br><span class=line><span class=comment>// 为避免多个设备命令污染，Linux推荐使用_IO _IOR _IOW _IOWR来定义ioctl的命令</span></span><br><span class=line><span class=comment>// 已经定义的设备类型可以见内核文档Documentation/ioctl/ioctl-number.txt</span></span><br><span class=line><span class=comment>// 内核预定义的控制命令不会被设备驱动处理，这些定义在include/uapi/asm-generic/ioctls.h</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MAGIC <span class=string>'g'</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MEM_CLEAR _IO(GLOBALMEM_MAGIC, 0)</span></span><br><span class=line></span><br><span class=line><span class=type>static</span> <span class=type>int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class=line>module_param(globalmem_major, <span class=type>int</span>, S_IRUGO);</span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> <span class=title>globalmem_dev</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// 设备号</span></span><br><span class=line>    <span class=type>dev_t</span> id;</span><br><span class=line>    <span class=comment>// 字符设备</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>cdev</span> <span class=title>cd</span>;</span></span><br><span class=line>    <span class=comment>// 模拟的设备内存</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>char</span> mem[GLOBALMEM_SIZE];</span><br><span class=line>} <span class=type>globalmem_dev_t</span>;</span><br><span class=line></span><br><span class=line><span class=type>globalmem_dev_t</span> *globalmem_devp;</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的打开函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">globalmem_open</span><span class=params>(<span class=keyword>struct</span> inode *inode, <span class=keyword>struct</span> file *filp)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = container_of(inode->i_cdev, <span class=type>globalmem_dev_t</span>, cd);</span><br><span class=line>    filp->private_data = dev;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的释放函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">globalmem_release</span><span class=params>(<span class=keyword>struct</span> inode *, <span class=keyword>struct</span> file *)</span></span><br><span class=line>{</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的I/O控制函数</span></span><br><span class=line><span class=type>static</span> <span class=type>long</span> <span class="title function_">globalmem_ioctl</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>unsigned</span> <span class=type>int</span> cmd, <span class=type>unsigned</span> <span class=type>long</span> arg)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>switch</span> (cmd)</span><br><span class=line>    {</span><br><span class=line>    <span class=keyword>case</span> MEM_CLEAR:</span><br><span class=line>        <span class=built_in>memset</span>(dev->mem, <span class=number>0</span>, GLOBALMEM_SIZE);</span><br><span class=line>        printk(KERN_INFO <span class=string>"globalmem is set to zero\n"</span>);</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>        <span class=keyword>return</span> -EINVAL;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的读操作。*ppos是要读的位置相对于内存开头的偏移，如果大于或等于GLOBALMEM_SIZE，则会返回0（EOF）</span></span><br><span class=line><span class=type>static</span> <span class=type>ssize_t</span> <span class="title function_">globalmem_read</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>char</span> __user *buf, <span class=type>size_t</span> size, <span class=type>loff_t</span> *ppos)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> p = *ppos;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> count = size;</span><br><span class=line>    <span class=type>int</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (p >= GLOBALMEM_SIZE)</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>if</span> (count > GLOBALMEM_SIZE - p)</span><br><span class=line>        count = GLOBALMEM_SIZE - p;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (copy_to_user(buf, dev->mem + p, count))</span><br><span class=line>    {</span><br><span class=line>        ret = -EFAULT;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        *ppos += count;</span><br><span class=line>        ret = count;</span><br><span class=line>        printk(KERN_INFO <span class=string>"read %u bytes(s) from %lu\n"</span>, count, p);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 驱动设备的写操作</span></span><br><span class=line><span class=type>static</span> <span class=type>ssize_t</span> <span class="title function_">globalmem_write</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>const</span> <span class=type>char</span> __user *buf, <span class=type>size_t</span> size, <span class=type>loff_t</span> *ppos)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> p = *ppos;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> count = size;</span><br><span class=line>    <span class=type>int</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (p > GLOBALMEM_SIZE)</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>if</span> (count > GLOBALMEM_SIZE - p)</span><br><span class=line>        count = GLOBALMEM_SIZE - p;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (copy_from_user(dev->mem + p, buf, count))</span><br><span class=line>        ret = -EFAULT;</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        *ppos += count;</span><br><span class=line>        ret = count;</span><br><span class=line>        printk(KERN_INFO <span class=string>"written %u bytes(s) from %lu\n"</span>, count, p);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的定位操作。</span></span><br><span class=line><span class=type>static</span> <span class=type>loff_t</span> <span class="title function_">globalmem_llseek_impl</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>loff_t</span> offset, <span class=type>int</span> orig)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>loff_t</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>loff_t</span> f_pos = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>switch</span> (orig)</span><br><span class=line>    {</span><br><span class=line>    <span class=keyword>case</span> <span class=number>1</span>: <span class=comment>/* 从内存当前位置开始seek */</span></span><br><span class=line>        f_pos = filp->f_pos;</span><br><span class=line>    <span class=keyword>case</span> <span class=number>0</span>: <span class=comment>/* 从内存开头位置seek */</span></span><br><span class=line>        <span class=keyword>if</span> ((f_pos + offset) &lt; <span class=number>0</span>)</span><br><span class=line>        {</span><br><span class=line>            ret = -EINVAL;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> ((f_pos + offset) > GLOBALMEM_SIZE)</span><br><span class=line>        {</span><br><span class=line>            ret = -EINVAL;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        filp->f_pos = f_pos;</span><br><span class=line>        ret = filp->f_pos;</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>        ret = -EINVAL;</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的文件操作结构体</span></span><br><span class=line><span class=type>static</span> <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>file_operations</span> <span class=title>globalmem_fops</span> =</span> {</span><br><span class=line>    .owner = THIS_MODULE,</span><br><span class=line>    .llseek = globalmem_llseek_impl,</span><br><span class=line>    .read = globalmem_read,</span><br><span class=line>    .write = globalmem_write,</span><br><span class=line>    .unlocked_ioctl = globalmem_ioctl,</span><br><span class=line>    .open = globalmem_open,</span><br><span class=line>    .release = globalmem_release,</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=comment>// cdev的初始化和添加</span></span><br><span class=line><span class=type>static</span> <span class=type>void</span> <span class="title function_">globalmem_setup_cdev</span><span class=params>(<span class=type>globalmem_dev_t</span> *dev)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> err;</span><br><span class=line>    cdev_init(&dev->cd, &globalmem_fops);</span><br><span class=line>    dev->cd.owner = THIS_MODULE;</span><br><span class=line>    err = cdev_add(&dev->cd, dev->id, <span class=number>1</span>);</span><br><span class=line>    <span class=keyword>if</span> (err)</span><br><span class=line>        printk(KERN_NOTICE <span class=string>"Error %d adding globalmem"</span>, err);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的初始化函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> __init <span class="title function_">globalmem_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> ret;</span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 设备号的申请</span></span><br><span class=line>    <span class=type>dev_t</span> id = MKDEV(globalmem_major, GLOBALMEM_MINOR);</span><br><span class=line>    <span class=keyword>if</span> (globalmem_major)</span><br><span class=line>        <span class=comment>// 1. 静态申请设备号</span></span><br><span class=line>        ret = register_chrdev_region(id, DEVICE_NUM, <span class=string>"globalmemND"</span>);</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        <span class=comment>// 2. 动态申请设备号</span></span><br><span class=line>        ret = alloc_chrdev_region(&id, <span class=number>0</span>, DEVICE_NUM, <span class=string>"globalmemND"</span>);</span><br><span class=line>        globalmem_major = MAJOR(id);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (ret &lt; <span class=number>0</span>)</span><br><span class=line>        <span class=keyword>return</span> ret;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 从内核中申请一份globalmem_dev的内存并清零</span></span><br><span class=line>    globalmem_devp = kzalloc(<span class=keyword>sizeof</span>(<span class=type>globalmem_dev_t</span>) * DEVICE_NUM, GFP_KERNEL);</span><br><span class=line>    <span class=keyword>if</span> (!globalmem_devp)</span><br><span class=line>    {</span><br><span class=line>        ret = -ENOMEM;</span><br><span class=line>        <span class=keyword>goto</span> fail_malloc;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class=line>    {</span><br><span class=line>        (globalmem_devp + i)->id = MKDEV(globalmem_major, i);</span><br><span class=line>        globalmem_setup_cdev(globalmem_devp + i);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>fail_malloc:</span><br><span class=line>    unregister_chrdev_region(id, DEVICE_NUM);</span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 导出设备驱动的初始化函数</span></span><br><span class=line>module_init(globalmem_init);</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的退出函数</span></span><br><span class=line><span class=type>static</span> <span class=type>void</span> __exit <span class="title function_">globalmem_exit</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class=line>        cdev_del(&(globalmem_devp + i)->cd);</span><br><span class=line>    kfree(globalmem_devp);</span><br><span class=line>    unregister_chrdev_region(globalmem_devp->id, DEVICE_NUM);</span><br><span class=line>}</span><br><span class=line><span class=comment>// 导出设备驱动的退出函数</span></span><br><span class=line>module_exit(globalmem_exit);</span><br><span class=line></span><br><span class=line><span class=comment>// 作者版权声明</span></span><br><span class=line>MODULE_AUTHOR(<span class=string>"johnny &lt;johnny@gmail.com>"</span>);</span><br><span class=line>MODULE_LICENSE(<span class=string>"GPL v2"</span>);</span><br><span class=line></span><br></pre></table></figure><h1 id=阻塞和非阻塞>阻塞和非阻塞</h1><h1 id=异步通知和异步io>异步通知和异步I/O</h1><h2 id=异步通知>异步通知</h2><p>异步通知使用Linux信号机制。<p>设备驱动中使用异步通知，主要用到一个数据结构和两个函数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 异步通知数据结构</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>fasync_struct</span>;</span></span><br><span class=line><span class=comment>// 处理标志变更</span></span><br><span class=line><span class=type>int</span> <span class="title function_">fasync_helper</span><span class=params>(<span class=type>int</span> fd, <span class=keyword>struct</span> file *filp, <span class=type>int</span> mode, <span class=keyword>struct</span> fasync_struct **fa)</span>;</span><br><span class=line><span class=comment>// 释放信号函数</span></span><br><span class=line><span class=type>void</span> <span class="title function_">kill_fasync</span><span class=params>(<span class=keyword>struct</span> fasync_struct **fa, <span class=type>int</span> sig, <span class=type>int</span> band)</span>;</span><br><span class=line></span><br></pre></table></figure><h2 id=异步io>异步I/O</h2><p>Linux内核AIO。<p>AIO无法解决系统调用问题，已经被摒弃，使用<code>io_uring</code>替代AIO机制。<a href=https://zhuanlan.zhihu.com/p/583298936 rel=noopener target=_blank>一文图解原理｜Linux I/O 神器之 io_uring</a><h1 id=中断与时钟>中断与时钟</h1><p>Linux将中断处理程序分解为两个半部：顶半部（Top Half）和底半部（Bottom Half）。<p>ARM Linux默认情况下，中断都是在CPU0上产生的，需要通过接口<code>irq_set_affinity</code>把中断irq设定到CPU i上去。<p>顶半部用于完成尽量少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态，并在清除中断标志后就进行“登记中断”的工作。<p>中断处理工作的重心就落在了底半部的头上，需用它来完成中断事件的绝大多数任务。<h2 id=关键函数-1>关键函数</h2><h3 id=顶半部>顶半部</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class="title function_">irqreturn_t</span> <span class=params>(*<span class=type>irq_handler_t</span>)</span><span class=params>(<span class=type>int</span>, <span class=type>void</span> *)</span>;</span><br><span class=line><span class=keyword>typedef</span> <span class=type>int</span> <span class=type>irqreturn_t</span>;</span><br><span class=line><span class=comment>// 申请irq</span></span><br><span class=line><span class=type>int</span> <span class="title function_">request_irq</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> irq, <span class=type>irq_handler_t</span> handler, <span class=type>unsigned</span> <span class=type>long</span> flags, <span class=type>const</span> <span class=type>char</span> *name, <span class=type>void</span> *dev)</span>;</span><br><span class=line><span class=comment>// 申请irq。区别是devm_开头的API申请的是内核“managed”的资源，一般不需要在出错处理和remove（）接口里再显式的释放。</span></span><br><span class=line><span class=type>int</span> <span class="title function_">devm_request_irq</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>unsigned</span> <span class=type>int</span> irq, <span class=type>irq_handler_t</span> handler, <span class=type>unsigned</span> <span class=type>long</span> irqflags, <span class=type>const</span> <span class=type>char</span> *devname, <span class=type>void</span> *dev_id)</span>;</span><br><span class=line><span class=comment>// 释放irq</span></span><br><span class=line><span class=type>void</span> <span class="title function_">free_irq</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> irq,<span class=type>void</span> *dev_id)</span>;</span><br><span class=line><span class=comment>// 屏蔽使能中断源</span></span><br><span class=line><span class=type>void</span> <span class="title function_">disable_irq</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">disable_irq_nosync</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">enable_irq</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br></pre></table></figure><p>中断共享需要在申请时，增加IRQF_SHARED标志。<h3 id=底半部>底半部</h3><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断和线程化irq。<h2 id=内核定时器>内核定时器</h2><h3 id=定时器>定时器</h3><p>timer_list<h3 id=工作队列>工作队列</h3><h2 id=内核延时>内核延时</h2><h3 id=短延时>短延时</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// 忙等待</span></span><br><span class=line><span class=type>void</span> <span class="title function_">ndelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> nsecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">udelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> usecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">mdelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> msecs)</span>;</span><br><span class=line><span class=comment>// 睡眠</span></span><br><span class=line><span class=type>void</span> <span class="title function_">msleep</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> millisecs)</span>;</span><br><span class=line><span class=type>unsigned</span> <span class=type>long</span> <span class="title function_">msleep_interruptible</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> millisecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">ssleep</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> seconds)</span>;</span><br><span class=line><span class=comment>// 睡着延时</span></span><br><span class=line>schedule_timeout</span><br></pre></table></figure><h1 id=内存与io访问>内存与I/O访问</h1><p>x86处理器中存在I/O空间的概念，而大多数嵌入式微处理器中并不提供I/O空间。<h2 id=linux内存管理>Linux内存管理</h2><p>在Linux系统中，进程的4GB内存空间被分为两个部分——用户空间与内核空间。用户空间的地址一般分布为0<sub>3GB（即PAGE_OFFSET，在0x86中它等于0xC0000000），而3</sub>4GB为内核空间。用户进程通常只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。用户进程只能通过系统调用等方式才可以访问到内核空间。<p>内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。<p>对于x86系统而言，一般情况下，物理内存映射区最大长度为896MB。当系统物理内存大于896MB时，超过物理内存映射区的那部分内存称为高端内存。<p>内核空间最顶部FIXADDR_TOP~4GB的区域作为保留区。<p>紧接着最顶端的保留区以下的一段区域为专用页面映射区（FIXADDR_START~FIXADDR_TOP）。<p>virt_to_phys（）和phys_to_virt（）方法仅适用于DMA和常规区域，高端内存的虚拟地址与物理地址之间不存在如此简单的换算关系。<h2 id=内存存取>内存存取</h2><h3 id=用户空间动态申请>用户空间动态申请</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>malloc</span></span><br><span class=line><span class=built_in>free</span></span><br></pre></table></figure><h3 id=内核空间动态申请>内核空间动态申请</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 依赖底层__get_free_pages（）来实现，分配标志的前缀GFP正好是这个底层函数的缩写。</span></span><br><span class=line><span class=comment>// 最常用的分配标志是GFP_KERNEL，其含义是在内核空间的进程中申请内存。</span></span><br><span class=line><span class=comment>// 使用GFP_KERNEL标志申请内存时，若暂时不能满足，则进程会睡眠等待页，即会引起阻塞，因此不能在中断上下文或持有自旋锁的时候使用GFP_KERNE申请内存。</span></span><br><span class=line><span class=comment>// 使用GFP_ATOMIC标志申请内存时，若不存在空闲页，则不等待，直接返回。</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kmalloc</span><span class=params>(<span class=type>size_t</span> size, <span class=type>int</span> flags)</span>;</span><br><span class=line>kfree</span><br><span class=line><span class=comment>// 一般只为存在于软件中（没有对应的硬件意义）的较大的顺序缓冲区分配内存</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">vmalloc</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">vfree</span><span class=params>(<span class=type>void</span> * addr)</span>;</span><br></pre></table></figure><p>slab缓存<p>完全使用页为单元申请和释放内存容易导致浪费（如果要申请少量字节，也需要用1页）；另一方面，在操作系统的运作过程中，经常会涉及大量对象的重复生成、使用和释放内存问题。如果我们能够用合适的方法使得对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，就可以大大提高效率。slab算法就是针对上述特点设计的。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建slab缓存</span></span><br><span class=line><span class=keyword>struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class=params>(<span class=type>const</span> <span class=type>char</span> *name, <span class=type>size_t</span> size,<span class=type>size_t</span> align, <span class=type>unsigned</span> <span class=type>long</span> flags,<span class=type>void</span> (*ctor)(<span class=type>void</span>*, <span class=keyword>struct</span> kmem_cache *, <span class=type>unsigned</span> <span class=type>long</span>),<span class=type>void</span> (*dtor)(<span class=type>void</span>*, <span class=keyword>struct</span> kmem_cache *, <span class=type>unsigned</span> <span class=type>long</span>))</span>;</span><br><span class=line><span class=comment>// 分配和释放slab缓存</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kmem_cache_alloc</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep, <span class=type>gfp_t</span> flags)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">kmem_cache_free</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep, <span class=type>void</span> *objp)</span>;</span><br><span class=line><span class=comment>// 回收slab缓存</span></span><br><span class=line><span class=type>int</span> <span class="title function_">kmem_cache_destroy</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep)</span>;</span><br></pre></table></figure><p>内存池<p>内存池技术也是一种非常经典的用于分配大量小对象的后备缓存技术。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建内存池</span></span><br><span class=line><span class=type>mempool_t</span> *<span class="title function_">mempool_create</span><span class=params>(<span class=type>int</span> min_nr, <span class=type>mempool_alloc_t</span> *alloc_fn,<span class=type>mempool_free_t</span> *free_fn, <span class=type>void</span> *pool_data)</span>;</span><br><span class=line><span class=keyword>typedef</span> <span class=type>void</span> *(<span class=type>mempool_alloc_t</span>)(<span class=type>int</span> gfp_mask, <span class=type>void</span> *pool_data); <span class=comment>// 标准对象分配的函数指针</span></span><br><span class=line><span class=keyword>typedef</span> <span class="title function_">void</span> <span class=params>(<span class=type>mempool_free_t</span>)</span><span class=params>(<span class=type>void</span> *element, <span class=type>void</span> *pool_data)</span>; <span class=comment>// 标准对象回收的函数指针</span></span><br><span class=line><span class=comment>// 内存池中分配和回收对象</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">mempool_alloc</span><span class=params>(<span class=type>mempool_t</span> *pool, <span class=type>int</span> gfp_mask)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">mempool_free</span><span class=params>(<span class=type>void</span> *element, <span class=type>mempool_t</span> *pool)</span>;</span><br><span class=line><span class=comment>// 回收内存池</span></span><br><span class=line><span class=type>void</span> <span class="title function_">mempool_destroy</span><span class=params>(<span class=type>mempool_t</span> *pool)</span>;</span><br></pre></table></figure><h2 id=io端口和io内存>I/O端口和I/O内存</h2><p>当位于I/O空间时，通常被称为I/O端口；当位于内存空间时，对应的内存空间被称为I/O内存。<h3 id=io端口访问>I/O端口访问</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// 读写字节端口（8位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inb</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outb</span><span class=params>(<span class=type>unsigned</span> <span class=type>char</span> byte, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写字端口（16位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inw</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outw</span><span class=params>(<span class=type>unsigned</span> <span class=type>short</span> word, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写长字端口（32位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inl</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outl</span><span class=params>(<span class=type>unsigned</span> longword, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写一串字节</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insb</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsb</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=comment>// 读写一串字</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insw</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsw</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=comment>// 读写一串长字</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insl</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsl</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br></pre></table></figure><h3 id=io内存访问>I/O内存访问</h3><p>在内核中访问I/O内存（通常是芯片内部的各个I2C、SPI、USB等控制器的寄存器或者外部内存总线上的设备）之前，需首先使用ioremap（）函数将设备所处的物理地址映射到虚拟地址上。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 返回一个特殊的虚拟地址，该地址可用来存取特定的物理地址范围，这个虚拟地址位于vmalloc映射区域。</span></span><br><span class=line><span class=comment>// 通过devm_ioremap进行的映射通常不需要在驱动退出和出错处理的时候进行iounmap</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">ioremap</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> offset, <span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=type>void</span> __iomem *<span class="title function_">devm_ioremap</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>resource_size_t</span> offset,<span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=comment>// 释放ioremap映射的地址</span></span><br><span class=line><span class=type>void</span> <span class="title function_">iounmap</span><span class=params>(<span class=type>void</span> * addr)</span>;</span><br></pre></table></figure><p>是Linux内核推荐用一组标准的API来完成设备内存映射的虚拟地址的读写。<p>没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是前者包含一个内存屏障。<p>以下分别是读写8bit、16bit、32bit的寄存器的版本。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 读寄存器</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readb(c) ({ u8 __v = readb_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readw(c) ({ u16__v = readw_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readl(c) ({ u32 __v = readl_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=comment>// 写寄存器</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writeb(v,c) ({ __iowmb(); writeb_relaxed(v,c); })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writew(v,c) ({ __iowmb(); writew_relaxed(v,c); })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writel(v,c) ({ __iowmb(); writel_relaxed(v,c); })</span></span><br></pre></table></figure><h3 id=申请释放io端口和io内存>申请释放I/O端口和I/O内存</h3><p>Linux内核提供了一组函数以申请和释放I/O端口，表明该驱动要访问这片区域。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请I/O端口</span></span><br><span class=line><span class=comment>// 变体devm_request_region</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">request_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> first, <span class=type>unsigned</span> <span class=type>long</span> n, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 归还I/O端口</span></span><br><span class=line><span class=type>void</span> <span class="title function_">release_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> n)</span>;</span><br></pre></table></figure><p>Linux内核也提供了一组函数以申请和释放I/O内存的范围。此处的“申请”表明该驱动要访问这片区域，它不会做任何内存映射的动作，更多的是类似于“reservation”的概念。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请I/O内存</span></span><br><span class=line><span class=comment>// 变体devm_request_mem_region</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">request_mem_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> len, <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 归还I/O内存</span></span><br><span class=line><span class=type>void</span> <span class="title function_">release_mem_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> len)</span>;</span><br></pre></table></figure><h3 id=io端口和io内存访问流程>I/O端口和I/O内存访问流程</h3><p>I/O端口访问的一种途径是直接使用I/O端口操作函数：在设备打开或驱动模块被加载时申请I/O端口区域，之后使用inb（）、outb（）等进行端口访问，最后，在设备关闭或驱动被卸载时释放I/O端口范围。<p>I/O内存的访问步骤，首先是调用request_mem_region（）申请资源，接着将寄存器地址通过ioremap（）映射到内核空间虚拟地址，之后就可以通过Linux设备访问编程接口访问这些设备的寄存器了。访问完成后，应对ioremap（）申请的虚拟地址进行释放，并释放release_mem_region（）申请的I/O内存资源。<h3 id=设备地址映射到用户空间>设备地址映射到用户空间</h3><p>一般情况下，用户空间是不可能也不应该直接访问设备的，但是，设备驱动程序中可实现mmap（）函数，这个函数可使得用户空间能直接访问设备的物理地址。<p>mmap（）必须以PAGE_SIZE为单位进行映射。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 驱动中mmap原型</span></span><br><span class=line><span class=type>int</span>(*mmap)(<span class=keyword>struct</span> file *, <span class=keyword>struct</span> vm_area_struct*);</span><br></pre></table></figure><p><code>vm_operations_struct</code>结构体的实体会在<code>file_operations</code>的mmap（）成员函数里被赋值给相应的<code>vma->vm_ops</code>。一般open（）函数也通常在mmap（）里调用，close（）函数会在用户调用munmap（）的时候被调用到。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建页表项</span></span><br><span class=line><span class=type>int</span> <span class="title function_">remap_pfn_range</span><span class=params>(<span class=keyword>struct</span> vm_area_struct *vma, <span class=type>unsigned</span> <span class=type>long</span> addr,<span class=type>unsigned</span> <span class=type>long</span> pfn, <span class=type>unsigned</span> <span class=type>long</span> size, <span class=type>pgprot_t</span> prot)</span>;</span><br></pre></table></figure><p>I/O内存被映射时需要是nocache的，这时候，我们应该对vma->vm_page_prot设置nocache标志之后再映射。<p>当访问的页不在内存里，即发生缺页异常时，fault（）会被内核自动调用，而fault（）的具体行为可以自定义。<h2 id=io内存静态映射>I/O内存静态映射</h2><p>在将Linux移植到目标电路板的过程中，有得会建立外设I/O内存物理地址到虚拟地址的静态映射，这个映射通过在与电路板对应的map_desc结构体数组中添加新的成员来完成。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>map_desc</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> virtual; <span class=comment>/* 虚拟地址 */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> pfn;     <span class=comment>/* __phys_to_pfn(phy_addr) */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> length;  <span class=comment>/* 大小 */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> type;     <span class=comment>/* 类型 */</span></span><br><span class=line>};</span><br><span class=line><span class=comment>// 然后通过函数iotable_init(struct map_desc&, size_t)建立映射。</span></span><br></pre></table></figure><p>驱动工程师可以对非常规内存区域的I/O内存（外设控制器寄存器、MCU内部集成的外设控制器寄存器等）依照电路板的资源使用情况添加到map_desc数组中，但是目前该方法已经不值得推荐。<h2 id=dma>DMA</h2><p>DMA是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。<p>DMA方式的数据传输由DMA控制器（DMAC）控制，在传输期间，CPU可以并发地执行其他任务。当DMA结束后，DMAC通过中断通知CPU数据传输已经结束，然后由CPU执行相应的中断服务程序进行后处理。<h3 id=dma与cache一致性>DMA与Cache一致性</h3><p>如果DMA的目的地址与Cache所缓存的内存地址访问有重叠，经过DMA操作，与Cache缓存对应的内存中的数据已经被修改，而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据。这样就会发生Cache与内存之间数据“不一致性”的错误。<p>Cache的不一致性问题并不是只发生在DMA的情况下，实际上，它还存在于Cache使能和关闭的时刻。<h3 id=linux下的dma编程>Linux下的DMA编程</h3><p>申请DMA缓冲区时应使用GFP_DMA标志，这样能保证获得的内存位于DMA区域中，并具备DMA能力。<p>在内核中定义了__get_free_pages（）针对DMA的“快捷方式”__get_dma_pages（），它在申请标志中添加了GFP_DMA。<p>如果不想使用log2size（即order）为参数申请DMA内存，则可以使用另一个函数dma_mem_alloc（）。<p>内核提供了如下函数以进行简单的虚拟地址/总线地址转换<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>unsigned</span> <span class=type>long</span> <span class="title function_">virt_to_bus</span><span class=params>(<span class=keyword>volatile</span> <span class=type>void</span> *address)</span>;</span><br><span class=line><span class=type>void</span> *<span class="title function_">bus_to_virt</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> address)</span>;</span><br></pre></table></figure><p>在使用IOMMU或反弹缓冲区的情况下，上述函数一般不会正常工作。而且，这两个函数并不建议使用。<p>设备并不一定能在所有的内存地址上执行DMA操作，在这种情况下应该通过下列函数执行DMA地址掩码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">dma_set_mask</span><span class=params>(<span class=keyword>struct</span> device *dev, u64 mask)</span>;</span><br></pre></table></figure><p>内核中提供了如下函数以分配一个DMA一致性的内存区域<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请Cache一致的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">dma_alloc_coherent</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span> *handle,<span class=type>gfp_t</span> gfp)</span>;</span><br><span class=line><span class=comment>// 释放Cache一致的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_free_coherent</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>void</span> *cpu_addr,<span class=type>dma_addr_t</span> handle)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 申请写合并的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">dma_alloc_writecombine</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span>*handle, <span class=type>gfp_t</span> gfp)</span>;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> dma_free_writecombine(dev,size,cpu_addr,handle) \</span></span><br><span class=line><span class=meta>    dma_free_coherent(dev,size,cpu_addr,handle)</span></span><br><span class=line></span><br><span class=line><span class=comment>// PCI设备申请DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">pci_alloc_consistent</span><span class=params>(<span class=keyword>struct</span> pci_dev *pdev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span> *dma_addrp)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">pci_free_consistent</span><span class=params>(<span class=keyword>struct</span> pci_dev *pdev, <span class=type>size_t</span> size, <span class=type>void</span> *cpu_addr,<span class=type>dma_addr_t</span> dma_addr)</span>;</span><br></pre></table></figure><p>缓冲区来自内核的较上层（如网卡驱动中的网络报文、块设备驱动中要写入设备的数据等），上层很可能用普通的kmalloc（）、__get_free_pages（）等方法申请，这时候就要使用流式DMA映射。<p>对于单个已经分配的缓冲区而言，使用dma_map_single（）可实现流式DMA映射<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>// DMA映射。第4个参数为DMA的方向，可能的值包括DMA_TO_DEVICE、DMA_FROM_DEVICE、DMA_BIDIRECTIONAL和DMA_NONE</span></span><br><span class=line><span class=type>dma_addr_t</span> <span class="title function_">dma_map_single</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>void</span> *buffer, <span class=type>size_t</span> size,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// DMA反映射</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_unmap_single</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_addr_t</span> dma_addr, <span class=type>size_t</span> size,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 获得DMA缓冲区的拥有权</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_single_for_cpu</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_handle_t</span> bus_addr,<span class=type>size_t</span> size, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 将其所有权返还给设备</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_single_for_device</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_handle_t</span> bus_addr,<span class=type>size_t</span> size, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 映射SG</span></span><br><span class=line><span class=type>int</span> <span class="title function_">dma_map_sg</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg, <span class=type>int</span> nents,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 去除映射SG</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_unmap_sg</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *<span class=built_in>list</span>,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 返回scatterlist对应的缓冲区的总线地址和缓冲区的长度</span></span><br><span class=line><span class=type>dma_addr_t</span> <span class="title function_">sg_dma_address</span><span class=params>(<span class=keyword>struct</span> scatterlist *sg)</span>;</span><br><span class=line><span class=type>unsigned</span> <span class=type>int</span> <span class="title function_">sg_dma_len</span><span class=params>(<span class=keyword>struct</span> scatterlist *sg)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 获得DMA缓冲区的拥有权</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_sg_for_cpu</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 将其所有权返还给设备</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_sg_for_device</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br></pre></table></figure><p>Linux内核目前推荐使用dmaengine的驱动架构来编写DMA控制器的驱动，同时外设的驱动使用标准的dmaengine API进行DMA的准备、发起和完成时的回调工作。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请DMA通道</span></span><br><span class=line><span class=keyword>struct</span> dma_chan *<span class="title function_">dma_request_slave_channel</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>dma_chan</span> *__<span class=title>dma_request_channel</span>(<span class=title>const</span> <span class=title>dma_cap_mask_t</span> *<span class=title>mask</span>,<span class=title>dma_filter_fn</span> <span class=title>fn</span>, <span class=title>void</span> *<span class=title>fn_param</span>);</span></span><br><span class=line><span class=comment>// 释放DMA通道</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_release_channel</span><span class=params>(<span class=keyword>struct</span> dma_chan *chan)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// DMA完成回调函数原型：void (dma_fini_callback)(void*)</span></span><br><span class=line></span><br><span class=line><span class=comment>// 申请DMA描述符，然后填充callback和callback_param参数</span></span><br><span class=line>dmaengine_prep_slave_single</span><br><span class=line><span class=comment>// 把描述符插入队列</span></span><br><span class=line>dmaengine_submit</span><br><span class=line><span class=comment>// 发起DMA动作</span></span><br><span class=line>dma_async_issue_pending</span><br></pre></table></figure><h1 id=linux设备驱动的软件架构思想>Linux设备驱动的软件架构思想</h1><p>让驱动以某种标准方法拿到这些平台信息呢Linux总线、设备和驱动模型实际上可以做到这一点，驱动只管驱动，设备只管设备，总线则负责匹配设备和驱动，而驱动则以标准途径拿到板级信息。<p>一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附于PCI、USB、I2C、SPI等的设备而言，这自然不是问题。在SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设等却不依附于此类总线。Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform_device，而驱动成为platform_driver。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>platform_device</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=type>int</span> id;</span><br><span class=line>    <span class=type>bool</span> id_auto;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>devicedev</span>;</span></span><br><span class=line>    u32 num_resources;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>resource</span> *<span class=title>resource</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device_id</span> *<span class=title>id_entry</span>;</span></span><br><span class=line>    <span class=type>char</span> *driver_override; <span class=comment>/* Driver name to force a match */</span></span><br><span class=line></span><br><span class=line>    <span class=comment>/* MFD cell pointer */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>mfd_cell</span> *<span class=title>mfd_cell</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>/* arch specific additions */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>pdev_archdata</span> <span class=title>archdata</span>;</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>platform_driver</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>int</span> (*probe)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>int</span> (*remove)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>void</span> (*shutdown)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>int</span> (*suspend)(<span class=keyword>struct</span> platform_device * <span class=type>pm_message_t</span> state);</span><br><span class=line>    <span class=type>int</span> (*resume)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>device_driver</span> <span class=title>driver</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device_id</span> *<span class=title>id_table</span>;</span></span><br><span class=line>    <span class=type>bool</span> prevent_deferred_probe;</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>device_driver</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bus_type</span> *<span class=title>bus</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>module</span> *<span class=title>owner</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *mod_name; <span class=comment>/* used for built-in modules */</span></span><br><span class=line></span><br><span class=line>    <span class=type>bool</span> suppress_bind_attrs; <span class=comment>/* disables bind/unbind via sysfs */</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>of_device_id</span> *<span class=title>of_match_table</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>acpi_device_id</span> *<span class=title>acpi_match_table</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>int</span> (*probe)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>int</span> (*remove)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>void</span> (*shutdown)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>int</span> (*suspend)(<span class=keyword>struct</span> device *dev, <span class=type>pm_message_t</span> state);</span><br><span class=line>    <span class=type>int</span> (*resume)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>attribute_group</span> **<span class=title>groups</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>dev_pm_ops</span> *<span class=title>pm</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>driver_private</span> *<span class=title>p</span>;</span></span><br><span class=line>};</span><br></pre></table></figure><p>与platform_driver地位对等的i2c_driver、spi_driver、usb_driver、pci_driver中都包含了device_driver结构体实例成员。它其实描述了各种xxx_driver（xxx是总线名）在驱动意义上的一些共性。<p>资源本身由resource结构体描述<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>resource</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>resource__size_t</span> start;</span><br><span class=line>    <span class=type>resource_size_t</span> end;</span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> flags; <span class=comment>// 值可以为IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORE-SOURCE_DMA等</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>resource</span> *<span class=title>parent</span>, *<span class=title>sibling</span>, *<span class=title>child</span>;</span></span><br><span class=line>};</span><br></pre></table></figure><p>对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中通过platform_get_resource（）这样的API来获取<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 获取资源通用接口</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">platform_get_resource</span><span class=params>(<span class=keyword>struct</span> platform_device *, <span class=type>unsigned</span> <span class=type>int</span>,<span class=type>unsigned</span> <span class=type>int</span>)</span>;</span><br><span class=line><span class=comment>// 获取IRQ资源封装接口，相当于platform_get_resource(dev, IORESOURCE_IRQ, num);</span></span><br><span class=line><span class=type>int</span> <span class="title function_">platform_get_irq</span><span class=params>(<span class=keyword>struct</span> platform_device *dev, <span class=type>unsigned</span> <span class=type>int</span> num)</span>;</span><br></pre></table></figure><p>platform也提供了platform_data的支持，platform_data的形式是由每个驱动自定义的<h3 id=将globalfifo作为platform设备>将globalfifo作为platform设备</h3><p>globalfifo驱动挂接到platform总线上，这要完成两个工作：<ul><li>将globalfifo移植为platform驱动<li>在板文件中添加globalfifo这个platform设备</ul><p>移植时需要屏蔽module_init和module_exit宏定义的入口。<p>为了完成在板文件中添加globalfifo这个platform设备的工作，需要在板文件<code>arch/arm/mach-&lt;soc名>/mach-&lt;板名>.c</code>中添加相应的代码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>static</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device</span> <span class=title>globalfifo_device</span> =</span> {</span><br><span class=line>    .name = <span class=string>"globalfifo"</span>,</span><br><span class=line>    .id = <span class=number>-1</span>,</span><br><span class=line>};</span><br></pre></table></figure><h2 id=设备驱动分层思想>设备驱动分层思想</h2><p>非常推荐使用misc类型设备驱动框架，编写字符类设备。<p>可以额外编写驱动触发设备驱动<code>xxx_probe</code>函数<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> __init <span class="title function_">globalfifodev_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> ret;</span><br><span class=line></span><br><span class=line>    globalfifo_pdev = platform_device_alloc(<span class=string>"globalfifo"</span>, <span class=number>-1</span>);</span><br><span class=line>    <span class=keyword>if</span> (!globalfifo_pdev)</span><br><span class=line>        <span class=keyword>return</span> -ENOMEM;</span><br><span class=line></span><br><span class=line>    ret = platform_device_add(globalfifo_pdev);</span><br><span class=line>    <span class=keyword>if</span> (ret)</span><br><span class=line>    {</span><br><span class=line>        platform_device_put(globalfifo_pdev);</span><br><span class=line>        <span class=keyword>return</span> ret;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line>module_init(globalfifodev_init);</span><br></pre></table></figure><h1 id=linux块设备驱动>Linux块设备驱动</h1><p>块设备是与字符设备并列的概念，这两类设备在Linux中的驱动结构有较大差异，总体而言，块设备驱动比字符设备驱动要复杂得多。缓冲、I/O调度、请求队列等都是与块设备驱动相关的概念。<h2 id=linux块设备驱动结构>Linux块设备驱动结构</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=comment>// 块设备操作描述符</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>block_device_operations</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// 打开和释放</span></span><br><span class=line>    <span class=type>int</span> (*open)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>);</span><br><span class=line>    <span class=type>void</span> (*release)(<span class=keyword>struct</span> gendisk *, <span class=type>fmode_t</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// I/O控制</span></span><br><span class=line>    <span class=type>int</span> (*ioctl)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>, <span class=type>unsigned</span>, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line>    <span class=type>int</span> (*compat_ioctl)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>, <span class=type>unsigned</span>, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 介质改变，以后会被check_events取代</span></span><br><span class=line>    <span class=type>int</span> (*media_changed)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 使介质有效</span></span><br><span class=line>    <span class=type>int</span> (*revalidate_disk)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取驱动器信息</span></span><br><span class=line>    <span class=type>int</span> (*getgeo)(<span class=keyword>struct</span> block_device *, <span class=keyword>struct</span> hd_geometry *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 模块指针，通常指向THIS_MODULE</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>module</span> *<span class=title>owner</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 其他</span></span><br><span class=line>    <span class=type>int</span> (*rw_page)(<span class=keyword>struct</span> block_device *, <span class=type>sector_t</span>, <span class=keyword>struct</span> page *, <span class=type>int</span> rw);</span><br><span class=line>    <span class=type>int</span> (*direct_access)(<span class=keyword>struct</span> block_device *, <span class=type>sector_t</span>, <span class=type>void</span> **, <span class=type>unsigned</span> <span class=type>long</span> *);</span><br><span class=line>    <span class=type>unsigned</span> <span class="title function_">int</span> <span class=params>(*check_events)</span><span class=params>(<span class=keyword>struct</span> gendisk *disk, <span class=type>unsigned</span> <span class=type>int</span> clearing)</span>;</span><br><span class=line>    <span class=type>void</span> (*unlock_native_capacity)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line>    <span class=type>void</span> (*swap_slot_free_notify)(<span class=keyword>struct</span> block_device *, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line>};</span><br></pre></table></figure><h3 id=gendisk>gendisk</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>// 磁盘描述符</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>gendisk</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// major、first_minor和minors共同表征了磁盘的主、次设备号，同一个磁盘的各个分区共享一个主设备号，而次设备号则不同</span></span><br><span class=line>    <span class=type>int</span> major;</span><br><span class=line>    <span class=type>int</span> first_minor;</span><br><span class=line>    <span class=type>int</span> minors;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 描述的块设备操作集合</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>block_device_operations</span> *<span class=title>fops</span>;</span></span><br><span class=line>    <span class=comment>// 管理这个设备的I/O请求队列的指针</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>request_queue</span> *<span class=title>queue</span>;</span></span><br><span class=line>    <span class=comment>// 指向磁盘的任何私有数据，与字符设备驱动的private_data类似</span></span><br><span class=line>    <span class=type>void</span> *private_data;</span><br><span class=line>    <span class=comment>// 表示一个分区</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>hd_struct</span> <span class=title>part0</span>;</span></span><br><span class=line>    <span class=comment>// 容纳分区表。与part0的关系：disk->part_tbl->part[0] = &disk->part0;</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>disk_part_tbl</span> __<span class=title>rcu</span> *<span class=title>part_tbl</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>char</span> disk_name[DISK_NAME_LEN]; <span class=comment>/* name of major driver */</span></span><br><span class=line>    <span class=type>char</span> *(*devnode)(<span class=keyword>struct</span> gendisk *gd, <span class=type>umode_t</span> *mode);</span><br><span class=line></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> events;       <span class=comment>/* supported events */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> async_events; <span class=comment>/* async events, subset of all */</span></span><br><span class=line></span><br><span class=line>    <span class=type>int</span> flags;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>device</span> *<span class=title>driverfs_dev</span>;</span> <span class=comment>// <span class=doctag>FIXME:</span> remove</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>kobject</span> *<span class=title>slave_dir</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>timer_rand_state</span> *<span class=title>random</span>;</span></span><br><span class=line>    <span class=type>atomic_t</span> sync_io; <span class=comment>/* RAID */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>disk_events</span> *<span class=title>ev</span>;</span></span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>blk_integrity</span> *<span class=title>integrity</span>;</span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>    <span class=type>int</span> node_id;</span><br><span class=line>};</span><br></pre></table></figure><p>操作函数<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 分配gendisk</span></span><br><span class=line><span class=keyword>struct</span> gendisk *<span class="title function_">alloc_disk</span><span class=params>(<span class=type>int</span> minors)</span>;</span><br><span class=line><span class=comment>// 增加gendisk</span></span><br><span class=line><span class=type>void</span> <span class="title function_">add_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br><span class=line><span class=comment>// 释放gendisk</span></span><br><span class=line><span class=type>void</span> <span class="title function_">del_gendisk</span><span class=params>(<span class=keyword>struct</span> gendisk *gp)</span>;</span><br><span class=line><span class=comment>// gendisk引用计数</span></span><br><span class=line><span class=keyword>struct</span> kobject *<span class="title function_">get_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">put_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br></pre></table></figure><h3 id=biorequest和request_queue>bio、request和request_queue</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bvec_iter</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>sector_t</span> bi_sector;   <span class=comment>/* device address in 512byte sectors */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_size; <span class=comment>/* residual I/O count */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_idx; <span class=comment>/* current index into bvl_vec */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_bvec_done; <span class=comment>/* number of bytes completed in current bvec */</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bio</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio</span> *<span class=title>bi_next</span>;</span> <span class=comment>/* request queue link */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>block_device</span> *<span class=title>bi_bdev</span>;</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> bi_flags; <span class=comment>/* status, command, etc */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> bi_rw;    <span class=comment>/* bottom bits READ/WRITE,</span></span><br><span class=line><span class=comment>                             * top bits priority</span></span><br><span class=line><span class=comment>                             */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bvec_iter</span> <span class=title>bi_iter</span>;</span></span><br><span class=line>    <span class=comment>/* Number of segments in this BIO after</span></span><br><span class=line><span class=comment>     * physical address coalescing is performed.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_phys_segments;</span><br><span class=line>    ...</span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span> *<span class=title>bi_io_vec</span>;</span> <span class=comment>/* the actual vec list */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_set</span> *<span class=title>bi_pool</span>;</span></span><br><span class=line>    <span class=comment>/*</span></span><br><span class=line><span class=comment>     * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class=line><span class=comment>     * double allocations for a small number of bio_vecs. This member</span></span><br><span class=line><span class=comment>     * MUST obviously be kept at the very end of the bio.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span> <span class=title>bi_inline_vecs</span>[0];</span></span><br><span class=line>};</span><br></pre></table></figure><p>与bio对应的数据每次存放的内存不一定是连续的，因此需要一个向量。向量中的每个元素实际是一个[page，offset，len]，我们一般也称它为一个片段。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>page</span> *<span class=title>bv_page</span>;</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bv_len;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bv_offset;</span><br><span class=line>};</span><br></pre></table></figure><p>I/O调度算法可将连续的bio合并成一个请求。请求是bio经由I/O调度进行调整后的结果，这是请求和bio的区别。<p>每个块设备或者块设备的分区都对应有自身的request_queue，从I/O调度器合并和排序出来的请求会被分发（Dispatch）到设备级的request_queue。<p>主要API<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>// 初始化请求队列</span></span><br><span class=line><span class=type>request_queue_t</span> *<span class="title function_">blk_init_queue</span><span class=params>(request_fn_proc *rfn, <span class=type>spinlock_t</span> *lock)</span>;</span><br><span class=line><span class=comment>// 清除请求队列</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_cleanup_queue</span><span class=params>(<span class=type>request_queue_t</span> * q)</span>;</span><br><span class=line><span class=comment>// 分配请求队列</span></span><br><span class=line><span class=type>request_queue_t</span> *<span class="title function_">blk_alloc_queue</span><span class=params>(<span class=type>int</span> gfp_mask)</span>;</span><br><span class=line><span class=comment>// 对于RAMDISK这种完全随机访问的非机械设备，并不需要进行复杂的I/O调度。</span></span><br><span class=line><span class=comment>// 使用如下函数来绑定请求队列和“制造请求”函数</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_queue_make_request</span><span class=params>(<span class=type>request_queue_t</span> * q, make_request_fn * mfn)</span>;</span><br><span class=line><span class=comment>// 提取请求</span></span><br><span class=line><span class=keyword>struct</span> request * <span class="title function_">blk_peek_request</span><span class=params>(<span class=keyword>struct</span> request_queue *q)</span>;</span><br><span class=line><span class=comment>// 启动请求</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_start_request</span><span class=params>(<span class=keyword>struct</span> request *req)</span>;</span><br><span class=line><span class=comment>// 报告完成</span></span><br><span class=line><span class=type>void</span> __blk_end_request_all(<span class=keyword>struct</span> request *rq, <span class=type>int</span> error);</span><br><span class=line><span class=type>void</span> <span class="title function_">blk_end_request_all</span><span class=params>(<span class=keyword>struct</span> request *rq, <span class=type>int</span> error)</span>;</span><br><span class=line><span class=comment>// 用blk_queue_make_request（）绕开I/O调度，但是在bio处理完成后应该使用bio_endio</span></span><br><span class=line><span class=type>void</span> <span class="title function_">bio_endio</span><span class=params>(<span class=keyword>struct</span> bio *bio, <span class=type>int</span> error)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 如果是I/O操作故障，可以调用快捷函数bio_io_error（）</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> bio_io_error(bio) bio_endio((bio), -EIO)</span></span><br><span class=line><span class=comment>// 遍历一个请求的所有bio</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> __rq_for_each_bio(_bio, rq) \</span></span><br><span class=line><span class=meta>    <span class=keyword>if</span> ((rq->bio))                  \</span></span><br><span class=line><span class=meta>        for (_bio = (rq)->bio; _bio; _bio = _bio->bi_next)</span></span><br><span class=line><span class=comment>// 遍历一个bio的所有bio_vec</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> __bio_for_each_segment(bvl, bio, iter, start) \</span></span><br><span class=line><span class=meta>    for (iter = (start);                              \</span></span><br><span class=line><span class=meta>         (iter).bi_size &&                            \</span></span><br><span class=line><span class=meta>         ((bvl = bio_iter_iovec((bio), (iter))), 1);  \</span></span><br><span class=line><span class=meta>         bio_advance_iter((bio), &(iter), (bvl).bv_len))</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> bio_for_each_segment(bvl, bio, iter) \</span></span><br><span class=line><span class=meta>    __bio_for_each_segment(bvl, bio, iter, (bio)->bi_iter)</span></span><br><span class=line><span class=comment>// 迭代遍历一个请求所有bio中的所有segment</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> rq_for_each_segment(bvl, _rq, _iter) \</span></span><br><span class=line><span class=meta>    __rq_for_each_bio(_iter.bio, _rq)        \</span></span><br><span class=line><span class=meta>        bio_for_each_segment(bvl, _iter.bio, _iter.iter)</span></span><br></pre></table></figure><h3 id=io调度器>I/O调度器</h3><p>Linux 2.6以后的内核包含4个I/O调度器，它们分别是Noop I/O调度器（适合Flash）、Anticipatory I/O调度器、Deadline I/O调度器（适合读取多的场景，数据库）与CFQ I/O调度器（适合多媒体应用）。其中，Anticipatory I/O调度器算法已经在2010年从内核中去掉了。<p>可以通过给内核添加启动参数，选择所使用的I/O调度算法<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>kernel elevator=deadline</span><br></pre></table></figure><p>通过类似如下的命令，改变一个设备的调度器<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>echo</span> SCHEDULER > /sys/block/DEVICE/queue/scheduler</span><br></pre></table></figure><h2 id=linux块设备驱动初始化>Linux块设备驱动初始化</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 注册设备</span></span><br><span class=line><span class=comment>// major参数是块设备要使用的主设备号，name为设备名，它会显示在/proc/devices中。</span></span><br><span class=line><span class=comment>// 如果major为0，内核会自动分配一个新的主设备号，register_blkdev（）函数的返回值就是这个主设备号。</span></span><br><span class=line><span class=type>int</span> <span class="title function_">register_blkdev</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> major, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 注销设备</span></span><br><span class=line><span class=type>int</span> <span class="title function_">unregister_blkdev</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> major, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br></pre></table></figure><h2 id=块设备的打开释放>块设备的打开释放</h2><p>块设备驱动的open（）函数和其字符设备驱动的对等体不太相似，前者不以相关的inode和file结构体指针作为参数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> (*open)(<span class=keyword>struct</span> block_device *bdev, <span class=type>fmode_t</span> mode);</span><br><span class=line><span class=type>void</span> (*release)(<span class=keyword>struct</span> gendisk *disk, <span class=type>fmode_t</span> mode);</span><br></pre></table></figure><h2 id=块设备ioctl函数>块设备ioctl函数</h2><p>与字符设备驱动一样，块设备可以包含一个ioctl（）函数以提供对设备的I/O控制能力。高层的块设备层代码处理了绝大多数I/O控制。例如，<code>drivers/block/floppy.c</code>实现了与软驱相关的命令，<code>drivers/mmc/card/block.c</code>实现了MMC子系统的命令处理。<h2 id=块设备驱动的io请求处理>块设备驱动的I/O请求处理</h2><p>使用请求队列的源码见<code>drivers/memstick/core/ms_block.c</code>。<p>使用请求队列对于一个机械磁盘设备而言的确有助于提高系统的性能，但是对于RAMDISK、ZRAM（Compressed RAM Block Device）等完全可真正随机访问的设备而言，无法从高级的请求队列逻辑中获益。源码见<code>drivers/block/zram/zram_drv.c</code><h2 id=实例vmem_disk驱动>实例：vmem_disk驱动</h2><h3 id=vmem_disk硬件原理>vmem_disk硬件原理</h3><p>vmem_disk是一种模拟磁盘，其数据实际上存储在RAM中。它使用通过vmalloc（）分配出来的内存空间来模拟出一个磁盘，以块设备的方式来访问这片内存。该驱动是对字符设备驱动章节中globalmem驱动的块方式改造。<p>加载vmem_disk.ko后，在使用默认模块参数的情况下，系统会增加4个块设备节点。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>ls</span> -l /dev/vmem_disk*</span><br><span class=line>brw-rw---- 1 root disk 252, 0 2月 25 14:00 /dev/vmem_diska</span><br><span class=line>brw-rw---- 1 root disk 252, 16 2月 25 14:00 /dev/vmem_diskb</span><br><span class=line>brw-rw---- 1 root disk 252, 32 2月 25 14:00 /dev/vmem_diskc</span><br><span class=line>brw-rw---- 1 root disk 252, 48 2月 25 14:00 /dev/vmem_diskd</span><br><span class=line></span><br><span class=line>$ <span class=built_in>sudo</span> mkfs.ext2 /dev/vmem_diska</span><br><span class=line>mke2fs 1.42.9 (4-Feb-2014)</span><br><span class=line>Filesystem label=</span><br><span class=line>OS <span class=built_in>type</span>: Linux</span><br><span class=line>Block size=1024 (<span class=built_in>log</span>=0)</span><br><span class=line>Fragment size=1024 (<span class=built_in>log</span>=0)</span><br><span class=line>Stride=0 blocks, Stripe width=0blocks</span><br><span class=line>64 inodes, 512 blocks</span><br><span class=line>25 blocks (4.88%) reserved <span class=keyword>for</span> the super user</span><br><span class=line>First data block=1</span><br><span class=line>Maximum filesystem blocks=524288</span><br><span class=line>1 block group</span><br><span class=line>8192 blocks per group, 8192fragments per group</span><br><span class=line>64 inodes per group</span><br><span class=line>Allocating group tables: <span class=keyword>done</span></span><br><span class=line>Writing inode tables: <span class=keyword>done</span></span><br><span class=line>Writing superblocks and filesystem accounting information: <span class=keyword>done</span></span><br></pre></table></figure><h1 id=驱动开发常用项>驱动开发常用项</h1><h2 id=驱动属性项>驱动属性项</h2><p><code>linux/device.h</code><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line>// 设备属性处理函数</span><br><span class=line>static ssize_t xxx1_store(struct device *dev,</span><br><span class=line>			      struct device_attribute *attr,</span><br><span class=line>			      const char *buf, size_t n)</span><br><span class=line>{</span><br><span class=line>	int input;</span><br><span class=line>	if (kstrtoint(buf, 10, &input))</span><br><span class=line>		return -EINVAL;</span><br><span class=line>	...</span><br><span class=line>	schedule_work(&work);</span><br><span class=line>	return n;</span><br><span class=line>}</span><br><span class=line>// 声明设备属性结构体dev_attr_xxx1，并赋值xxx1_store为对应的处理函数</span><br><span class=line>static DEVICE_ATTR_WO(xxx1);</span><br><span class=line>static struct attribute *xxx_attrs[] = {</span><br><span class=line>	&dev_attr_xxx1.attr,</span><br><span class=line>	&dev_attr_xxx2.attr,</span><br><span class=line>	NULL,</span><br><span class=line>};</span><br><span class=line>static const struct attribute_group xxx_group = {</span><br><span class=line>	.attrs = xxx_attrs,</span><br><span class=line>};</span><br><span class=line></span><br><span class=line>// 在进行初始化时进行，例如probe中</span><br><span class=line>// 注册设备属性</span><br><span class=line>sysfs_create_group(&dev->kobj, &xxx_group);</span><br><span class=line>// 移除设备属性</span><br><span class=line>sysfs_remove_group(&dev->kobj, &xxx_group);</span><br></pre></table></figure><h2 id=工作队列-1>工作队列</h2><p>内核驱动处理时，遇到比较费时类型的任务时，可以将任务放到工作队列，稍后在合适的时候进行处理。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>// 工作队列结构体</span><br><span class=line>struct work_struct{}</span><br><span class=line>// 工作队列处理函数</span><br><span class=line>void xxx_handle(struct work_struct *work);</span><br><span class=line>// 初始化工作队列</span><br><span class=line>INIT_WORK(&xxx_work, xxx_handle);</span><br><span class=line>// 调度工作队列</span><br><span class=line>schedule_work(&work);</span><br></pre></table></figure><h1 id=附录>附录</h1><h2 id=常用命令>常用命令</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=comment># 加载驱动</span></span><br><span class=line>$ <span class=built_in>sudo</span> insmod globalmem.ko</span><br><span class=line><span class=comment># 卸载驱动</span></span><br><span class=line>$ <span class=built_in>sudo</span> rmmod globalmem</span><br><span class=line></span><br><span class=line><span class=comment># 只查看最新的内核打印消息</span></span><br><span class=line>$ dmesg -W</span><br><span class=line></span><br><span class=line><span class=comment># 查看驱动主设备号</span></span><br><span class=line>$ <span class=built_in>cat</span> /proc/devices | grep globalmem</span><br><span class=line>230 globalmem</span><br><span class=line><span class=comment># 查看驱动设备节点信息</span></span><br><span class=line>$ <span class=built_in>ls</span> -l /dev/globalmem</span><br><span class=line>crwxrwxrwx 1 root root 230, 0 Dec 27 17:40 /dev/globalmem</span><br><span class=line><span class=comment># 查看platform驱动</span></span><br><span class=line><span class=built_in>ls</span> /sys/devices/platform/globalfifo -l</span><br><span class=line>total 0</span><br><span class=line>lrwxrwxrwx 1 root root    0  1月  2 17:00 driver -> ../../../bus/platform/drivers/globalfifo</span><br><span class=line>-rw-r--r-- 1 root root 4096  1月  2 17:03 driver_override</span><br><span class=line>-r--r--r-- 1 root root 4096  1月  2 17:03 modalias</span><br><span class=line>drwxr-xr-x 2 root root    0  1月  2 17:03 power</span><br><span class=line>lrwxrwxrwx 1 root root    0  1月  2 17:03 subsystem -> ../../../bus/platform</span><br><span class=line>-rw-r--r-- 1 root root 4096  1月  2 17:00 uevent</span><br><span class=line></span><br><span class=line><span class=comment># 创建设备节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem c 230 0</span><br><span class=line><span class=comment># 删除设备节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>unlink</span> /dev/globalmem</span><br><span class=line><span class=comment># 创建支持多设备的节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem0 c 230 0</span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem1 c 230 1</span><br><span class=line></span><br><span class=line><span class=comment># 创建的设备普通用户没有写入权限，需要增加写入权限</span></span><br><span class=line><span class=comment># 或者给予全权限</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>chmod</span> 777 /dev/globalmem*</span><br><span class=line></span><br><span class=line><span class=comment># 向设备写入数据</span></span><br><span class=line>$ <span class=built_in>echo</span> <span class=string>"hello world 0"</span> >> /dev/globalmem0</span><br><span class=line><span class=comment># 读取设备中的数据</span></span><br><span class=line>$ <span class=built_in>cat</span> /dev/globalmem0</span><br><span class=line>hello world 0</span><br></pre></table></figure><h2 id=参考>参考</h2><p><a href=https://github.com/kevinwangkk/LDD4.0_note/blob/master/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%80%E6%96%B0%E7%9A%84Linux4.0%E5%86%85%E6%A0%B8.pdf rel=noopener target=_blank>Linux设备驱动开发详解：基于最新的Linux4.0内核.pdf</a><p><a href=https://blog.csdn.net/cotex_a9/category_12427627.html rel=noopener target=_blank>嵌入式王道长-Linux内核驱动开发</a></div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>本文作者： </strong>oz1010<li class=post-copyright-link><strong>本文链接：</strong> <a href=https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ title=Linux驱动开发笔记>https://oz1010.github.com/2024/04/24/Linux驱动开发笔记/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><div class=post-nav><div class=post-nav-item><a href=/2024/04/24/Xv6-RISC-V%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ rel=prev title=Xv6-RISC-V阅读笔记> <i class="fa fa-angle-left"></i> Xv6-RISC-V阅读笔记 </a></div><div class=post-nav-item><a href=/2024/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ rel=next title=嵌入式Linux驱动开发笔记> 嵌入式Linux驱动开发笔记 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>oz1010</span></div><div class=wordcount><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-chart-line"></i> </span> <span title=站点总字数>93k</span> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span> <span title=站点阅读时长>5:40</span> </span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"oz1010/oz1010.github.io-comments","issue_term":"pathname","theme":"github-light"}</script><script defer src=/js/third-party/comments/utterances.js></script>