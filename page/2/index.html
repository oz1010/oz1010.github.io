<!doctype html><html lang=zh-CN><meta charset=UTF-8><meta content="width=device-width" name=viewport><meta content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/icon-180.png rel=apple-touch-icon sizes=180x180><link href=/images/icon-32.png rel=icon sizes=32x32 type=image/png><link href=/images/icon-16.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/oz1010_logo.svg rel=mask-icon><style>:root{--body-bg-color:#f5f7f9;--content-bg-color:#fff;--card-bg-color:#f5f5f5;--text-color:#555;--selection-bg:#262a30;--selection-color:#eee;--blockquote-color:#666;--link-color:#555;--link-hover-color:#222;--brand-color:#fff;--brand-hover-color:#fff;--table-row-odd-bg-color:#f9f9f9;--table-row-hover-bg-color:#f5f5f5;--menu-item-bg-color:#f5f5f5;--theme-color:#222;--btn-default-bg:#fff;--btn-default-color:#555;--btn-default-border-color:#555;--btn-default-hover-bg:#222;--btn-default-hover-color:#fff;--btn-default-hover-border-color:#222;--highlight-background:#f6f6f6;--highlight-foreground:#2f3337;--highlight-gutter-background:#e2e2e2;--highlight-gutter-foreground:#42464a;color-scheme:light}html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{margin:.67em 0;font-size:2em}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace;font-size:1em}a{background:0 0}abbr[title]{border-bottom:none;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace;font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:100%;line-height:1.15}button,input{overflow:visible}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted buttontext}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;white-space:normal;max-width:100%;padding:0;display:table}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}details{display:block}summary{display:list-item}template,[hidden]{display:none}::selection{background:var(--selection-bg);color:var(--selection-color)}html,body{height:100%}body{background:var(--body-bg-color);box-sizing:border-box;color:var(--text-color);min-height:100%;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:1em;line-height:2;transition:padding .2s ease-in-out;position:relative}h1,h2,h3,h4,h5,h6{margin:30px 0 15px;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-weight:700;line-height:1.5}h1{font-size:1.5em}h2{font-size:1.375em}h3{font-size:1.25em}h4{font-size:1.125em}h5{font-size:1em}h6{font-size:.875em}a{color:var(--link-color);cursor:pointer;overflow-wrap:break-word;border-bottom:1px solid #999;outline:0;text-decoration:none}a:hover{border-bottom-color:var(--link-hover-color);color:var(--link-hover-color)}iframe,img,video,embed{max-width:100%;margin-left:auto;margin-right:auto;display:block}hr{background-image:repeating-linear-gradient(-45deg,#ddd,#ddd 4px,#0000 4px 8px);border:0;height:3px;margin:40px 0}blockquote{color:var(--blockquote-color);border-left:4px solid #ddd;margin:0;padding:0 15px}blockquote cite:before{content:"-";padding:0 5px}dt{font-weight:700}dd{margin:0;padding:0}.table-container{overflow:auto}table{border-collapse:collapse;border-spacing:0;width:100%;margin:0 0 20px;font-size:.875em}tbody tr:nth-of-type(odd){background:var(--table-row-odd-bg-color)}tbody tr:hover{background:var(--table-row-hover-bg-color)}caption,th,td{padding:8px}th,td{border:1px solid #ddd;border-bottom-width:3px}th{padding-bottom:10px;font-weight:700}td{border-bottom-width:1px}.btn{background:var(--btn-default-bg);border:2px solid var(--btn-default-border-color);color:var(--btn-default-color);border-radius:2px;padding:0 20px;font-size:.875em;line-height:2;transition:background-color .2s ease-in-out;display:inline-block}.btn:hover{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.btn+.btn{margin:0 0 8px 8px}.btn .fa-fw{text-align:left;width:1.28571em}.toggle{line-height:0}.toggle .toggle-line{background:#fff;width:100%;height:2px;transition:left .4s,opacity .4s,top .4s,transform .4s,width .4s;display:block;position:relative;top:0;left:0}.toggle .toggle-line:first-child{margin-top:1px}.toggle .toggle-line:not(:first-child){margin-top:4px}.toggle.toggle-arrow :first-child{width:50%;top:2px;left:50%;transform:rotate(45deg)}.toggle.toggle-arrow :last-child{width:50%;top:-2px;left:50%;transform:rotate(-45deg)}.toggle.toggle-close :nth-child(2){opacity:0}.toggle.toggle-close :first-child{top:6px;transform:rotate(45deg)}.toggle.toggle-close :last-child{top:-6px;transform:rotate(-45deg)}pre code.hljs{padding:1em;display:block;overflow-x:auto}code.hljs{padding:3px 5px}.hljs{color:#2f3337;background:#f6f6f6}.hljs-subst{color:#2f3337}.hljs-comment{color:#656e77}.hljs-keyword,.hljs-selector-tag,.hljs-meta .hljs-keyword,.hljs-doctag,.hljs-section,.hljs-attr{color:#015692}.hljs-attribute{color:#803378}.hljs-name,.hljs-type,.hljs-number,.hljs-selector-id,.hljs-quote,.hljs-template-tag{color:#b75501}.hljs-selector-class{color:#015692}.hljs-string,.hljs-regexp,.hljs-symbol,.hljs-variable,.hljs-template-variable,.hljs-link,.hljs-selector-attr{color:#54790d}.hljs-meta,.hljs-selector-pseudo{color:#015692}.hljs-built_in,.hljs-title,.hljs-literal{color:#b75501}.hljs-bullet,.hljs-code{color:#535a60}.hljs-meta .hljs-string{color:#54790d}.hljs-deletion{color:#c02d2e}.hljs-addition{color:#2f6f44}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.highlight:hover .copy-btn,.code-container:hover .copy-btn{opacity:1}.code-container{position:relative}.code-lang{opacity:.1;pointer-events:none;font-size:40px;line-height:1;position:absolute;right:5px}.copy-btn{color:#333;cursor:pointer;opacity:0;background:#fff;border:0;padding:2px 6px;font-size:.8125em;line-height:1.6;transition:opacity .2s ease-in-out;position:absolute;top:0;right:0}code,kbd,figure.highlight,pre{background:var(--highlight-background);color:var(--highlight-foreground)}figure.highlight,pre{margin:0 auto 20px;line-height:1.6}figure.highlight figcaption,pre .caption{background:var(--highlight-gutter-background);color:var(--highlight-foreground);padding:.5em;font-size:.875em;line-height:1.2;display:flow-root}figure.highlight figcaption a,pre .caption a{color:var(--highlight-foreground);float:right}figure.highlight figcaption a:hover,pre .caption a:hover{border-bottom-color:var(--highlight-foreground)}pre,code{font-family:consolas,Menlo,monospace,PingFang SC,Microsoft YaHei}code{overflow-wrap:break-word;border-radius:3px;padding:2px 4px;font-size:.875em}kbd{white-space:nowrap;border:2px solid #ccc;border-radius:.2em;padding:.1em .3em;font-family:inherit;box-shadow:.1em .1em .2em #0000001a}figure.highlight{position:relative;overflow:auto}figure.highlight pre{border:0;margin:0;padding:10px 0}figure.highlight table{border:0;width:auto;margin:0}figure.highlight td{border:0;padding:0}figure.highlight .gutter{-webkit-user-select:none;user-select:none}figure.highlight .gutter pre{background:var(--highlight-gutter-background);color:var(--highlight-gutter-foreground);text-align:right;padding-left:10px;padding-right:10px}figure.highlight .code pre{width:100%;padding-left:10px}figure.highlight .marked{background:#0000004d}pre .caption{margin-bottom:10px}.gist table{width:auto}.gist table td{border:0}pre{padding:10px;overflow:auto}pre code{text-shadow:none;background:0 0;padding:0}.blockquote-center{text-align:center;border-left:0;margin:40px 0;padding:0;position:relative}.blockquote-center:before,.blockquote-center:after{opacity:.6;width:100%;line-height:1;position:absolute;left:0}.blockquote-center:before{text-align:left;content:"";border-top:1px solid #ccc;font-family:"Font Awesome 6 Free";font-weight:900;top:-20px}.blockquote-center:after{text-align:right;content:"";border-bottom:1px solid #ccc;font-family:"Font Awesome 6 Free";font-weight:900;bottom:-20px}.blockquote-center p,.blockquote-center div{text-align:center}.group-picture{margin-bottom:20px}.group-picture .group-picture-row{gap:3px;margin-bottom:3px;display:flex}.group-picture .group-picture-column{flex:1}.group-picture .group-picture-column img{object-fit:cover;width:100%;height:100%;margin:0}.post-body .label{color:#555;padding:0 2px}.post-body .label.default{background:#f0f0f0}.post-body .label.primary{background:#efe6f7}.post-body .label.info{background:#e5f2f8}.post-body .label.success{background:#e7f4e9}.post-body .label.warning{background:#fcf6e1}.post-body .label.danger{background:#fae8eb}.post-body .link-grid{grid-gap:1.5rem;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:1.5rem;margin-bottom:20px;padding:1rem;display:grid}.post-body .link-grid .link-grid-container{border:solid #ddd;min-width:0;min-height:5rem;padding:.5rem;transition:background .3s;position:relative;box-shadow:1rem 1rem .5rem #00000080}.post-body .link-grid .link-grid-container:hover{background:var(--card-bg-color);animation:.5s next-shake}.post-body .link-grid .link-grid-container:active{transform:translate(.2rem,.2rem);box-shadow:.5rem .5rem .25rem #00000080}.post-body .link-grid .link-grid-container .link-grid-image{box-sizing:border-box;border:1px solid #ddd;border-radius:50%;width:5rem;height:5rem;padding:3px;position:absolute}.post-body .link-grid .link-grid-container p{margin:0 1rem 0 6rem}.post-body .link-grid .link-grid-container p:first-of-type{font-size:1.2em}.post-body .link-grid .link-grid-container p:last-of-type{opacity:.7;font-size:.8em;line-height:1.3rem}.post-body .link-grid .link-grid-container a{border:0;width:100%;height:100%;position:absolute;top:0;left:0}@keyframes next-shake{0%{transform:translate(1pt,1pt)rotate(0)}10%{transform:translate(-1pt,-2pt)rotate(-1deg)}20%{transform:translate(-3pt)rotate(1deg)}30%{transform:translate(3pt,2pt)rotate(0)}40%{transform:translate(1pt,-1pt)rotate(1deg)}50%{transform:translate(-1pt,2pt)rotate(-1deg)}60%{transform:translate(-3pt,1pt)rotate(0)}70%{transform:translate(3pt,1pt)rotate(-1deg)}80%{transform:translate(-1pt,-1pt)rotate(1deg)}90%{transform:translate(1pt,2pt)rotate(0)}to{transform:translate(1pt,-2pt)rotate(-1deg)}}.post-body .note{border:1px solid #eee;border-left-width:5px;border-radius:3px;margin-bottom:20px;padding:1em;position:relative}.post-body .note summary{cursor:pointer;outline:0}.post-body .note summary p{display:inline}.post-body .note h2,.post-body .note h3,.post-body .note h4,.post-body .note h5,.post-body .note h6{border-bottom:initial;margin:0;padding-top:0}.post-body .note :first-child{margin-top:0}.post-body .note :last-child{margin-bottom:0}.post-body .note.default{border-left-color:#777}.post-body .note.default h2,.post-body .note.default h3,.post-body .note.default h4,.post-body .note.default h5,.post-body .note.default h6{color:#777}.post-body .note.primary{border-left-color:#6f42c1}.post-body .note.primary h2,.post-body .note.primary h3,.post-body .note.primary h4,.post-body .note.primary h5,.post-body .note.primary h6{color:#6f42c1}.post-body .note.info{border-left-color:#428bca}.post-body .note.info h2,.post-body .note.info h3,.post-body .note.info h4,.post-body .note.info h5,.post-body .note.info h6{color:#428bca}.post-body .note.success{border-left-color:#5cb85c}.post-body .note.success h2,.post-body .note.success h3,.post-body .note.success h4,.post-body .note.success h5,.post-body .note.success h6{color:#5cb85c}.post-body .note.warning{border-left-color:#f0ad4e}.post-body .note.warning h2,.post-body .note.warning h3,.post-body .note.warning h4,.post-body .note.warning h5,.post-body .note.warning h6{color:#f0ad4e}.post-body .note.danger{border-left-color:#d9534f}.post-body .note.danger h2,.post-body .note.danger h3,.post-body .note.danger h4,.post-body .note.danger h5,.post-body .note.danger h6{color:#d9534f}.post-body .tabs{margin-bottom:20px}.post-body .tabs,.tabs-comment{padding-top:10px}.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{background:var(--content-bg-color);z-index:5;flex-wrap:wrap;justify-content:center;margin:0;padding:0;display:flex;position:sticky;top:0}@media (width<=413px){.post-body .tabs ul.nav-tabs,.tabs-comment ul.nav-tabs{margin-bottom:5px;display:block}}.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border:1px solid #0000;border-top-width:3px;border-bottom-color:#ddd;border-radius:0;flex-grow:1;list-style-type:none}@media (width<=413px){.post-body .tabs ul.nav-tabs li.tab,.tabs-comment ul.nav-tabs li.tab{border:1px solid #0000;border-left-width:3px;border-radius:0}}.post-body .tabs ul.nav-tabs li.tab a,.tabs-comment ul.nav-tabs li.tab a{border-bottom:initial;text-align:center;padding:.25em .75em;line-height:1.8;transition:all .2s ease-out;display:block}.post-body .tabs ul.nav-tabs li.tab a i[class^=fa],.tabs-comment ul.nav-tabs li.tab a i[class^=fa]{width:1.28571em}.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#fc6423 #ddd #0000}@media (width<=413px){.post-body .tabs ul.nav-tabs li.tab.active,.tabs-comment ul.nav-tabs li.tab.active{border-color:#ddd #ddd #ddd #fc6423}}.post-body .tabs ul.nav-tabs li.tab.active a,.tabs-comment ul.nav-tabs li.tab.active a{cursor:default}.post-body .tabs .tab-content,.tabs-comment .tab-content{border:1px solid #ddd;border-top-color:#0000;border-radius:0}@media (width<=413px){.post-body .tabs .tab-content,.tabs-comment .tab-content{border-top-color:#ddd;border-radius:0}}.post-body .tabs .tab-content .tab-pane,.tabs-comment .tab-content .tab-pane{padding:20px 20px 0}.post-body .tabs .tab-content .tab-pane:not(.active),.tabs-comment .tab-content .tab-pane:not(.active){display:none}.pagination .prev,.pagination .next,.pagination .page-number,.pagination .space{margin:-1px 10px 0;padding:0 10px;display:inline-block}@media (width<=767px){.pagination .prev,.pagination .next,.pagination .page-number,.pagination .space{margin:0 5px}}.pagination .page-number.current{color:var(--content-bg-color);background:#ccc;border-color:#ccc}.pagination{text-align:center;border-top:1px solid #eee;margin:120px 0 0}.pagination .prev,.pagination .next,.pagination .page-number{border-top:1px solid #eee;border-bottom:0;transition:border-color .2s ease-in-out}.pagination .prev:hover,.pagination .next:hover,.pagination .page-number:hover{border-top-color:var(--link-hover-color)}@media (width<=767px){.pagination{border-top:0}.pagination .prev,.pagination .next,.pagination .page-number{border-top:0;border-bottom:1px solid #eee}.pagination .prev:hover,.pagination .next:hover,.pagination .page-number:hover{border-bottom-color:var(--link-hover-color)}}.pagination .space{margin:0;padding:0}.comments{margin-top:60px;overflow:hidden}.comment-button-group{flex-wrap:wrap;justify-content:center;margin:1em 0;display:flex}.comment-button-group .comment-button{margin:.1em .2em}.comment-button-group .comment-button.active{background:var(--btn-default-hover-bg);border-color:var(--btn-default-hover-border-color);color:var(--btn-default-hover-color)}.comment-position{display:none}.comment-position.active{display:block}.tabs-comment{margin-top:4em;padding-top:0}.tabs-comment .comments{margin-top:0;padding-top:0}.headband{background:var(--theme-color);height:3px}@media (width<=991px){.headband{display:none}}.site-brand-container{flex-shrink:0;padding:0 10px;display:flex}.use-motion .column,.use-motion .site-brand-container .toggle{opacity:0}.site-meta{text-align:center;flex-grow:1}@media (width<=767px){.site-meta{text-align:center}}.custom-logo-image{margin-top:20px}@media (width<=991px){.custom-logo-image{display:none}}.brand{color:var(--brand-color);border-bottom:0;padding:0;display:inline-block}.brand:hover{color:var(--brand-hover-color)}.site-title{margin:0;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:1.375em;font-weight:400;line-height:1.5}.site-subtitle{color:#ddd;margin:10px 10px 0;font-size:.8125em}.use-motion .site-title,.use-motion .site-subtitle,.use-motion .custom-logo-image{opacity:0;position:relative;top:-10px}.site-nav-toggle,.site-nav-right{display:none}@media (width<=767px){.site-nav-toggle,.site-nav-right{flex-direction:column;justify-content:center;display:flex}}.site-nav-toggle .toggle,.site-nav-right .toggle{color:var(--text-color);width:22px;padding:10px}.site-nav-toggle .toggle .toggle-line,.site-nav-right .toggle .toggle-line{background:var(--text-color);border-radius:1px}@media (width<=767px){.site-nav{--scroll-height:0;visibility:hidden;height:0;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height);visibility:unset}}.menu{text-align:center;margin:0;padding:1em 0}.menu-item{margin:0 10px;list-style:none;display:inline-block}@media (width<=767px){.menu-item{margin-top:10px;display:block}.menu-item.menu-item-search{display:none}}.menu-item a{border-bottom:0;font-size:.8125em;transition:border-color .2s ease-in-out;display:block}.menu-item a:hover,.menu-item a.menu-item-active{background:var(--menu-item-bg-color)}.menu-item i[class^=fa]{margin-right:8px}.menu-item .badge{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-weight:700;line-height:1}.use-motion .menu-item{visibility:hidden}@media (width<=991px){.sidebar{left:-320px}.sidebar-active .sidebar{left:0}.sidebar{z-index:20;background:#222;width:320px;max-height:100vh;transition:left .2s ease-out,right .2s ease-out;position:fixed;top:0;bottom:0;overflow-y:auto;box-shadow:inset 0 2px 6px #000}.sidebar a{color:#999;border-bottom-color:#555}.sidebar a:hover{color:#eee;border-bottom-color:#eee}.links-of-author:not(:first-child){margin-top:15px}.links-of-author a{vertical-align:middle;border-bottom-color:#555;margin-bottom:10px;margin-right:10px;display:inline-block}.links-of-author a:before{content:" ";background:#7e086b;border-radius:50%;width:4px;height:4px;margin-right:3px;display:inline-block;transform:translateY(-2px)}.links-of-blogroll-item{padding:0 5px}.popular-posts .popular-posts-item .popular-posts-link:hover{background:0 0}.sidebar-dimmer{opacity:0;visibility:hidden;z-index:10;background:#000;width:100%;height:100%;transition:visibility .4s,opacity .4s;position:fixed;top:0;left:0}.sidebar-active .sidebar-dimmer{opacity:.7;visibility:visible}}.sidebar-inner{color:#999;text-align:center;flex-direction:column;justify-content:center;padding:18px 10px;display:flex}.sidebar-toggle{cursor:pointer;opacity:.6;z-index:30;background:#222;width:16px;height:16px;padding:5px;position:fixed;bottom:61px;left:30px}@media (width<=991px){.sidebar-toggle{left:20px}}.sidebar-toggle:hover{opacity:.8}@media (width<=991px){.sidebar-toggle{opacity:.8}}.sidebar-toggle:hover .toggle-line{background:#fc6423}@media (any-hover:hover){body:not(.sidebar-active) .sidebar-toggle:hover :first-child{width:50%;top:2px;left:50%;transform:rotate(45deg)}body:not(.sidebar-active) .sidebar-toggle:hover :last-child{width:50%;top:-2px;left:50%;transform:rotate(-45deg)}}.sidebar-active .sidebar-toggle :nth-child(2){opacity:0}.sidebar-active .sidebar-toggle :first-child{top:6px;transform:rotate(45deg)}.sidebar-active .sidebar-toggle :last-child{top:-6px;transform:rotate(-45deg)}.sidebar-nav{pointer-events:none;visibility:hidden;height:0;margin:0;padding-left:0;font-size:.875em;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}.sidebar-nav-active .sidebar-nav{pointer-events:unset;height:calc(2em + 1px);visibility:unset}.sidebar-nav li{color:var(--text-color);cursor:pointer;border-bottom:1px solid #0000;transition:border-bottom-color .2s ease-in-out,color .2s ease-in-out;display:inline-block}.sidebar-nav li.sidebar-nav-overview{margin-left:10px}.sidebar-nav li:hover{color:#fc6423}.sidebar-toc-active .sidebar-nav-toc,.sidebar-overview-active .sidebar-nav-overview{color:#fc6423;border-bottom-color:#fc6423;transition-delay:.2s}.sidebar-toc-active .sidebar-nav-toc:hover,.sidebar-overview-active .sidebar-nav-overview:hover{color:#fc6423}.sidebar-panel-container{flex:1;align-items:start;padding-top:0;transition:padding-top .2s ease-in-out;display:grid;overflow:hidden auto}.sidebar-nav-active .sidebar-panel-container{padding-top:20px}.sidebar-panel{opacity:0;pointer-events:none;visibility:hidden;grid-area:1/1;height:0;transition:opacity .2s ease-in-out,transform .2s ease-in-out,visibility .2s ease-in-out;animation:.2s ease-in-out deactivate-sidebar-panel;overflow:hidden;transform:translateY(0)}.sidebar-nav-active .sidebar-panel,.sidebar-overview-active .sidebar-panel.post-toc-wrap{transform:translateY(-20px)}.sidebar-overview-active:not(.sidebar-nav-active) .sidebar-panel.post-toc-wrap{transition-delay:0s,.2s,0s}.sidebar-overview-active .sidebar-panel.site-overview-wrap,.sidebar-toc-active .sidebar-panel.post-toc-wrap{opacity:1;pointer-events:unset;height:auto;visibility:unset;transition-delay:.2s,.2s,0s;animation-name:activate-sidebar-panel;transform:translateY(0)}.sidebar-panel.site-overview-wrap{flex-direction:column;justify-content:flex-start;gap:10px;display:flex}@keyframes deactivate-sidebar-panel{0%{height:var(--inactive-panel-height,0)}to{height:var(--active-panel-height,0)}}@keyframes activate-sidebar-panel{0%{height:var(--inactive-panel-height,auto)}to{height:var(--active-panel-height,auto)}}.post-toc{font-size:.875em}.post-toc ol{text-align:left;margin:0;padding:0 2px 0 10px;list-style:none}.post-toc ol>:last-child{margin-bottom:5px}.post-toc ol>ol{padding-left:0}.post-toc ol a{transition:all .2s ease-in-out}.post-toc .nav-item{text-overflow:ellipsis;white-space:nowrap;line-height:1.8;overflow:hidden}.post-toc .nav .active>a{color:#fc6423;border-bottom-color:#fc6423}.post-toc .nav .active-current>a,.post-toc .nav .active-current>a:hover{color:#fc6423}.site-author-image{border:1px solid #eee;border-radius:50%;max-width:120px;padding:2px}.site-author-name{color:var(--text-color);margin:0;font-weight:600}.site-description{color:#999;margin-top:0;font-size:.8125em}.site-state{flex-wrap:wrap;justify-content:center;line-height:1.4;display:flex}.site-state-item{padding:0 15px}.site-state-item a{border-bottom:0;display:block}.site-state-item-count{font-size:1em;font-weight:600;display:block}.site-state-item-name{color:#999;font-size:.8125em}.sidebar .sidebar-button:not(:first-child){margin-top:15px}.sidebar .sidebar-button button{color:#fc6423;cursor:pointer;background:0 0;border:1px solid #fc6423;border-radius:4px;padding:0 15px;line-height:2}.sidebar .sidebar-button button:hover{color:#fff;background:#fc6423}.sidebar .sidebar-button button i[class^=fa]{margin-right:5px}.links-of-author a{font-size:.8125em}.links-of-author i[class^=fa]{margin-right:2px}.cc-license .cc-opacity{opacity:.7;border-bottom:0}.cc-license .cc-opacity:hover{opacity:.9}.cc-license img{display:inline-block}.links-of-blogroll{font-size:.8125em}.links-of-blogroll-title{font-size:.875em;font-weight:600}.links-of-blogroll-list{flex-flow:column wrap;justify-content:center;gap:5px;margin:5px 0 0;padding:0;list-style:none;display:flex}.links-of-blogroll-item{max-width:100%}.links-of-blogroll-item a{box-sizing:border-box;text-overflow:ellipsis;white-space:nowrap;max-width:100%;display:inline-block;overflow:hidden}.footer{color:#999;padding:20px 0;font-size:.875em;transition:left .2s ease-in-out,right .2s ease-in-out}.footer.footer-fixed{position:absolute;bottom:0;left:0;right:0}.footer-inner{box-sizing:border-box;text-align:center;flex-direction:column;justify-content:center;width:calc(100% - 20px);margin:0 auto;display:flex}@media (width<=767px){.footer-inner{width:auto}}@media (width>=1200px){.footer-inner{width:1160px}}@media (width>=1600px){.footer-inner{width:73%}}.use-motion .footer{opacity:0}.languages{font-size:1.125em;display:inline-block;position:relative}.languages .lang-select-label span{margin:0 .5em}.languages .lang-select{opacity:0;width:100%;height:100%;position:absolute;top:0;left:0}.with-love{color:red;margin:0 5px;display:inline-block}@keyframes icon-animate{0%,to{transform:scale(1)}10%,30%{transform:scale(.9)}20%,40%,60%,80%{transform:scale(1.1)}50%,70%{transform:scale(1.1)}}.back-to-top{color:#fff;cursor:pointer;opacity:.6;z-index:30;background:#222;align-items:center;height:26px;font-size:12px;transition:bottom .2s ease-in-out;display:flex;position:fixed;bottom:-100px;left:30px}.back-to-top span{margin-right:8px}.back-to-top .fa{text-align:center;width:26px}@media (width<=991px){.back-to-top{left:20px}}.back-to-top:hover{opacity:.8}@media (width<=991px){.back-to-top{opacity:.8}}.back-to-top:hover{color:#fc6423}.back-to-top.back-to-top-on{bottom:30px}.rtl.post-body p,.rtl.post-body a,.rtl.post-body h1,.rtl.post-body h2,.rtl.post-body h3,.rtl.post-body h4,.rtl.post-body h5,.rtl.post-body h6,.rtl.post-body li,.rtl.post-body ul,.rtl.post-body ol{direction:rtl;font-family:UKIJ Ekran}.rtl.post-title{font-family:UKIJ Ekran}.post-button{text-align:center;margin-top:40px}.use-motion .post-block,.use-motion .pagination,.use-motion .comments,.use-motion .post-header,.use-motion .post-body,.use-motion .collection-header{visibility:hidden}.posts-collapse .post-content{margin-bottom:35px;margin-left:35px;position:relative}@media (width<=767px){.posts-collapse .post-content{margin-left:0;margin-right:0}}.posts-collapse .post-content .collection-title{font-size:1.125em;position:relative}.posts-collapse .post-content .collection-title:before{content:" ";background:#999;border:1px solid #fff;border-radius:50%;width:10px;height:10px;margin-top:-4px;margin-left:-6px;position:absolute;top:50%}.posts-collapse .post-content .collection-year{margin:60px 0;font-size:1.5em;font-weight:700;position:relative}.posts-collapse .post-content .collection-year .collection-year-count{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-size:.75em;font-weight:700;line-height:1}.posts-collapse .post-content .collection-year:before{content:" ";background:#bbb;border-radius:50%;width:8px;height:8px;margin-top:-4px;margin-left:-4px;position:absolute;top:50%}.posts-collapse .post-content .collection-header{margin-left:20px;display:block}.posts-collapse .post-content .collection-header small{color:#bbb;margin-left:5px}.posts-collapse .post-content .post-header{border-bottom:1px dashed #ccc;margin:30px 2px 0;padding-left:15px;transition:border .2s ease-in-out;position:relative}.posts-collapse .post-content .post-header:before{content:" ";background:#bbb;border:1px solid #fff;border-radius:50%;width:6px;height:6px;transition:background .2s ease-in-out;position:absolute;top:.75em;left:-6px}.posts-collapse .post-content .post-header:hover{border-bottom-color:#666}.posts-collapse .post-content .post-header:hover:before{background:#222}.posts-collapse .post-content .post-meta-container{margin-right:10px;font-size:.75em;display:inline}.posts-collapse .post-content .post-title{display:inline}.posts-collapse .post-content .post-title a{color:var(--link-color);border-bottom:0}.posts-collapse .post-content .post-title .fa{margin-left:5px;font-size:.875em}.posts-collapse .post-content:before{content:" ";background:#f5f5f5;width:4px;height:100%;margin-left:-2px;position:absolute;top:1.25em}.post-body{overflow-wrap:break-word;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif}@media (width>=1200px){.post-body{font-size:1.125em}}@media (width>=992px){.post-body{text-align:justify}}@media (width<=991px){.post-body{text-align:justify}}.post-body h1 .header-anchor,.post-body h2 .header-anchor,.post-body h3 .header-anchor,.post-body h4 .header-anchor,.post-body h5 .header-anchor,.post-body h6 .header-anchor,.post-body h1 .headerlink,.post-body h2 .headerlink,.post-body h3 .headerlink,.post-body h4 .headerlink,.post-body h5 .headerlink,.post-body h6 .headerlink{color:inherit;float:right;opacity:0;border-bottom-style:none;margin-left:10px;font-size:.875em}.post-body h1 .header-anchor:before,.post-body h2 .header-anchor:before,.post-body h3 .header-anchor:before,.post-body h4 .header-anchor:before,.post-body h5 .header-anchor:before,.post-body h6 .header-anchor:before,.post-body h1 .headerlink:before,.post-body h2 .headerlink:before,.post-body h3 .headerlink:before,.post-body h4 .headerlink:before,.post-body h5 .headerlink:before,.post-body h6 .headerlink:before{content:"";font-family:"Font Awesome 6 Free";font-weight:900}.post-body h1:hover .header-anchor,.post-body h2:hover .header-anchor,.post-body h3:hover .header-anchor,.post-body h4:hover .header-anchor,.post-body h5:hover .header-anchor,.post-body h6:hover .header-anchor,.post-body h1:hover .headerlink,.post-body h2:hover .headerlink,.post-body h3:hover .headerlink,.post-body h4:hover .headerlink,.post-body h5:hover .headerlink,.post-body h6:hover .headerlink{opacity:.5}.post-body h1:hover .header-anchor:hover,.post-body h2:hover .header-anchor:hover,.post-body h3:hover .header-anchor:hover,.post-body h4:hover .header-anchor:hover,.post-body h5:hover .header-anchor:hover,.post-body h6:hover .header-anchor:hover,.post-body h1:hover .headerlink:hover,.post-body h2:hover .headerlink:hover,.post-body h3:hover .headerlink:hover,.post-body h4:hover .headerlink:hover,.post-body h5:hover .headerlink:hover,.post-body h6:hover .headerlink:hover{opacity:1}.post-body .exturl .fa{margin-left:4px;font-size:.875em}.post-body figure:not(.highlight) figcaption{color:#999;text-align:center;margin:-15px auto 15px;font-size:.875em;font-weight:700;line-height:1}.post-body iframe,.post-body img,.post-body video,.post-body embed{margin-bottom:20px}.post-body .video-container{width:100%;height:0;margin-bottom:20px;padding-top:75%;position:relative;overflow:hidden}.post-body .video-container iframe,.post-body .video-container object,.post-body .video-container embed{width:100%;height:100%;margin:0;position:absolute;top:0;left:0}.post-gallery{min-height:200px;display:flex}.post-gallery .post-gallery-image{flex:1}.post-gallery .post-gallery-image:not(:first-child){clip-path:polygon(40px 0,100% 0,100% 100%,0 100%);margin-left:-20px}.post-gallery .post-gallery-image:not(:last-child){margin-right:-20px}.post-gallery .post-gallery-image img{object-fit:cover;opacity:1;width:100%;height:100%}.posts-expand .post-gallery{margin-bottom:60px}.posts-collapse .post-gallery{margin:15px 0}.posts-expand .post-header{text-align:center;margin-bottom:60px;font-size:1.125em}.posts-expand .post-title{margin:initial;overflow-wrap:break-word;font-size:1.5em;font-weight:400}.posts-expand .post-title-link{color:var(--link-color);border-bottom:0;max-width:100%;display:inline-block;position:relative}.posts-expand .post-title-link:before{background:var(--link-color);content:"";width:100%;height:2px;transition:transform .2s ease-in-out;position:absolute;bottom:0;left:0;transform:scaleX(0)}.posts-expand .post-title-link:hover:before{transform:scaleX(1)}.posts-expand .post-title-link .fa{margin-left:5px;font-size:.875em}.post-sticky-flag{margin-right:8px;display:inline-block;transform:rotate(30deg)}.posts-expand .post-meta-container{color:#999;margin-top:3px;font-family:Lato,PingFang SC,Microsoft YaHei,sans-serif;font-size:.75em}.posts-expand .post-meta-container .post-description{margin-top:2px;font-size:.875em}.posts-expand .post-meta-container time{border-bottom:1px dashed #999}.post-meta{flex-wrap:wrap;justify-content:center;display:flex}:not(.post-meta-break)+.post-meta-item:before{content:"|";margin:0 .5em}.post-meta-item-icon{margin-right:3px}@media (width<=991px){.post-meta-item-text{display:none}}.post-meta-break{flex-basis:100%;height:0}.post-nav{border-top:1px solid #eee;justify-content:space-between;gap:30px;margin-top:1em;padding:10px 5px 0;display:flex}.post-nav-item{flex:1}.post-nav-item a{border-bottom:0;font-size:.875em;line-height:1.6;display:block}.post-nav-item a:active{top:2px}.post-nav-item .fa{font-size:.75em}.post-nav-item:first-child .fa{margin-right:5px}.post-nav-item:last-child{text-align:right}.post-nav-item:last-child .fa{margin-left:5px}.post-footer{flex-direction:column;justify-content:center;display:flex}.post-eof{background:#ccc;width:8%;height:1px;margin:80px auto 60px}.post-block:last-of-type .post-eof{display:none}.post-copyright ul{background:var(--card-bg-color);border-left:3px solid #ff2a2a;margin:1em 0 0;padding:.5em 1em;list-style:none;position:relative;overflow:hidden}.post-copyright ul:after{content:"";opacity:.1;font-family:"Font Awesome 6 Brands";font-size:200px;position:absolute;top:-150px;right:-50px}.post-tags{text-align:center;margin-top:40px}.post-tags a{font-size:.8125em;display:inline-block}.post-tags a:not(:last-child){margin-right:10px}.social-like{border-top:1px solid #eee;flex-wrap:wrap;justify-content:center;margin-top:1em;padding-top:1em;font-size:.875em;display:flex}.social-like a{border-bottom:none}.reward-container{text-align:center;margin:1em 0 0;padding:1em 0}.reward-container button{color:#fc6423;cursor:pointer;vertical-align:text-top;background:0 0;border:2px solid #fc6423;border-radius:2px;outline:0;padding:0 15px;line-height:2}.reward-container button:hover{color:#fff;background:#fc6423}.post-reward{padding-top:20px;display:none}.post-reward.active{display:block}.post-reward div{display:inline-block}.post-reward div span{display:block}.post-reward img{width:180px;max-width:100%;margin:.8em 2em 0;display:inline-block}@keyframes next-roll{0%{transform:rotate(30deg)}to{transform:rotate(-30deg)}}.category-all-page .category-all-title{text-align:center}.category-all-page .category-all{margin-top:20px}.category-all-page .category-list{margin:0;padding:0;list-style:none}.category-all-page .category-list-item{margin:5px 10px}.category-all-page .category-list-count{color:var(--content-bg-color);text-shadow:1px 1px #0000001a;background:#ccc;border-radius:10px;margin-left:.35em;padding:2px 5px;font-size:.75em;font-weight:700;line-height:1}.category-all-page .category-list-child{padding-left:10px}.event-list hr{background:#222;margin:20px 0 45px}.event-list hr:after{color:#fff;content:"NOW";background:#222;padding:0 5px;font-weight:700;display:inline-block}.event-list .event{--event-background:#222;--event-foreground:#bbb;--event-title:#fff;background:var(--event-background);padding:15px}.event-list .event .event-summary{color:var(--event-title);border-bottom:0;margin:0;padding:0 0 0 35px;position:relative}.event-list .event .event-summary:before{background:var(--event-title);content:" ";border-radius:50%;width:12px;height:12px;margin-top:-6px;animation:1s ease-in-out infinite alternate dot-flash;position:absolute;top:50%;left:0}.event-list .event:nth-of-type(odd) .event-summary:before{animation-delay:.5s}.event-list .event:not(:last-child){margin-bottom:20px}.event-list .event .event-relative-time{color:var(--event-foreground);padding-left:12px;font-size:12px;font-weight:400;display:inline-block}.event-list .event .event-details{color:var(--event-foreground);padding:6px 0 6px 35px;line-height:18px;display:block}.event-list .event .event-details:before{color:var(--event-foreground);width:14px;margin-right:9px;font-family:"Font Awesome 6 Free";font-weight:900;display:inline-block}.event-list .event .event-details.event-location:before{content:""}.event-list .event .event-details.event-duration:before{content:""}.event-list .event .event-details.event-description:before{content:""}.event-list .event-past{--event-background:#f5f5f5;--event-foreground:#999;--event-title:#222}@keyframes dot-flash{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}ul.breadcrumb{text-align:center;margin:1em 0;padding:0 2em;font-size:.75em;list-style:none}ul.breadcrumb li{display:inline}ul.breadcrumb li:not(:first-child):before{content:"/ ";padding:.5em;font-weight:400}ul.breadcrumb li:last-child{font-weight:700}.tag-cloud{text-align:center}.tag-cloud a{margin:10px;display:inline-block}.tag-cloud-0{color:#aaa;border-bottom-color:#aaa}.tag-cloud-1{color:#9a9a9a;border-bottom-color:#9a9a9a}.tag-cloud-2{color:#8b8b8b;border-bottom-color:#8b8b8b}.tag-cloud-3{color:#7c7c7c;border-bottom-color:#7c7c7c}.tag-cloud-4{color:#6c6c6c;border-bottom-color:#6c6c6c}.tag-cloud-5{color:#5d5d5d;border-bottom-color:#5d5d5d}.tag-cloud-6{color:#4e4e4e;border-bottom-color:#4e4e4e}.tag-cloud-7{color:#3e3e3e;border-bottom-color:#3e3e3e}.tag-cloud-8{color:#2f2f2f;border-bottom-color:#2f2f2f}.tag-cloud-9{color:#202020;border-bottom-color:#202020}.tag-cloud-10{color:#111;border-bottom-color:#111}.utterances{max-width:unset}.search-active{margin-right:var(--dialog-scrollgutter,0);overflow:hidden}.search-pop-overlay{visibility:hidden;z-index:40;background:0 0;width:100%;height:100%;transition:visibility .4s,background .4s;display:flex;position:fixed;top:0;left:0}.search-active .search-pop-overlay{visibility:visible;background:#0000004d}.search-popup{background:var(--card-bg-color);border-radius:5px;width:700px;height:80%;margin:auto;transition:transform .4s;transform:scale(0)}.search-active .search-popup{transform:scale(1)}@media (width<=767px){.search-popup{border-radius:0;width:100%;height:100%}}.search-popup .search-icon,.search-popup .popup-btn-close{color:#999;padding:0 10px;font-size:18px}.search-popup .popup-btn-close{cursor:pointer}.search-popup .popup-btn-close:hover .fa{color:#222}.search-popup .search-header{background:#eee;border-top-left-radius:5px;border-top-right-radius:5px;padding:5px;display:flex}.search-popup input.search-input{background:0 0;border:0;outline:0;width:100%}.search-popup input.search-input::-webkit-search-cancel-button{display:none}.search-popup .search-result-container{flex-direction:column;height:calc(100% - 55px);padding:5px 25px;display:flex;overflow:auto}.search-popup .search-result-container hr{flex-shrink:0;margin:5px 0 10px}.search-popup .search-result-container hr:first-child{display:none}.search-popup .search-result-list{margin:0 5px;padding:0}.search-popup a.search-result-title{font-weight:700}.search-popup p.search-result{border-bottom:1px dashed #ccc;margin:0 0 10px;padding:5px 0}.search-popup .search-input-container{flex-grow:1;padding:2px}.search-popup .search-result-icon{color:#ccc;margin:auto}mark.search-keyword{color:#ff2a2a;background:0 0;border-bottom:1px dashed #ff2a2a;font-weight:700}.use-motion .animated{visibility:inherit;animation-fill-mode:none}.use-motion .sidebar .animated{animation-fill-mode:both}header.header{background:var(--content-bg-color);border-radius:initial;box-shadow:initial}@media (width<=991px){header.header{border-radius:initial}}.main{justify-content:space-between;align-items:stretch;width:calc(100% - 20px);margin:0 auto;display:flex}@media (width<=767px){.main{width:auto}}@media (width>=1200px){.main{width:1160px}}@media (width>=1600px){.main{width:73%}}@media (width<=991px){.main{width:auto;display:block}}.main-inner{border-radius:initial;box-sizing:border-box;width:calc(100% - 252px)}@media (width<=991px){.main-inner{border-radius:initial;width:100%}}.footer-inner{padding-left:252px}@media (width<=991px){.footer-inner{width:auto;padding-left:0;padding-right:0}}.column{width:240px}@media (width<=991px){.column{width:auto}}.site-brand-container{background:var(--theme-color)}@media (width<=991px){.site-nav-on .site-brand-container{box-shadow:0 0 16px #00000080}}.site-meta{padding:20px 0}@media (width>=768px) and (width<=991px){.site-nav-toggle,.site-nav-right{flex-direction:column;justify-content:center;display:flex}}.site-nav-toggle .toggle,.site-nav-right .toggle{color:#fff}.site-nav-toggle .toggle .toggle-line,.site-nav-right .toggle .toggle-line{background:#fff}@media (width>=768px) and (width<=991px){.site-nav{--scroll-height:0;visibility:hidden;height:0;transition:height .2s ease-in-out,visibility .2s ease-in-out;overflow:hidden}body:not(.site-nav-on) .site-nav .animated{animation:none}body.site-nav-on .site-nav{height:var(--scroll-height);visibility:unset}}.menu .menu-item{margin:0;display:block}.menu .menu-item a{align-items:center;padding:5px 20px;transition-property:background-color;display:flex;position:relative}.menu .menu-item a .badge{margin-left:auto}@media (width<=991px){.menu .menu-item.menu-item-search{display:none}}.sub-menu{margin:0;padding:6px 0}.sub-menu .menu-item{display:inline-block}.sub-menu .menu-item a{padding:initial;background:0 0;margin:5px 10px}.sub-menu .menu-item a:hover{color:#fc6423;background:0 0}.sub-menu .menu-item-active{color:#fc6423;border-bottom-color:#fc6423}.sub-menu .menu-item-active:hover{border-bottom-color:#fc6423}@media (width>=992px){.sidebar{position:sticky;top:12px}.sidebar-toggle{display:none}.sidebar-inner{background:var(--content-bg-color);border-radius:initial;box-shadow:initial;box-sizing:border-box;color:var(--text-color);visibility:hidden;max-height:calc(100vh - 24px);margin-top:12px}.site-state-item{padding:0 10px}.sidebar .sidebar-button{border-top:1px dotted #ccc;border-bottom:1px dotted #ccc}.sidebar .sidebar-button button{color:#fc6423;border:0;width:100%;display:block}.sidebar .sidebar-button button:hover{color:#e34603;background:0 0;border:0}.links-of-author{flex-wrap:wrap;justify-content:center;display:flex}.links-of-author-item{width:50%;margin:5px 0 0}.links-of-author-item a{box-sizing:border-box;text-overflow:ellipsis;white-space:nowrap;border-bottom:0;border-radius:4px;max-width:100%;padding:0 5px;display:inline-block;overflow:hidden}.links-of-author-item a:hover{background:var(--body-bg-color)}.links-of-blogroll-item a{padding:0 5px}}.main-inner{background:var(--content-bg-color);box-shadow:initial;padding:40px}@media (width<=991px){.main-inner{padding:20px}}.sub-menu{border-bottom:1px solid #ddd}.post-block:first-of-type{padding-top:40px}@media (width<=767px){.pagination{margin-bottom:10px}}</style><link integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css rel=stylesheet><link integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css rel=stylesheet><script integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js></script><script class=next-config data-name=main type=application/json>{"hostname":"oz1010.github.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"stackoverflow-light","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":100,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script defer src=/js/config.js></script><meta content=普通而有趣的技术员 name=description><meta content=website property=og:type><meta content="oz1010's blog" property=og:title><meta content=https://oz1010.github.com/page/2/index.html property=og:url><meta content="oz1010's blog" property=og:site_name><meta content=普通而有趣的技术员 property=og:description><meta content=zh_CN property=og:locale><meta content=oz1010 property=article:author><meta content=summary name=twitter:card><link href=https://oz1010.github.com/page/2/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>oz1010's blog</title><script integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script defer src=/js/utils.js></script><script defer src=/js/motion.js></script><script defer src=/js/sidebar.js></script><script defer src=/js/next-boot.js></script><script integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js></script><script defer src=/js/third-party/search/local-search.js></script><script defer src=/js/third-party/pace.js></script><noscript><link href=/css/noscript.css rel=stylesheet></noscript><link title="oz1010's blog" href=/atom.xml rel=alternate type=application/atom+xml><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>oz1010's blog</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>记录生活或技能</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>4</span></a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>18</span></a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>44</span></a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=oz1010 class=site-author-image itemprop=image src=/images/avatar.jpg><p class=site-author-name itemprop=name>oz1010<div class=site-description itemprop=description>普通而有趣的技术员</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>44</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>18</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>4</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/oz1010" href=https://github.com/oz1010 target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a rel="noopener me" title="E-Mail → mailto:alfdxl@163.com" href=mailto:alfdxl@163.com target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span></div><div class="cc-license animated" itemprop=license><a class=cc-opacity href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><img alt="Creative Commons" src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg></a></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/06/12/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/06/12/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%BF%E7%94%A8/ itemprop=url>嵌入式-ARM处理器使用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-06-12 11:53:31" datetime=2024-06-12T11:53:31+08:00>2024-06-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>嵌入式</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>47</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>1 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h2 id=注意事项>注意事项</h2><h3 id=指令差异>指令差异</h3><p>ARM处理器具有<code>ARM</code>和<code>Thumb</code>两种指令，相互切换一般采用<code>b</code>类指令进行跳转，否则处理器会返回异常。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/ itemprop=url>分布式基础理论</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-06-08 12:13:13" datetime=2024-06-08T12:13:13+08:00>2024-06-08</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>分布式</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>1k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>4 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=分布式基础理论>分布式基础理论</h1><h2 id=cap理论基本概念>CAP理论基本概念</h2><ul><li>数据一致性（consistency）：若系统更新操作成功，则它之后的读请求都必须读到这个新数据；若失败，则所有读请求都不能读到这个新数据，对调用者而言数据具有强一致性（strong consistency）<li>服务可用性（availability）：所有请求在一定时间内得到响应，可终止，不会一直等待<li>分区容错性（partition-tolerance）：在网络分区的情况下，被分隔的节点仍能正常对外服务</ul><h2 id=cap三者不空兼得>CAP三者不空兼得</h2><p>若放弃P，即系统称为传统的单服务器模式；而分布式必然不能放弃P；<p>实现P就允许网络存在异常。若实现CP，向一个分区的更新操作因一致性要求，必然导致网络恢复前，其他分区不能满足可用性。若实现AP，存在不同分区因网络异常，无法保证强一致性。<p>因此，分布式系统理论上不可能选择CA架构，只能选择CP或AP架构。<h2 id=base理论>Base理论</h2><p>CAP理论的一种妥协，由于CAP只能二取一，Base理论降低了发生分区容错时对可用性和一致性的要求。<ol type=1><li>基本可用：允许可用性降低（可能响应延长、可能服务降级）<li>软状态：指允许系统中的数据存在中间状态，并任务该中间状态不会影响系统整体可用性（比如支付完成前的支付中）<li>最终一致性：节点数据同步可能存在时延，但在一定的期限后必须达成数据的一致，状态变为最终状态</ol><h2 id=数据一致性模型>数据一致性模型</h2><p>强一致性：当更新操作完成后，任何多个后续进程的访问都会返回更新后的数据。根据CAP理论，这种实现需要牺牲可用性。<p>弱一致性：当更新操作完成后，不承诺立即可以读到更新后的数据，而这段时间存在“不一致性窗口”。<p>最终一致性：是弱一致性的特例，强调的是所有的数据副本，在经过一定时间的同步后，最终能够达到一个一致的状态。达到最终一致性的时间，就是不一致窗口时间。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。<p>最终一致性模型根据其提供的不同保证可以划分为因果一致性和会话一致性等等模型。<p>因果一致性：要求有因果关系的操作顺序要得到保证，非因果关系的操作顺序则无所谓。<p>会话一致性：将对系统数据的访问过程框定在了一个会话当中，约定了系统保证在同一个有效的会话中实现“读己之所写”的一致性。<h2 id=quorumwaro机制>Quorum、WARO机制</h2><p>WARO：一种简单的副本控制协议，写操作时，只有当所有副本都成功更新之后，这次写操作才算成功，否则视为失败。优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。但只要有一个节点存活，任然能够提供读服务。<p>选举算法Quorum机制：如，10个副本，一次成功更新了三个，那么需要读取八个副本的数据，可以保证读到最新数据。无法保证强一致性，也就是无法实现任何时刻或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号的metadata服务，这样可以确定最新成功提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ itemprop=url>嵌入式Linux驱动开发笔记</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-24 09:48:01" datetime=2024-04-24T09:48:01+08:00>2024-04-24</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> ， <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/Driver/ itemprop=url rel=index><span itemprop=name>Driver</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>1.5k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>5 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=模拟vexpress-a9>模拟vexpress-a9</h1><p>使用QEMU模拟vexpress-a9开发板，网络上教程比较多，可以快速搭建好开发环境。<h2 id=基本环境>基本环境</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class=header><th>项目<th>信息<tbody><tr class=odd><td>操作系统<td>Ubuntu 22.04<tr class=even><td>内核<td><a href=https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.334.tar.xz rel=noopener target=_blank>linux-4.14.334</a><tr class=odd><td>根文件系统<td><a href=https://busybox.net/downloads/busybox-1.36.1.tar.bz2 rel=noopener target=_blank>busybox-1.36.1</a><tr class=even><td>引导程序<td><a href=https://ftp.denx.de/pub/u-boot/u-boot-2022.10-rc5.tar.bz2 rel=noopener target=_blank>u-boot-2022.10-rc5</a></table><h2 id=安装依赖>安装依赖</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> apt-get install -y make gcc bc libncurses5-dev bison flex libssl-dev u-boot-tools gcc-arm-linux-gnueabi g++-arm-linux-gnueabi qemu-system-arm</span><br></pre></table></figure><h2 id=linux内核>Linux内核</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=comment># 使用vexpress默认配置编译</span></span><br><span class=line><span class=built_in>cd</span> linux-4.14.334</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span><br><span class=line><span class=comment># 开启NFS4支持。</span></span><br><span class=line><span class=comment># 位置：File System -> Network File Systems->NFS client support for NFS version 4 （相关的四项全勾上）</span></span><br><span class=line></span><br><span class=line><span class=comment># 编译内核</span></span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- zImage -j$(<span class=built_in>nproc</span>)</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j$(<span class=built_in>nproc</span>)</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules -j$(<span class=built_in>nproc</span>)</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- dtbs -j$(<span class=built_in>nproc</span>)</span><br><span class=line><span class=built_in>cd</span> ..</span><br><span class=line></span><br><span class=line><span class=comment># 启动模拟器</span></span><br><span class=line>qemu-system-arm -M vexpress-a9 -m 128M -kernel linux-4.14.334/arch/arm/boot/zImage -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append <span class=string>"console=ttyAMA0"</span></span><br><span class=line><span class=comment># 这里注意文件的路径，是在linux-4.14.334源码目录执行的。</span></span><br><span class=line><span class=comment># -M vexpress-a9 模拟vexpress-a9单板，你能够使用-M ?參数来获取该qemu版本号支持的全部单板</span></span><br><span class=line><span class=comment># -m 128M 单板执行物理内存128M</span></span><br><span class=line><span class=comment># -kernel xx/zImage 告诉qemu单板执行内核镜像路径</span></span><br><span class=line><span class=comment># -dtb xx/vexpress-v2p-ca9.dtb  告诉qemu单板的设备树（必须加入）</span></span><br><span class=line><span class=comment># -nographic 不使用图形化界面，仅仅使用串口</span></span><br><span class=line><span class=comment># -append "console=ttyAMA0" 内核启动參数。这里告诉内核vexpress单板执行。串口设备是哪个tty。</span></span><br><span class=line></span><br></pre></table></figure><p>提示没有根文件系统，接下来制作它。<h2 id=根文件系统>根文件系统</h2><h3 id=配置编译>配置编译</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> busybox-1.36.1</span><br><span class=line></span><br><span class=line><span class=comment># 配置</span></span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- clean</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span><br><span class=line><span class=comment># 配置页面选择</span></span><br><span class=line><span class=comment># Settings->Build Options->Build static binary</span></span><br><span class=line></span><br><span class=line><span class=comment># 编译</span></span><br><span class=line><span class=comment># 默认安装在_install路径中</span></span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j$(<span class=built_in>nproc</span>)</span><br><span class=line>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span><br><span class=line></span><br><span class=line><span class=built_in>cd</span> ..</span><br></pre></table></figure><h3 id=补充根文件系统>补充根文件系统</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br></pre><td class=code><pre><span class=line><span class=comment># 拷贝基本文件系统</span></span><br><span class=line><span class=built_in>mkdir</span> rootfs-arm32</span><br><span class=line><span class=built_in>cd</span> rootfs-arm32</span><br><span class=line><span class=built_in>cp</span> -rfd ../busybox-1.36.1/_install/* .</span><br><span class=line></span><br><span class=line><span class=comment># 创建设备节点</span></span><br><span class=line><span class=built_in>mkdir</span> dev</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/tty1 c 4 1</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/tty2 c 4 2</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/tty3 c 4 3</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/tty4 c 4 4</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/console c 5 1</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mknod</span> -m 666 dev/null c 1 3</span><br><span class=line></span><br><span class=line><span class=comment># 安装动态链接库</span></span><br><span class=line><span class=built_in>mkdir</span> lib</span><br><span class=line><span class=built_in>cp</span> -d /usr/arm-linux-gnueabi/lib/*.so* ./lib</span><br><span class=line></span><br><span class=line><span class=comment># 配置初始化进程rcS</span></span><br><span class=line><span class=built_in>mkdir</span> -p etc/init.d</span><br><span class=line><span class=built_in>touch</span> etc/init.d/rcS</span><br><span class=line><span class=built_in>chmod</span> 777 etc/init.d/rcS</span><br><span class=line><span class=built_in>cat</span> > etc/init.d/rcS &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>#!/bin/sh</span></span><br><span class=line><span class=string>PATH=/bin:/sbin:/usr/bin:/usr/sbin</span></span><br><span class=line><span class=string>export LD_LIBRARY_PATH=/lib:/usr/lib</span></span><br><span class=line><span class=string>/bin/mount -n -t ramfs ramfs /var</span></span><br><span class=line><span class=string>/bin/mount -n -t ramfs ramfs /tmp</span></span><br><span class=line><span class=string>/bin/mount -n -t sysfs none /sys</span></span><br><span class=line><span class=string>/bin/mount -n -t ramfs none /dev</span></span><br><span class=line><span class=string>/bin/mkdir /var/tmp</span></span><br><span class=line><span class=string>/bin/mkdir /var/modules</span></span><br><span class=line><span class=string>/bin/mkdir /var/run</span></span><br><span class=line><span class=string>/bin/mkdir /var/log</span></span><br><span class=line><span class=string>/bin/mkdir -p /dev/pts</span></span><br><span class=line><span class=string>/bin/mkdir -p /dev/shm</span></span><br><span class=line><span class=string>/sbin/mdev -s</span></span><br><span class=line><span class=string>/bin/mount -a</span></span><br><span class=line><span class=string>echo "-----------------------------------"</span></span><br><span class=line><span class=string>echo "*****welcome to vexpress board*****"</span></span><br><span class=line><span class=string>echo "-----------------------------------"</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line></span><br><span class=line><span class=comment># 配置文件系统fstab</span></span><br><span class=line><span class=built_in>cat</span> > etc/fstab &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>proc    /proc           proc    defaults        0       0</span></span><br><span class=line><span class=string>none    /dev/pts        devpts  mode=0622       0       0</span></span><br><span class=line><span class=string>mdev    /dev            ramfs   defaults        0       0</span></span><br><span class=line><span class=string>sysfs   /sys            sysfs   defaults        0       0</span></span><br><span class=line><span class=string>tmpfs   /dev/shm        tmpfs   defaults        0       0</span></span><br><span class=line><span class=string>tmpfs   /dev            tmpfs   defaults        0       0</span></span><br><span class=line><span class=string>tmpfs   /mnt            tmpfs   defaults        0       0</span></span><br><span class=line><span class=string>var     /dev            tmpfs   defaults        0       0</span></span><br><span class=line><span class=string>ramfs   /dev            ramfs   defaults        0       0</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line></span><br><span class=line><span class=comment># 配置初始化脚本</span></span><br><span class=line><span class=built_in>cat</span> > etc/inittab &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>::sysinit:/etc/init.d/rcS </span></span><br><span class=line><span class=string>::askfirst:-/bin/sh</span></span><br><span class=line><span class=string>::restart:/sbin/init </span></span><br><span class=line><span class=string>::ctrlaltdel:/sbin/reboot</span></span><br><span class=line><span class=string>::shutdown:/bin/umount -a -r</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line></span><br><span class=line><span class=comment># 配置环境变量，'EOF'可以防止内容被解析</span></span><br><span class=line><span class=built_in>cat</span> > etc/profile &lt;&lt;<span class=string>'EOF'</span></span><br><span class=line><span class=comment>#!/bin/sh </span></span><br><span class=line>USER=<span class=string>"root"</span></span><br><span class=line>LOGNAME=<span class=variable>$USER</span></span><br><span class=line><span class=comment># export HOSTNAME=vexpress-a9</span></span><br><span class=line><span class=built_in>export</span> HOSTNAME=`<span class=built_in>cat</span> /etc/sysconfig/HOSTNAME`</span><br><span class=line><span class=built_in>export</span> USER=root</span><br><span class=line><span class=built_in>export</span> HOME=root</span><br><span class=line><span class=built_in>export</span> PS1=<span class=string>"[<span class=variable>$USER</span>@<span class=variable>$HOSTNAME</span>:\w]\#"</span></span><br><span class=line>PATH=/bin:/sbin:/usr/bin:/usr/sbin </span><br><span class=line>LD_LIBRARY_PATH=/lib:/usr/lib:<span class=variable>$LD_LIBRARY_PATH</span></span><br><span class=line><span class=built_in>export</span> PATH LD_LIBRARY_PATH</span><br><span class=line>EOF</span><br><span class=line></span><br><span class=line><span class=comment># 增加主机名</span></span><br><span class=line><span class=built_in>mkdir</span> etc/sysconfig</span><br><span class=line><span class=built_in>cat</span> > etc/sysconfig/HOSTNAME &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>vexpress-a9</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line></span><br><span class=line><span class=comment># 创建其他文件夹</span></span><br><span class=line><span class=built_in>mkdir</span> mnt proc root sys tmp var</span><br><span class=line></span><br><span class=line><span class=built_in>cd</span> ..</span><br></pre></table></figure><p>接下来需要制作根文件系统，有两种方式<h3 id=方式一模拟sd卡方式启动>方式一：模拟SD卡方式启动</h3><p>这种方式非常简单，但不适合需要经常修改文件系统中的文件的场景<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># 创建SD卡根文件系统镜像</span></span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mkdir</span> /mnt/rootfs</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>chmod</span> 777 /mnt/rootfs</span><br><span class=line><span class=built_in>dd</span> <span class=keyword>if</span>=/dev/zero of=rootfs-arm32.ext3 bs=1M count=64</span><br><span class=line>mkfs.ext3 rootfs-arm32.ext3</span><br><span class=line><span class=built_in>sudo</span> mount -t ext3 rootfs-arm32.ext3 /mnt/rootfs -o loop</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>cp</span> -rf rootfs-arm32/* /mnt/rootfs/</span><br><span class=line><span class=built_in>sudo</span> umount /mnt/rootfs/</span><br><span class=line></span><br><span class=line><span class=comment># 启动模拟器</span></span><br><span class=line>qemu-system-arm -M vexpress-a9 \</span><br><span class=line>        -m 512M \</span><br><span class=line>        -kernel linux-4.14.334/arch/arm/boot/zImage \</span><br><span class=line>        -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class=line>        -nographic \</span><br><span class=line>        -append <span class=string>"root=/dev/mmcblk0 rw console=ttyAMA0"</span> \</span><br><span class=line>	    -sd rootfs-arm32.ext3</span><br></pre></table></figure><h3 id=方式二通过nfs挂载根文件系统>方式二：通过NFS挂载根文件系统</h3><p>首先，宿主机需要安装配置nfs<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装依赖</span></span><br><span class=line><span class=built_in>sudo</span> apt-get install -y nfs-kernel-server</span><br><span class=line></span><br><span class=line><span class=comment># 配置nfs</span></span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>mkdir</span> -p /sync/rootfs</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>chmod</span> 777 -R /home/johnny/project/ldd4/rootfs-arm32</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>cat</span> >>/etc/exports &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>/home/johnny/project/ldd4/rootfs-arm32 *(rw,sync,no_root_squash,no_subtree_check)</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line><span class=comment># 为解决Linux内核与NFS服务器的兼容问题</span></span><br><span class=line><span class=comment># 设置Ubuntu20.04的NFS，使之兼容NFS-V2和NFS-V3并增加调试功能。</span></span><br><span class=line><span class=built_in>sudo</span> sed -i <span class=string>'s/\(^RPCSVCGSSDOPTS="\).*/\1--nfs-version 2,3,4 --debug --syslog"/g'</span> /etc/default/nfs-kernel-server</span><br><span class=line></span><br><span class=line><span class=comment># 重启nfs服务</span></span><br><span class=line><span class=built_in>sudo</span> systemctl restart rpcbind</span><br><span class=line><span class=built_in>sudo</span> systemctl restart nfs-kernel-server</span><br></pre></table></figure><p>配置主机网络<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装依赖</span></span><br><span class=line><span class=built_in>sudo</span> apt-get install -y uml-utilities bridge-utils</span><br><span class=line></span><br><span class=line><span class=comment># 配置网桥</span></span><br><span class=line><span class=built_in>cat</span> > /etc/network/interfaces &lt;&lt;<span class=string>EOF</span></span><br><span class=line><span class=string>auto lo</span></span><br><span class=line><span class=string>iface lo inet loopback</span></span><br><span class=line><span class=string> </span></span><br><span class=line><span class=string>auto eth0</span></span><br><span class=line><span class=string> </span></span><br><span class=line><span class=string>auto br0</span></span><br><span class=line><span class=string>iface br0 inet dhcp</span></span><br><span class=line><span class=string>bridge_ports eth0</span></span><br><span class=line><span class=string>EOF</span></span><br><span class=line></span><br><span class=line><span class=comment># 创建tap0网卡，用于连接qemu虚拟开发板</span></span><br><span class=line><span class=built_in>sudo</span> tunctl -u root -t tap0</span><br><span class=line><span class=built_in>sudo</span> ifconfig tap0 172.16.16.10 promisc up</span><br></pre></table></figure><p>启动模拟器<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> qemu-system-arm \</span><br><span class=line>        -M vexpress-a9 \</span><br><span class=line>        -m 512M \</span><br><span class=line>        -kernel linux-4.14.334/arch/arm/boot/zImage \</span><br><span class=line>        -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class=line>	    -net tap,ifname=tap0,script=no,downscript=no,<span class=built_in>id</span>=net0 \</span><br><span class=line>	    -net nic,macaddr=00:16:3e:00:00:01 \ </span><br><span class=line>        -nographic \</span><br><span class=line>        -append <span class=string>"root=/dev/nfs rw nfsroot=172.16.16.10:/home/johnny/project/ldd4/rootfs-arm32,proto=tcp,nfsvers=3,nolock init=/linuxrc console=ttyAMA0 ip=172.16.16.20"</span></span><br></pre></table></figure><h1 id=ask-qemu>100ask-qemu</h1><p>目前只支持ubuntu 16.04和18.04，需要拥有桌面环境。<p>已经支持模拟网卡、LCD显示、LED灯、按键、AT24CXX I2C存储芯片的功能<p>具体参考<a href=http://wiki.100ask.org/Qemu rel=noopener target=_blank>百问网嵌入式Linux</a><h1 id=linux驱动开发>Linux驱动开发</h1><p>与通用主机的差异是使用的内核与交叉编译工具不一样，详见Makefile文件<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(KERNELRELEASE)</span>,)</span><br><span class=line> </span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(ARCH)</span>,arm)</span><br><span class=line>KERNELDIR ?= /home/johnny/project/ldd4/linux-4.14.334</span><br><span class=line>OBJECTDIR ?= /home/johnny/project/ldd4/objects/vexpress-v2p-ca9</span><br><span class=line>ROOTFS ?= /home/johnny/project/ldd4/rootfs-arm32</span><br><span class=line>CROSS_COMPILE ?= arm-linux-gnueabi-</span><br><span class=line><span class=keyword>else</span></span><br><span class=line>KERNELDIR ?= /lib/modules/<span class=variable>$(<span class=built_in>shell</span> uname -r)</span>/build</span><br><span class=line><span class=keyword>endif</span></span><br><span class=line>PWD := <span class=variable>$(<span class=built_in>shell</span> pwd)</span></span><br><span class=line> </span><br><span class=line><span class=section>modules:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules</span><br><span class=line> </span><br><span class=line><span class=section>modules_install:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules INSTALL_MOD_PATH=<span class=variable>$(ROOTFS)</span> modules_install</span><br><span class=line> </span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf  *.o  *.ko  .*.cmd  *.mod*  modules.order  Module.symvers   .tmp_versions</span><br><span class=line> </span><br><span class=line><span class=keyword>else</span></span><br><span class=line>	obj-m += globalfifo.o</span><br><span class=line> </span><br><span class=line><span class=keyword>endif</span></span><br><span class=line> </span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/ itemprop=url>Linux驱动开发笔记</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-24 09:47:35" datetime=2024-04-24T09:47:35+08:00>2024-04-24</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> ， <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/Driver/ itemprop=url rel=index><span itemprop=name>Driver</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>9.5k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>35 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=环境搭建>环境搭建</h1><p>Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令<code>uname -r</code>。<p>对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交叉编译工具变量<code>CROSS_COMPILE</code>为指定的工具。<p>对于通用内核来说，可以使用包管理工具直接下载内核，例如在Ubuntu系统中使用命令<code>sudo apt-get install -y linux-headers-$(uname -r)</code>。默认内核安装路径在<code>/lib/modules/$(uname -r)</code>。编译驱动时，需要将内核路径指定到<code>/lib/modules/$(uname -r)/build</code>。对应的头文件在路径<code>/usr/src/linux-headers-$(uname -r)/include</code>中。<p>对于wsl来说，与通用内核类似，只是内核需要单独从<a href=https://github.com/microsoft/WSL2-Linux-Kernel/releases rel=noopener target=_blank>微软wsl2内核仓库</a>下载。然后手动进行编译安装。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装编译wsl特供内核依赖</span></span><br><span class=line><span class=built_in>sudo</span> apt-get install -y libelf-dev build-essential pkg-config bison build-essential flex libssl-dev libelf-dev bc dwarves</span><br><span class=line></span><br><span class=line><span class=comment># 解压进入到目录</span></span><br><span class=line>tar -xvf WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1.tar.gz</span><br><span class=line><span class=built_in>cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1</span><br><span class=line><span class=built_in>cp</span> Microsoft/config-wsl .config</span><br><span class=line></span><br><span class=line><span class=comment># 编译安装</span></span><br><span class=line><span class=built_in>sudo</span> make scripts</span><br><span class=line><span class=built_in>sudo</span> make modules -j$(<span class=built_in>nproc</span>)</span><br><span class=line><span class=built_in>sudo</span> make modules_install</span><br><span class=line></span><br><span class=line><span class=built_in>cd</span> ..</span><br></pre></table></figure><h1 id=驱动简介>驱动简介</h1><p>Linux驱动可以使用多种方式加载到系统中。<h2 id=基本框架>基本框架</h2><p><code>hello.c</code>文件的内容如下<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/module.h></span> <span class=comment>// 包含内核编程最常用的函数声明，如printk</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/kernel.h></span> <span class=comment>// 包含模块编程相关的宏定义，如：MODULE_LICENSE</span></span></span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>init初始化函数在模块被插入进内核时调用，主要作用为驱动功能做好预备工作被称为模块的入口函数</span></span><br><span class=line><span class=comment>  </span></span><br><span class=line><span class=comment>__init的作用 : </span></span><br><span class=line><span class=comment>  1. 一个宏，展开后为：__attribute__ ((__section__ (".init.text"))) 实际是gcc的一个特殊链接标记</span></span><br><span class=line><span class=comment>  2. 指示链接器将该函数放置在 .init.text区段</span></span><br><span class=line><span class=comment>  3. 在模块插入时方便内核从ko文件指定位置读取入口函数的指令到特定内存位置</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=type>int</span> __init <span class="title function_">hello_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>	<span class=comment>// 具体初始化逻辑</span></span><br><span class=line>    printk(<span class=string>"hello module init.\n"</span>);</span><br><span class=line>	<span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>module_init 宏</span></span><br><span class=line><span class=comment>1. 用法：module_init(模块入口函数名) </span></span><br><span class=line><span class=comment>2. 动态加载模块，对应函数被调用</span></span><br><span class=line><span class=comment>3. 静态加载模块，内核启动过程中对应函数被调用</span></span><br><span class=line><span class=comment>4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.initcall段），方便系统初始化统一调用。</span></span><br><span class=line><span class=comment>5. 对于动态加载的模块，由于内核模块的默认入口函数名是init_module,用该宏可以给对应模块入口函数起别名</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>module_init(hello_init);</span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>exit退出函数在模块从内核中被移除时调用，主要作用做些init函数的反操作被称为模块的出口函数</span></span><br><span class=line><span class=comment>  </span></span><br><span class=line><span class=comment>__exit的作用：</span></span><br><span class=line><span class=comment>  1. 一个宏，展开后为：__attribute__ ((__section__ (".exit.text"))) 实际也是gcc的一个特殊链接标记</span></span><br><span class=line><span class=comment>  2. 指示链接器将该函数放置在 .exit.text区段</span></span><br><span class=line><span class=comment>  3. 在模块插入时方便内核从ko文件指定位置读取出口函数的指令到另一个特定内存位置</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=type>void</span> __exit <span class="title function_">hello_exit</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>	<span class=comment>// 具体反初始化逻辑</span></span><br><span class=line>    printk(<span class=string>"hello module exit.\n"</span>);</span><br><span class=line>}</span><br><span class=line> </span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>module_exit宏</span></span><br><span class=line><span class=comment>  1. 用法：module_exit(模块出口函数名)</span></span><br><span class=line><span class=comment>  2. 动态加载的模块在卸载时，对应函数被调用</span></span><br><span class=line><span class=comment>  3. 静态加载的模块可以认为在系统退出时，对应函数被调用，实际上对应函数被忽略</span></span><br><span class=line><span class=comment>  4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.exitcall段），方便系统必要时统一调用，实际上该宏在静态加载时没有意义，因为静态编译的驱动无法卸载。</span></span><br><span class=line><span class=comment>  5. 对于动态加载的模块，由于内核模块的默认出口函数名是cleanup_module,用该宏可以给对应模块出口函数起别名</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>module_exit(hello_exit);</span><br><span class=line></span><br><span class=line><span class=comment>/*</span></span><br><span class=line><span class=comment>MODULE_LICENSE(字符串常量);</span></span><br><span class=line><span class=comment>字符串常量内容为源码的许可证协议 可以是"GPL" "GPL v2"  "GPL and additional rights"  "Dual BSD/GPL"  "Dual MIT/GPL" "Dual MPL/GPL"等, "GPL"最常用</span></span><br><span class=line><span class=comment>其本质也是一个宏，宏体也是一个特殊链接标记，指示链接器在ko文件指定位置说明本模块源码遵循的许可证</span></span><br><span class=line><span class=comment>在模块插入到内核时，内核会检查新模块的许可证是不是也遵循GPL协议，如果发现不遵循GPL，则在插入模块时打印抱怨信息：</span></span><br><span class=line><span class=comment>	myhello：module license 'unspecified' taints kernel</span></span><br><span class=line><span class=comment>	Disabling lock debugging due to kernel taint</span></span><br><span class=line><span class=comment>也会导致新模块没法使用一些内核其它模块提供的高级功能</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line>MODULE_LICENSE(<span class=string>"GPL"</span>);</span><br><span class=line></span><br></pre></table></figure><p><code>Makefile</code>文件的内容如下<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(KERNELRELEASE)</span>,)</span><br><span class=line> </span><br><span class=line><span class=keyword>ifeq</span> (<span class=variable>$(ARCH)</span>,arm)</span><br><span class=line>KERNELDIR ?= /root/ldd4/linux-4.14.334</span><br><span class=line><span class=comment># OBJECTDIR ?= /root/ldd4/objects/vexpress-v2p-ca9</span></span><br><span class=line>ROOTFS ?= /root/ldd4/rootfs-arm32</span><br><span class=line>CROSS_COMPILE ?= arm-linux-gnueabi-</span><br><span class=line><span class=keyword>else</span></span><br><span class=line>KERNELDIR ?= /lib/modules/<span class=variable>$(<span class=built_in>shell</span> uname -r)</span>/build</span><br><span class=line><span class=keyword>endif</span></span><br><span class=line>PWD := <span class=variable>$(<span class=built_in>shell</span> pwd)</span></span><br><span class=line> </span><br><span class=line><span class=section>modules:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules</span><br><span class=line> </span><br><span class=line><span class=section>modules_install:</span></span><br><span class=line>	<span class=variable>$(MAKE)</span> -C <span class=variable>$(KERNELDIR)</span> M=<span class=variable>$(PWD)</span> CROSS_COMPILE=<span class=variable>$(CROSS_COMPILE)</span> O=<span class=variable>$(OBJECTDIR)</span> modules INSTALL_MOD_PATH=<span class=variable>$(ROOTFS)</span> modules_install</span><br><span class=line> </span><br><span class=line><span class=section>clean:</span></span><br><span class=line>	rm -rf  *.o  *.ko  .*.cmd  *.mod*  modules.order  Module.symvers   .tmp_versions</span><br><span class=line> </span><br><span class=line><span class=keyword>else</span></span><br><span class=line>	obj-m += hello.o</span><br><span class=line></span><br><span class=line><span class=keyword>endif</span></span><br><span class=line></span><br></pre></table></figure><p>驱动编译成功后，使用附录中的常用命令进行测试。<h1 id=字符设备驱动>字符设备驱动</h1><p>Linux字符设备会涉及到关键数据结构<code>cdev</code>及<code>file_operations</code>结构体的操作方法。<p><code>cdev</code>定义在文件<code>include/linux/cdev.h</code>中，主要描述设备驱动基本信息。<p><code>file_operations</code>定义在文件<code>include/linux/fs.h</code>中，主要描述设备驱动提供的基本接口函数，比如open、read、write、llseek、unlocked_ioctl等基本操作函数。<h2 id=关键函数>关键函数</h2><p>初始化基本流程为：注册设备号->申请驱动内存->初始化与新增字符设备描述符<p>注销基本流程为：删除字符设备描述符->释放驱动内存->删除设备号<h3 id=设备号>设备号</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> u32 <span class=type>dev_t</span>;</span><br><span class=line><span class=comment>// 生成设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MKDEV(ma,minor) (((ma) &lt;&lt; 20) | (mi))</span></span><br><span class=line><span class=comment>// 获取主设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS))</span></span><br><span class=line><span class=comment>// 获取次设备号</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MINOR(dev)	((unsigned int) ((dev) & MINORMASK))</span></span><br></pre></table></figure><p><code>dev_t</code>为设备编号类型，为32位无符号整数。<ul><li>ma为主设备号major<li>mi为次设备号minor</ul><p>在创建设备节点时，通过设备号来绑定驱动模块。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 静态注册设备号</span></span><br><span class=line><span class=type>int</span> <span class="title function_">register_chrdev_region</span><span class=params>(<span class=type>dev_t</span> dev, <span class=type>unsigned</span> count, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 动态申请设备号</span></span><br><span class=line><span class=type>int</span> <span class="title function_">alloc_chrdev_region</span><span class=params>(<span class=type>dev_t</span> *dev, <span class=type>unsigned</span> minor, <span class=type>unsigned</span> count, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 注销设备号</span></span><br><span class=line><span class=type>void</span> <span class="title function_">unregister_chrdev_region</span><span class=params>(<span class=type>dev_t</span> dev, <span class=type>unsigned</span> count)</span>;</span><br></pre></table></figure><ul><li>dev为设备编号，动态申请时通过指针传值方式返回<li>minor为需要分配的起始次设备号<li>count为需要分配的设备数量，主设备号一样，次设备号依次累加<li>name为设备驱动名称，可以在<code>/proc/devices</code>中查看</ul><h3 id=驱动内存>驱动内存</h3><p>值得注意的是，设备驱动运行在内核空间，因此内存需要使用内核内存管理函数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请内存并置零。</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kzalloc</span><span class=params>(<span class=type>size_t</span> size, <span class=type>gfp_t</span> flags)</span>;</span><br><span class=line><span class=comment>// 内存释放</span></span><br><span class=line><span class=type>void</span> <span class="title function_">kfree</span><span class=params>(<span class=type>const</span> <span class=type>void</span> *p)</span></span><br></pre></table></figure><ul><li>size申请内存大小<li>flags内存标志位，这里使用GFP_KERNEL<li>p内存指针指向待释放的内存</ul><h3 id=字符设备>字符设备</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 初始化字符设备描述符</span></span><br><span class=line><span class=type>void</span> <span class="title function_">cdev_init</span><span class=params>(<span class=keyword>struct</span> cdev *cdev, <span class=type>const</span> <span class=keyword>struct</span> file_operations *ops)</span>;</span><br><span class=line><span class=comment>// 新增字符设备描述符</span></span><br><span class=line><span class=type>int</span> <span class="title function_">cdev_add</span><span class=params>(<span class=keyword>struct</span> cdev *cdev, <span class=type>dev_t</span> dev, <span class=type>unsigned</span> count)</span>;</span><br><span class=line><span class=comment>// 删除字符设备描述符</span></span><br><span class=line><span class=type>void</span> <span class="title function_">cdev_del</span><span class=params>(<span class=keyword>struct</span> cdev *cdev)</span>;</span><br></pre></table></figure><ul><li>cdev字符设备描述符<li>ops文件操作描述符<li>dev设备编号</ul><h3 id=其他宏>其他宏</h3><table><thead><tr class=header><th>名称<th>作用<th>必选<tbody><tr class=odd><td>module_init<td>导出设备驱动的初始化函数<td>✅<tr class=even><td>module_exit<td>导出设备驱动的退出函数<td>✅<tr class=odd><td>module_param<td>导出设备驱动参数<td>❌<tr class=even><td>MODULE_LICENSE<td>声明许可信息<td>✅<tr class=odd><td>MODULE_AUTHOR<td>声明作者信息<td>❌<tr class=even><td>MODULE_DESCRIPTION<td>声明描述信息<td>❌</table><h2 id=简单的模拟缓存设备>简单的模拟缓存设备</h2><p>支持最多创建10个设备节点，每个节点可以读取或写入数据。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br><span class=line>165</span><br><span class=line>166</span><br><span class=line>167</span><br><span class=line>168</span><br><span class=line>169</span><br><span class=line>170</span><br><span class=line>171</span><br><span class=line>172</span><br><span class=line>173</span><br><span class=line>174</span><br><span class=line>175</span><br><span class=line>176</span><br><span class=line>177</span><br><span class=line>178</span><br><span class=line>179</span><br><span class=line>180</span><br><span class=line>181</span><br><span class=line>182</span><br><span class=line>183</span><br><span class=line>184</span><br><span class=line>185</span><br><span class=line>186</span><br><span class=line>187</span><br><span class=line>188</span><br><span class=line>189</span><br><span class=line>190</span><br><span class=line>191</span><br><span class=line>192</span><br><span class=line>193</span><br><span class=line>194</span><br><span class=line>195</span><br><span class=line>196</span><br><span class=line>197</span><br><span class=line>198</span><br><span class=line>199</span><br><span class=line>200</span><br><span class=line>201</span><br><span class=line>202</span><br><span class=line>203</span><br><span class=line>204</span><br><span class=line>205</span><br><span class=line>206</span><br><span class=line>207</span><br><span class=line>208</span><br><span class=line>209</span><br><span class=line>210</span><br><span class=line>211</span><br><span class=line>212</span><br><span class=line>213</span><br><span class=line>214</span><br><span class=line>215</span><br><span class=line>216</span><br><span class=line>217</span><br><span class=line>218</span><br><span class=line>219</span><br><span class=line>220</span><br><span class=line>221</span><br><span class=line>222</span><br><span class=line>223</span><br><span class=line>224</span><br><span class=line>225</span><br><span class=line>226</span><br><span class=line>227</span><br><span class=line>228</span><br><span class=line>229</span><br><span class=line>230</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/module.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/fs.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/init.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/cdev.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/slab.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;linux/uaccess.h></span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_SIZE 0x1000</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MAJOR 230</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MINOR 0</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> DEVICE_NUM 10</span></span><br><span class=line></span><br><span class=line><span class=comment>// 为避免多个设备命令污染，Linux推荐使用_IO _IOR _IOW _IOWR来定义ioctl的命令</span></span><br><span class=line><span class=comment>// 已经定义的设备类型可以见内核文档Documentation/ioctl/ioctl-number.txt</span></span><br><span class=line><span class=comment>// 内核预定义的控制命令不会被设备驱动处理，这些定义在include/uapi/asm-generic/ioctls.h</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> GLOBALMEM_MAGIC <span class=string>'g'</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MEM_CLEAR _IO(GLOBALMEM_MAGIC, 0)</span></span><br><span class=line></span><br><span class=line><span class=type>static</span> <span class=type>int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class=line>module_param(globalmem_major, <span class=type>int</span>, S_IRUGO);</span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> <span class=title>globalmem_dev</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// 设备号</span></span><br><span class=line>    <span class=type>dev_t</span> id;</span><br><span class=line>    <span class=comment>// 字符设备</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>cdev</span> <span class=title>cd</span>;</span></span><br><span class=line>    <span class=comment>// 模拟的设备内存</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>char</span> mem[GLOBALMEM_SIZE];</span><br><span class=line>} <span class=type>globalmem_dev_t</span>;</span><br><span class=line></span><br><span class=line><span class=type>globalmem_dev_t</span> *globalmem_devp;</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的打开函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">globalmem_open</span><span class=params>(<span class=keyword>struct</span> inode *inode, <span class=keyword>struct</span> file *filp)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = container_of(inode->i_cdev, <span class=type>globalmem_dev_t</span>, cd);</span><br><span class=line>    filp->private_data = dev;</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的释放函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> <span class="title function_">globalmem_release</span><span class=params>(<span class=keyword>struct</span> inode *, <span class=keyword>struct</span> file *)</span></span><br><span class=line>{</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的I/O控制函数</span></span><br><span class=line><span class=type>static</span> <span class=type>long</span> <span class="title function_">globalmem_ioctl</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>unsigned</span> <span class=type>int</span> cmd, <span class=type>unsigned</span> <span class=type>long</span> arg)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>switch</span> (cmd)</span><br><span class=line>    {</span><br><span class=line>    <span class=keyword>case</span> MEM_CLEAR:</span><br><span class=line>        <span class=built_in>memset</span>(dev->mem, <span class=number>0</span>, GLOBALMEM_SIZE);</span><br><span class=line>        printk(KERN_INFO <span class=string>"globalmem is set to zero\n"</span>);</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>        <span class=keyword>return</span> -EINVAL;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的读操作。*ppos是要读的位置相对于内存开头的偏移，如果大于或等于GLOBALMEM_SIZE，则会返回0（EOF）</span></span><br><span class=line><span class=type>static</span> <span class=type>ssize_t</span> <span class="title function_">globalmem_read</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>char</span> __user *buf, <span class=type>size_t</span> size, <span class=type>loff_t</span> *ppos)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> p = *ppos;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> count = size;</span><br><span class=line>    <span class=type>int</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (p >= GLOBALMEM_SIZE)</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>if</span> (count > GLOBALMEM_SIZE - p)</span><br><span class=line>        count = GLOBALMEM_SIZE - p;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (copy_to_user(buf, dev->mem + p, count))</span><br><span class=line>    {</span><br><span class=line>        ret = -EFAULT;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        *ppos += count;</span><br><span class=line>        ret = count;</span><br><span class=line>        printk(KERN_INFO <span class=string>"read %u bytes(s) from %lu\n"</span>, count, p);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 驱动设备的写操作</span></span><br><span class=line><span class=type>static</span> <span class=type>ssize_t</span> <span class="title function_">globalmem_write</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>const</span> <span class=type>char</span> __user *buf, <span class=type>size_t</span> size, <span class=type>loff_t</span> *ppos)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> p = *ppos;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> count = size;</span><br><span class=line>    <span class=type>int</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>globalmem_dev_t</span> *dev = filp->private_data;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (p > GLOBALMEM_SIZE)</span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>if</span> (count > GLOBALMEM_SIZE - p)</span><br><span class=line>        count = GLOBALMEM_SIZE - p;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (copy_from_user(dev->mem + p, buf, count))</span><br><span class=line>        ret = -EFAULT;</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        *ppos += count;</span><br><span class=line>        ret = count;</span><br><span class=line>        printk(KERN_INFO <span class=string>"written %u bytes(s) from %lu\n"</span>, count, p);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的定位操作。</span></span><br><span class=line><span class=type>static</span> <span class=type>loff_t</span> <span class="title function_">globalmem_llseek_impl</span><span class=params>(<span class=keyword>struct</span> file *filp, <span class=type>loff_t</span> offset, <span class=type>int</span> orig)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>loff_t</span> ret = <span class=number>0</span>;</span><br><span class=line>    <span class=type>loff_t</span> f_pos = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>switch</span> (orig)</span><br><span class=line>    {</span><br><span class=line>    <span class=keyword>case</span> <span class=number>1</span>: <span class=comment>/* 从内存当前位置开始seek */</span></span><br><span class=line>        f_pos = filp->f_pos;</span><br><span class=line>    <span class=keyword>case</span> <span class=number>0</span>: <span class=comment>/* 从内存开头位置seek */</span></span><br><span class=line>        <span class=keyword>if</span> ((f_pos + offset) &lt; <span class=number>0</span>)</span><br><span class=line>        {</span><br><span class=line>            ret = -EINVAL;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> ((f_pos + offset) > GLOBALMEM_SIZE)</span><br><span class=line>        {</span><br><span class=line>            ret = -EINVAL;</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        filp->f_pos = f_pos;</span><br><span class=line>        ret = filp->f_pos;</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>default</span>:</span><br><span class=line>        ret = -EINVAL;</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的文件操作结构体</span></span><br><span class=line><span class=type>static</span> <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>file_operations</span> <span class=title>globalmem_fops</span> =</span> {</span><br><span class=line>    .owner = THIS_MODULE,</span><br><span class=line>    .llseek = globalmem_llseek_impl,</span><br><span class=line>    .read = globalmem_read,</span><br><span class=line>    .write = globalmem_write,</span><br><span class=line>    .unlocked_ioctl = globalmem_ioctl,</span><br><span class=line>    .open = globalmem_open,</span><br><span class=line>    .release = globalmem_release,</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=comment>// cdev的初始化和添加</span></span><br><span class=line><span class=type>static</span> <span class=type>void</span> <span class="title function_">globalmem_setup_cdev</span><span class=params>(<span class=type>globalmem_dev_t</span> *dev)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> err;</span><br><span class=line>    cdev_init(&dev->cd, &globalmem_fops);</span><br><span class=line>    dev->cd.owner = THIS_MODULE;</span><br><span class=line>    err = cdev_add(&dev->cd, dev->id, <span class=number>1</span>);</span><br><span class=line>    <span class=keyword>if</span> (err)</span><br><span class=line>        printk(KERN_NOTICE <span class=string>"Error %d adding globalmem"</span>, err);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的初始化函数</span></span><br><span class=line><span class=type>static</span> <span class=type>int</span> __init <span class="title function_">globalmem_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> ret;</span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 设备号的申请</span></span><br><span class=line>    <span class=type>dev_t</span> id = MKDEV(globalmem_major, GLOBALMEM_MINOR);</span><br><span class=line>    <span class=keyword>if</span> (globalmem_major)</span><br><span class=line>        <span class=comment>// 1. 静态申请设备号</span></span><br><span class=line>        ret = register_chrdev_region(id, DEVICE_NUM, <span class=string>"globalmemND"</span>);</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        <span class=comment>// 2. 动态申请设备号</span></span><br><span class=line>        ret = alloc_chrdev_region(&id, <span class=number>0</span>, DEVICE_NUM, <span class=string>"globalmemND"</span>);</span><br><span class=line>        globalmem_major = MAJOR(id);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (ret &lt; <span class=number>0</span>)</span><br><span class=line>        <span class=keyword>return</span> ret;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 从内核中申请一份globalmem_dev的内存并清零</span></span><br><span class=line>    globalmem_devp = kzalloc(<span class=keyword>sizeof</span>(<span class=type>globalmem_dev_t</span>) * DEVICE_NUM, GFP_KERNEL);</span><br><span class=line>    <span class=keyword>if</span> (!globalmem_devp)</span><br><span class=line>    {</span><br><span class=line>        ret = -ENOMEM;</span><br><span class=line>        <span class=keyword>goto</span> fail_malloc;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class=line>    {</span><br><span class=line>        (globalmem_devp + i)->id = MKDEV(globalmem_major, i);</span><br><span class=line>        globalmem_setup_cdev(globalmem_devp + i);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>fail_malloc:</span><br><span class=line>    unregister_chrdev_region(id, DEVICE_NUM);</span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line><span class=comment>// 导出设备驱动的初始化函数</span></span><br><span class=line>module_init(globalmem_init);</span><br><span class=line></span><br><span class=line><span class=comment>// 设备驱动的退出函数</span></span><br><span class=line><span class=type>static</span> <span class=type>void</span> __exit <span class="title function_">globalmem_exit</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class=line>        cdev_del(&(globalmem_devp + i)->cd);</span><br><span class=line>    kfree(globalmem_devp);</span><br><span class=line>    unregister_chrdev_region(globalmem_devp->id, DEVICE_NUM);</span><br><span class=line>}</span><br><span class=line><span class=comment>// 导出设备驱动的退出函数</span></span><br><span class=line>module_exit(globalmem_exit);</span><br><span class=line></span><br><span class=line><span class=comment>// 作者版权声明</span></span><br><span class=line>MODULE_AUTHOR(<span class=string>"johnny &lt;johnny@gmail.com>"</span>);</span><br><span class=line>MODULE_LICENSE(<span class=string>"GPL v2"</span>);</span><br><span class=line></span><br></pre></table></figure><h1 id=阻塞和非阻塞>阻塞和非阻塞</h1><h1 id=异步通知和异步io>异步通知和异步I/O</h1><h2 id=异步通知>异步通知</h2><p>异步通知使用Linux信号机制。<p>设备驱动中使用异步通知，主要用到一个数据结构和两个函数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 异步通知数据结构</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>fasync_struct</span>;</span></span><br><span class=line><span class=comment>// 处理标志变更</span></span><br><span class=line><span class=type>int</span> <span class="title function_">fasync_helper</span><span class=params>(<span class=type>int</span> fd, <span class=keyword>struct</span> file *filp, <span class=type>int</span> mode, <span class=keyword>struct</span> fasync_struct **fa)</span>;</span><br><span class=line><span class=comment>// 释放信号函数</span></span><br><span class=line><span class=type>void</span> <span class="title function_">kill_fasync</span><span class=params>(<span class=keyword>struct</span> fasync_struct **fa, <span class=type>int</span> sig, <span class=type>int</span> band)</span>;</span><br><span class=line></span><br></pre></table></figure><h2 id=异步io>异步I/O</h2><p>Linux内核AIO。<p>AIO无法解决系统调用问题，已经被摒弃，使用<code>io_uring</code>替代AIO机制。<a href=https://zhuanlan.zhihu.com/p/583298936 rel=noopener target=_blank>一文图解原理｜Linux I/O 神器之 io_uring</a><h1 id=中断与时钟>中断与时钟</h1><p>Linux将中断处理程序分解为两个半部：顶半部（Top Half）和底半部（Bottom Half）。<p>ARM Linux默认情况下，中断都是在CPU0上产生的，需要通过接口<code>irq_set_affinity</code>把中断irq设定到CPU i上去。<p>顶半部用于完成尽量少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态，并在清除中断标志后就进行“登记中断”的工作。<p>中断处理工作的重心就落在了底半部的头上，需用它来完成中断事件的绝大多数任务。<h2 id=关键函数-1>关键函数</h2><h3 id=顶半部>顶半部</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class="title function_">irqreturn_t</span> <span class=params>(*<span class=type>irq_handler_t</span>)</span><span class=params>(<span class=type>int</span>, <span class=type>void</span> *)</span>;</span><br><span class=line><span class=keyword>typedef</span> <span class=type>int</span> <span class=type>irqreturn_t</span>;</span><br><span class=line><span class=comment>// 申请irq</span></span><br><span class=line><span class=type>int</span> <span class="title function_">request_irq</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> irq, <span class=type>irq_handler_t</span> handler, <span class=type>unsigned</span> <span class=type>long</span> flags, <span class=type>const</span> <span class=type>char</span> *name, <span class=type>void</span> *dev)</span>;</span><br><span class=line><span class=comment>// 申请irq。区别是devm_开头的API申请的是内核“managed”的资源，一般不需要在出错处理和remove（）接口里再显式的释放。</span></span><br><span class=line><span class=type>int</span> <span class="title function_">devm_request_irq</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>unsigned</span> <span class=type>int</span> irq, <span class=type>irq_handler_t</span> handler, <span class=type>unsigned</span> <span class=type>long</span> irqflags, <span class=type>const</span> <span class=type>char</span> *devname, <span class=type>void</span> *dev_id)</span>;</span><br><span class=line><span class=comment>// 释放irq</span></span><br><span class=line><span class=type>void</span> <span class="title function_">free_irq</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> irq,<span class=type>void</span> *dev_id)</span>;</span><br><span class=line><span class=comment>// 屏蔽使能中断源</span></span><br><span class=line><span class=type>void</span> <span class="title function_">disable_irq</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">disable_irq_nosync</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">enable_irq</span><span class=params>(<span class=type>int</span> irq)</span>;</span><br></pre></table></figure><p>中断共享需要在申请时，增加IRQF_SHARED标志。<h3 id=底半部>底半部</h3><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断和线程化irq。<h2 id=内核定时器>内核定时器</h2><h3 id=定时器>定时器</h3><p>timer_list<h3 id=工作队列>工作队列</h3><h2 id=内核延时>内核延时</h2><h3 id=短延时>短延时</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// 忙等待</span></span><br><span class=line><span class=type>void</span> <span class="title function_">ndelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> nsecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">udelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> usecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">mdelay</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> msecs)</span>;</span><br><span class=line><span class=comment>// 睡眠</span></span><br><span class=line><span class=type>void</span> <span class="title function_">msleep</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> millisecs)</span>;</span><br><span class=line><span class=type>unsigned</span> <span class=type>long</span> <span class="title function_">msleep_interruptible</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> millisecs)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">ssleep</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> seconds)</span>;</span><br><span class=line><span class=comment>// 睡着延时</span></span><br><span class=line>schedule_timeout</span><br></pre></table></figure><h1 id=内存与io访问>内存与I/O访问</h1><p>x86处理器中存在I/O空间的概念，而大多数嵌入式微处理器中并不提供I/O空间。<h2 id=linux内存管理>Linux内存管理</h2><p>在Linux系统中，进程的4GB内存空间被分为两个部分——用户空间与内核空间。用户空间的地址一般分布为0<sub>3GB（即PAGE_OFFSET，在0x86中它等于0xC0000000），而3</sub>4GB为内核空间。用户进程通常只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。用户进程只能通过系统调用等方式才可以访问到内核空间。<p>内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。<p>对于x86系统而言，一般情况下，物理内存映射区最大长度为896MB。当系统物理内存大于896MB时，超过物理内存映射区的那部分内存称为高端内存。<p>内核空间最顶部FIXADDR_TOP~4GB的区域作为保留区。<p>紧接着最顶端的保留区以下的一段区域为专用页面映射区（FIXADDR_START~FIXADDR_TOP）。<p>virt_to_phys（）和phys_to_virt（）方法仅适用于DMA和常规区域，高端内存的虚拟地址与物理地址之间不存在如此简单的换算关系。<h2 id=内存存取>内存存取</h2><h3 id=用户空间动态申请>用户空间动态申请</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>malloc</span></span><br><span class=line><span class=built_in>free</span></span><br></pre></table></figure><h3 id=内核空间动态申请>内核空间动态申请</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 依赖底层__get_free_pages（）来实现，分配标志的前缀GFP正好是这个底层函数的缩写。</span></span><br><span class=line><span class=comment>// 最常用的分配标志是GFP_KERNEL，其含义是在内核空间的进程中申请内存。</span></span><br><span class=line><span class=comment>// 使用GFP_KERNEL标志申请内存时，若暂时不能满足，则进程会睡眠等待页，即会引起阻塞，因此不能在中断上下文或持有自旋锁的时候使用GFP_KERNE申请内存。</span></span><br><span class=line><span class=comment>// 使用GFP_ATOMIC标志申请内存时，若不存在空闲页，则不等待，直接返回。</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kmalloc</span><span class=params>(<span class=type>size_t</span> size, <span class=type>int</span> flags)</span>;</span><br><span class=line>kfree</span><br><span class=line><span class=comment>// 一般只为存在于软件中（没有对应的硬件意义）的较大的顺序缓冲区分配内存</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">vmalloc</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">vfree</span><span class=params>(<span class=type>void</span> * addr)</span>;</span><br></pre></table></figure><p>slab缓存<p>完全使用页为单元申请和释放内存容易导致浪费（如果要申请少量字节，也需要用1页）；另一方面，在操作系统的运作过程中，经常会涉及大量对象的重复生成、使用和释放内存问题。如果我们能够用合适的方法使得对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，就可以大大提高效率。slab算法就是针对上述特点设计的。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建slab缓存</span></span><br><span class=line><span class=keyword>struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class=params>(<span class=type>const</span> <span class=type>char</span> *name, <span class=type>size_t</span> size,<span class=type>size_t</span> align, <span class=type>unsigned</span> <span class=type>long</span> flags,<span class=type>void</span> (*ctor)(<span class=type>void</span>*, <span class=keyword>struct</span> kmem_cache *, <span class=type>unsigned</span> <span class=type>long</span>),<span class=type>void</span> (*dtor)(<span class=type>void</span>*, <span class=keyword>struct</span> kmem_cache *, <span class=type>unsigned</span> <span class=type>long</span>))</span>;</span><br><span class=line><span class=comment>// 分配和释放slab缓存</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">kmem_cache_alloc</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep, <span class=type>gfp_t</span> flags)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">kmem_cache_free</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep, <span class=type>void</span> *objp)</span>;</span><br><span class=line><span class=comment>// 回收slab缓存</span></span><br><span class=line><span class=type>int</span> <span class="title function_">kmem_cache_destroy</span><span class=params>(<span class=keyword>struct</span> kmem_cache *cachep)</span>;</span><br></pre></table></figure><p>内存池<p>内存池技术也是一种非常经典的用于分配大量小对象的后备缓存技术。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建内存池</span></span><br><span class=line><span class=type>mempool_t</span> *<span class="title function_">mempool_create</span><span class=params>(<span class=type>int</span> min_nr, <span class=type>mempool_alloc_t</span> *alloc_fn,<span class=type>mempool_free_t</span> *free_fn, <span class=type>void</span> *pool_data)</span>;</span><br><span class=line><span class=keyword>typedef</span> <span class=type>void</span> *(<span class=type>mempool_alloc_t</span>)(<span class=type>int</span> gfp_mask, <span class=type>void</span> *pool_data); <span class=comment>// 标准对象分配的函数指针</span></span><br><span class=line><span class=keyword>typedef</span> <span class="title function_">void</span> <span class=params>(<span class=type>mempool_free_t</span>)</span><span class=params>(<span class=type>void</span> *element, <span class=type>void</span> *pool_data)</span>; <span class=comment>// 标准对象回收的函数指针</span></span><br><span class=line><span class=comment>// 内存池中分配和回收对象</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">mempool_alloc</span><span class=params>(<span class=type>mempool_t</span> *pool, <span class=type>int</span> gfp_mask)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">mempool_free</span><span class=params>(<span class=type>void</span> *element, <span class=type>mempool_t</span> *pool)</span>;</span><br><span class=line><span class=comment>// 回收内存池</span></span><br><span class=line><span class=type>void</span> <span class="title function_">mempool_destroy</span><span class=params>(<span class=type>mempool_t</span> *pool)</span>;</span><br></pre></table></figure><h2 id=io端口和io内存>I/O端口和I/O内存</h2><p>当位于I/O空间时，通常被称为I/O端口；当位于内存空间时，对应的内存空间被称为I/O内存。<h3 id=io端口访问>I/O端口访问</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// 读写字节端口（8位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inb</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outb</span><span class=params>(<span class=type>unsigned</span> <span class=type>char</span> byte, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写字端口（16位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inw</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outw</span><span class=params>(<span class=type>unsigned</span> <span class=type>short</span> word, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写长字端口（32位宽）</span></span><br><span class=line><span class=type>unsigned</span> <span class="title function_">inl</span><span class=params>(<span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outl</span><span class=params>(<span class=type>unsigned</span> longword, <span class=type>unsigned</span> port)</span>;</span><br><span class=line><span class=comment>// 读写一串字节</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insb</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsb</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=comment>// 读写一串字</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insw</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsw</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=comment>// 读写一串长字</span></span><br><span class=line><span class=type>void</span> <span class="title function_">insl</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">outsl</span><span class=params>(<span class=type>unsigned</span> port, <span class=type>void</span> *addr, <span class=type>unsigned</span> <span class=type>long</span> count)</span>;</span><br></pre></table></figure><h3 id=io内存访问>I/O内存访问</h3><p>在内核中访问I/O内存（通常是芯片内部的各个I2C、SPI、USB等控制器的寄存器或者外部内存总线上的设备）之前，需首先使用ioremap（）函数将设备所处的物理地址映射到虚拟地址上。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 返回一个特殊的虚拟地址，该地址可用来存取特定的物理地址范围，这个虚拟地址位于vmalloc映射区域。</span></span><br><span class=line><span class=comment>// 通过devm_ioremap进行的映射通常不需要在驱动退出和出错处理的时候进行iounmap</span></span><br><span class=line><span class=type>void</span> *<span class="title function_">ioremap</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> offset, <span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=type>void</span> __iomem *<span class="title function_">devm_ioremap</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>resource_size_t</span> offset,<span class=type>unsigned</span> <span class=type>long</span> size)</span>;</span><br><span class=line><span class=comment>// 释放ioremap映射的地址</span></span><br><span class=line><span class=type>void</span> <span class="title function_">iounmap</span><span class=params>(<span class=type>void</span> * addr)</span>;</span><br></pre></table></figure><p>是Linux内核推荐用一组标准的API来完成设备内存映射的虚拟地址的读写。<p>没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是前者包含一个内存屏障。<p>以下分别是读写8bit、16bit、32bit的寄存器的版本。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 读寄存器</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readb(c) ({ u8 __v = readb_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readw(c) ({ u16__v = readw_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> readl(c) ({ u32 __v = readl_relaxed(c); __iormb(); __v; })</span></span><br><span class=line><span class=comment>// 写寄存器</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writeb(v,c) ({ __iowmb(); writeb_relaxed(v,c); })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writew(v,c) ({ __iowmb(); writew_relaxed(v,c); })</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> writel(v,c) ({ __iowmb(); writel_relaxed(v,c); })</span></span><br></pre></table></figure><h3 id=申请释放io端口和io内存>申请释放I/O端口和I/O内存</h3><p>Linux内核提供了一组函数以申请和释放I/O端口，表明该驱动要访问这片区域。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请I/O端口</span></span><br><span class=line><span class=comment>// 变体devm_request_region</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">request_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> first, <span class=type>unsigned</span> <span class=type>long</span> n, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 归还I/O端口</span></span><br><span class=line><span class=type>void</span> <span class="title function_">release_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> n)</span>;</span><br></pre></table></figure><p>Linux内核也提供了一组函数以申请和释放I/O内存的范围。此处的“申请”表明该驱动要访问这片区域，它不会做任何内存映射的动作，更多的是类似于“reservation”的概念。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请I/O内存</span></span><br><span class=line><span class=comment>// 变体devm_request_mem_region</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">request_mem_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> len, <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 归还I/O内存</span></span><br><span class=line><span class=type>void</span> <span class="title function_">release_mem_region</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> start, <span class=type>unsigned</span> <span class=type>long</span> len)</span>;</span><br></pre></table></figure><h3 id=io端口和io内存访问流程>I/O端口和I/O内存访问流程</h3><p>I/O端口访问的一种途径是直接使用I/O端口操作函数：在设备打开或驱动模块被加载时申请I/O端口区域，之后使用inb（）、outb（）等进行端口访问，最后，在设备关闭或驱动被卸载时释放I/O端口范围。<p>I/O内存的访问步骤，首先是调用request_mem_region（）申请资源，接着将寄存器地址通过ioremap（）映射到内核空间虚拟地址，之后就可以通过Linux设备访问编程接口访问这些设备的寄存器了。访问完成后，应对ioremap（）申请的虚拟地址进行释放，并释放release_mem_region（）申请的I/O内存资源。<h3 id=设备地址映射到用户空间>设备地址映射到用户空间</h3><p>一般情况下，用户空间是不可能也不应该直接访问设备的，但是，设备驱动程序中可实现mmap（）函数，这个函数可使得用户空间能直接访问设备的物理地址。<p>mmap（）必须以PAGE_SIZE为单位进行映射。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 驱动中mmap原型</span></span><br><span class=line><span class=type>int</span>(*mmap)(<span class=keyword>struct</span> file *, <span class=keyword>struct</span> vm_area_struct*);</span><br></pre></table></figure><p><code>vm_operations_struct</code>结构体的实体会在<code>file_operations</code>的mmap（）成员函数里被赋值给相应的<code>vma->vm_ops</code>。一般open（）函数也通常在mmap（）里调用，close（）函数会在用户调用munmap（）的时候被调用到。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建页表项</span></span><br><span class=line><span class=type>int</span> <span class="title function_">remap_pfn_range</span><span class=params>(<span class=keyword>struct</span> vm_area_struct *vma, <span class=type>unsigned</span> <span class=type>long</span> addr,<span class=type>unsigned</span> <span class=type>long</span> pfn, <span class=type>unsigned</span> <span class=type>long</span> size, <span class=type>pgprot_t</span> prot)</span>;</span><br></pre></table></figure><p>I/O内存被映射时需要是nocache的，这时候，我们应该对vma->vm_page_prot设置nocache标志之后再映射。<p>当访问的页不在内存里，即发生缺页异常时，fault（）会被内核自动调用，而fault（）的具体行为可以自定义。<h2 id=io内存静态映射>I/O内存静态映射</h2><p>在将Linux移植到目标电路板的过程中，有得会建立外设I/O内存物理地址到虚拟地址的静态映射，这个映射通过在与电路板对应的map_desc结构体数组中添加新的成员来完成。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>map_desc</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> virtual; <span class=comment>/* 虚拟地址 */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> pfn;     <span class=comment>/* __phys_to_pfn(phy_addr) */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> length;  <span class=comment>/* 大小 */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> type;     <span class=comment>/* 类型 */</span></span><br><span class=line>};</span><br><span class=line><span class=comment>// 然后通过函数iotable_init(struct map_desc&, size_t)建立映射。</span></span><br></pre></table></figure><p>驱动工程师可以对非常规内存区域的I/O内存（外设控制器寄存器、MCU内部集成的外设控制器寄存器等）依照电路板的资源使用情况添加到map_desc数组中，但是目前该方法已经不值得推荐。<h2 id=dma>DMA</h2><p>DMA是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。<p>DMA方式的数据传输由DMA控制器（DMAC）控制，在传输期间，CPU可以并发地执行其他任务。当DMA结束后，DMAC通过中断通知CPU数据传输已经结束，然后由CPU执行相应的中断服务程序进行后处理。<h3 id=dma与cache一致性>DMA与Cache一致性</h3><p>如果DMA的目的地址与Cache所缓存的内存地址访问有重叠，经过DMA操作，与Cache缓存对应的内存中的数据已经被修改，而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据。这样就会发生Cache与内存之间数据“不一致性”的错误。<p>Cache的不一致性问题并不是只发生在DMA的情况下，实际上，它还存在于Cache使能和关闭的时刻。<h3 id=linux下的dma编程>Linux下的DMA编程</h3><p>申请DMA缓冲区时应使用GFP_DMA标志，这样能保证获得的内存位于DMA区域中，并具备DMA能力。<p>在内核中定义了__get_free_pages（）针对DMA的“快捷方式”__get_dma_pages（），它在申请标志中添加了GFP_DMA。<p>如果不想使用log2size（即order）为参数申请DMA内存，则可以使用另一个函数dma_mem_alloc（）。<p>内核提供了如下函数以进行简单的虚拟地址/总线地址转换<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>unsigned</span> <span class=type>long</span> <span class="title function_">virt_to_bus</span><span class=params>(<span class=keyword>volatile</span> <span class=type>void</span> *address)</span>;</span><br><span class=line><span class=type>void</span> *<span class="title function_">bus_to_virt</span><span class=params>(<span class=type>unsigned</span> <span class=type>long</span> address)</span>;</span><br></pre></table></figure><p>在使用IOMMU或反弹缓冲区的情况下，上述函数一般不会正常工作。而且，这两个函数并不建议使用。<p>设备并不一定能在所有的内存地址上执行DMA操作，在这种情况下应该通过下列函数执行DMA地址掩码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">dma_set_mask</span><span class=params>(<span class=keyword>struct</span> device *dev, u64 mask)</span>;</span><br></pre></table></figure><p>内核中提供了如下函数以分配一个DMA一致性的内存区域<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请Cache一致的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">dma_alloc_coherent</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span> *handle,<span class=type>gfp_t</span> gfp)</span>;</span><br><span class=line><span class=comment>// 释放Cache一致的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_free_coherent</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>void</span> *cpu_addr,<span class=type>dma_addr_t</span> handle)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 申请写合并的DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">dma_alloc_writecombine</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span>*handle, <span class=type>gfp_t</span> gfp)</span>;</span><br><span class=line><span class=meta>#<span class=keyword>define</span> dma_free_writecombine(dev,size,cpu_addr,handle) \</span></span><br><span class=line><span class=meta>    dma_free_coherent(dev,size,cpu_addr,handle)</span></span><br><span class=line></span><br><span class=line><span class=comment>// PCI设备申请DMA缓冲区</span></span><br><span class=line><span class=type>void</span> * <span class="title function_">pci_alloc_consistent</span><span class=params>(<span class=keyword>struct</span> pci_dev *pdev, <span class=type>size_t</span> size, <span class=type>dma_addr_t</span> *dma_addrp)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">pci_free_consistent</span><span class=params>(<span class=keyword>struct</span> pci_dev *pdev, <span class=type>size_t</span> size, <span class=type>void</span> *cpu_addr,<span class=type>dma_addr_t</span> dma_addr)</span>;</span><br></pre></table></figure><p>缓冲区来自内核的较上层（如网卡驱动中的网络报文、块设备驱动中要写入设备的数据等），上层很可能用普通的kmalloc（）、__get_free_pages（）等方法申请，这时候就要使用流式DMA映射。<p>对于单个已经分配的缓冲区而言，使用dma_map_single（）可实现流式DMA映射<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>// DMA映射。第4个参数为DMA的方向，可能的值包括DMA_TO_DEVICE、DMA_FROM_DEVICE、DMA_BIDIRECTIONAL和DMA_NONE</span></span><br><span class=line><span class=type>dma_addr_t</span> <span class="title function_">dma_map_single</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>void</span> *buffer, <span class=type>size_t</span> size,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// DMA反映射</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_unmap_single</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_addr_t</span> dma_addr, <span class=type>size_t</span> size,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 获得DMA缓冲区的拥有权</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_single_for_cpu</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_handle_t</span> bus_addr,<span class=type>size_t</span> size, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 将其所有权返还给设备</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_single_for_device</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>dma_handle_t</span> bus_addr,<span class=type>size_t</span> size, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 映射SG</span></span><br><span class=line><span class=type>int</span> <span class="title function_">dma_map_sg</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg, <span class=type>int</span> nents,<span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 去除映射SG</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_unmap_sg</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *<span class=built_in>list</span>,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 返回scatterlist对应的缓冲区的总线地址和缓冲区的长度</span></span><br><span class=line><span class=type>dma_addr_t</span> <span class="title function_">sg_dma_address</span><span class=params>(<span class=keyword>struct</span> scatterlist *sg)</span>;</span><br><span class=line><span class=type>unsigned</span> <span class=type>int</span> <span class="title function_">sg_dma_len</span><span class=params>(<span class=keyword>struct</span> scatterlist *sg)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 获得DMA缓冲区的拥有权</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_sg_for_cpu</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br><span class=line><span class=comment>// 将其所有权返还给设备</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_sync_sg_for_device</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=keyword>struct</span> scatterlist *sg,<span class=type>int</span> nents, <span class=keyword>enum</span> dma_data_direction direction)</span>;</span><br></pre></table></figure><p>Linux内核目前推荐使用dmaengine的驱动架构来编写DMA控制器的驱动，同时外设的驱动使用标准的dmaengine API进行DMA的准备、发起和完成时的回调工作。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment>// 申请DMA通道</span></span><br><span class=line><span class=keyword>struct</span> dma_chan *<span class="title function_">dma_request_slave_channel</span><span class=params>(<span class=keyword>struct</span> device *dev, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>dma_chan</span> *__<span class=title>dma_request_channel</span>(<span class=title>const</span> <span class=title>dma_cap_mask_t</span> *<span class=title>mask</span>,<span class=title>dma_filter_fn</span> <span class=title>fn</span>, <span class=title>void</span> *<span class=title>fn_param</span>);</span></span><br><span class=line><span class=comment>// 释放DMA通道</span></span><br><span class=line><span class=type>void</span> <span class="title function_">dma_release_channel</span><span class=params>(<span class=keyword>struct</span> dma_chan *chan)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// DMA完成回调函数原型：void (dma_fini_callback)(void*)</span></span><br><span class=line></span><br><span class=line><span class=comment>// 申请DMA描述符，然后填充callback和callback_param参数</span></span><br><span class=line>dmaengine_prep_slave_single</span><br><span class=line><span class=comment>// 把描述符插入队列</span></span><br><span class=line>dmaengine_submit</span><br><span class=line><span class=comment>// 发起DMA动作</span></span><br><span class=line>dma_async_issue_pending</span><br></pre></table></figure><h1 id=linux设备驱动的软件架构思想>Linux设备驱动的软件架构思想</h1><p>让驱动以某种标准方法拿到这些平台信息呢Linux总线、设备和驱动模型实际上可以做到这一点，驱动只管驱动，设备只管设备，总线则负责匹配设备和驱动，而驱动则以标准途径拿到板级信息。<p>一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附于PCI、USB、I2C、SPI等的设备而言，这自然不是问题。在SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设等却不依附于此类总线。Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform_device，而驱动成为platform_driver。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>platform_device</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=type>int</span> id;</span><br><span class=line>    <span class=type>bool</span> id_auto;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>devicedev</span>;</span></span><br><span class=line>    u32 num_resources;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>resource</span> *<span class=title>resource</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device_id</span> *<span class=title>id_entry</span>;</span></span><br><span class=line>    <span class=type>char</span> *driver_override; <span class=comment>/* Driver name to force a match */</span></span><br><span class=line></span><br><span class=line>    <span class=comment>/* MFD cell pointer */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>mfd_cell</span> *<span class=title>mfd_cell</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>/* arch specific additions */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>pdev_archdata</span> <span class=title>archdata</span>;</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>platform_driver</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>int</span> (*probe)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>int</span> (*remove)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>void</span> (*shutdown)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=type>int</span> (*suspend)(<span class=keyword>struct</span> platform_device * <span class=type>pm_message_t</span> state);</span><br><span class=line>    <span class=type>int</span> (*resume)(<span class=keyword>struct</span> platform_device *);</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>device_driver</span> <span class=title>driver</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device_id</span> *<span class=title>id_table</span>;</span></span><br><span class=line>    <span class=type>bool</span> prevent_deferred_probe;</span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>device_driver</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bus_type</span> *<span class=title>bus</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>module</span> *<span class=title>owner</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *mod_name; <span class=comment>/* used for built-in modules */</span></span><br><span class=line></span><br><span class=line>    <span class=type>bool</span> suppress_bind_attrs; <span class=comment>/* disables bind/unbind via sysfs */</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>of_device_id</span> *<span class=title>of_match_table</span>;</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>acpi_device_id</span> *<span class=title>acpi_match_table</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>int</span> (*probe)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>int</span> (*remove)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>void</span> (*shutdown)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>int</span> (*suspend)(<span class=keyword>struct</span> device *dev, <span class=type>pm_message_t</span> state);</span><br><span class=line>    <span class=type>int</span> (*resume)(<span class=keyword>struct</span> device *dev);</span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>attribute_group</span> **<span class=title>groups</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>dev_pm_ops</span> *<span class=title>pm</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>driver_private</span> *<span class=title>p</span>;</span></span><br><span class=line>};</span><br></pre></table></figure><p>与platform_driver地位对等的i2c_driver、spi_driver、usb_driver、pci_driver中都包含了device_driver结构体实例成员。它其实描述了各种xxx_driver（xxx是总线名）在驱动意义上的一些共性。<p>资源本身由resource结构体描述<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>resource</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>resource__size_t</span> start;</span><br><span class=line>    <span class=type>resource_size_t</span> end;</span><br><span class=line>    <span class=type>const</span> <span class=type>char</span> *name;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> flags; <span class=comment>// 值可以为IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORE-SOURCE_DMA等</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>resource</span> *<span class=title>parent</span>, *<span class=title>sibling</span>, *<span class=title>child</span>;</span></span><br><span class=line>};</span><br></pre></table></figure><p>对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中通过platform_get_resource（）这样的API来获取<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 获取资源通用接口</span></span><br><span class=line><span class=keyword>struct</span> resource *<span class="title function_">platform_get_resource</span><span class=params>(<span class=keyword>struct</span> platform_device *, <span class=type>unsigned</span> <span class=type>int</span>,<span class=type>unsigned</span> <span class=type>int</span>)</span>;</span><br><span class=line><span class=comment>// 获取IRQ资源封装接口，相当于platform_get_resource(dev, IORESOURCE_IRQ, num);</span></span><br><span class=line><span class=type>int</span> <span class="title function_">platform_get_irq</span><span class=params>(<span class=keyword>struct</span> platform_device *dev, <span class=type>unsigned</span> <span class=type>int</span> num)</span>;</span><br></pre></table></figure><p>platform也提供了platform_data的支持，platform_data的形式是由每个驱动自定义的<h3 id=将globalfifo作为platform设备>将globalfifo作为platform设备</h3><p>globalfifo驱动挂接到platform总线上，这要完成两个工作：<ul><li>将globalfifo移植为platform驱动<li>在板文件中添加globalfifo这个platform设备</ul><p>移植时需要屏蔽module_init和module_exit宏定义的入口。<p>为了完成在板文件中添加globalfifo这个platform设备的工作，需要在板文件<code>arch/arm/mach-&lt;soc名>/mach-&lt;板名>.c</code>中添加相应的代码<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>static</span> <span class=class><span class=keyword>struct</span> <span class=title>platform_device</span> <span class=title>globalfifo_device</span> =</span> {</span><br><span class=line>    .name = <span class=string>"globalfifo"</span>,</span><br><span class=line>    .id = <span class=number>-1</span>,</span><br><span class=line>};</span><br></pre></table></figure><h2 id=设备驱动分层思想>设备驱动分层思想</h2><p>非常推荐使用misc类型设备驱动框架，编写字符类设备。<p>可以额外编写驱动触发设备驱动<code>xxx_probe</code>函数<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=type>static</span> <span class=type>int</span> __init <span class="title function_">globalfifodev_init</span><span class=params>(<span class=type>void</span>)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> ret;</span><br><span class=line></span><br><span class=line>    globalfifo_pdev = platform_device_alloc(<span class=string>"globalfifo"</span>, <span class=number>-1</span>);</span><br><span class=line>    <span class=keyword>if</span> (!globalfifo_pdev)</span><br><span class=line>        <span class=keyword>return</span> -ENOMEM;</span><br><span class=line></span><br><span class=line>    ret = platform_device_add(globalfifo_pdev);</span><br><span class=line>    <span class=keyword>if</span> (ret)</span><br><span class=line>    {</span><br><span class=line>        platform_device_put(globalfifo_pdev);</span><br><span class=line>        <span class=keyword>return</span> ret;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> ret;</span><br><span class=line>}</span><br><span class=line>module_init(globalfifodev_init);</span><br></pre></table></figure><h1 id=linux块设备驱动>Linux块设备驱动</h1><p>块设备是与字符设备并列的概念，这两类设备在Linux中的驱动结构有较大差异，总体而言，块设备驱动比字符设备驱动要复杂得多。缓冲、I/O调度、请求队列等都是与块设备驱动相关的概念。<h2 id=linux块设备驱动结构>Linux块设备驱动结构</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=comment>// 块设备操作描述符</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>block_device_operations</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// 打开和释放</span></span><br><span class=line>    <span class=type>int</span> (*open)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>);</span><br><span class=line>    <span class=type>void</span> (*release)(<span class=keyword>struct</span> gendisk *, <span class=type>fmode_t</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// I/O控制</span></span><br><span class=line>    <span class=type>int</span> (*ioctl)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>, <span class=type>unsigned</span>, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line>    <span class=type>int</span> (*compat_ioctl)(<span class=keyword>struct</span> block_device *, <span class=type>fmode_t</span>, <span class=type>unsigned</span>, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 介质改变，以后会被check_events取代</span></span><br><span class=line>    <span class=type>int</span> (*media_changed)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 使介质有效</span></span><br><span class=line>    <span class=type>int</span> (*revalidate_disk)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取驱动器信息</span></span><br><span class=line>    <span class=type>int</span> (*getgeo)(<span class=keyword>struct</span> block_device *, <span class=keyword>struct</span> hd_geometry *);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 模块指针，通常指向THIS_MODULE</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>module</span> *<span class=title>owner</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 其他</span></span><br><span class=line>    <span class=type>int</span> (*rw_page)(<span class=keyword>struct</span> block_device *, <span class=type>sector_t</span>, <span class=keyword>struct</span> page *, <span class=type>int</span> rw);</span><br><span class=line>    <span class=type>int</span> (*direct_access)(<span class=keyword>struct</span> block_device *, <span class=type>sector_t</span>, <span class=type>void</span> **, <span class=type>unsigned</span> <span class=type>long</span> *);</span><br><span class=line>    <span class=type>unsigned</span> <span class="title function_">int</span> <span class=params>(*check_events)</span><span class=params>(<span class=keyword>struct</span> gendisk *disk, <span class=type>unsigned</span> <span class=type>int</span> clearing)</span>;</span><br><span class=line>    <span class=type>void</span> (*unlock_native_capacity)(<span class=keyword>struct</span> gendisk *);</span><br><span class=line>    <span class=type>void</span> (*swap_slot_free_notify)(<span class=keyword>struct</span> block_device *, <span class=type>unsigned</span> <span class=type>long</span>);</span><br><span class=line>};</span><br></pre></table></figure><h3 id=gendisk>gendisk</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>// 磁盘描述符</span></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>gendisk</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=comment>// major、first_minor和minors共同表征了磁盘的主、次设备号，同一个磁盘的各个分区共享一个主设备号，而次设备号则不同</span></span><br><span class=line>    <span class=type>int</span> major;</span><br><span class=line>    <span class=type>int</span> first_minor;</span><br><span class=line>    <span class=type>int</span> minors;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 描述的块设备操作集合</span></span><br><span class=line>    <span class=type>const</span> <span class=class><span class=keyword>struct</span> <span class=title>block_device_operations</span> *<span class=title>fops</span>;</span></span><br><span class=line>    <span class=comment>// 管理这个设备的I/O请求队列的指针</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>request_queue</span> *<span class=title>queue</span>;</span></span><br><span class=line>    <span class=comment>// 指向磁盘的任何私有数据，与字符设备驱动的private_data类似</span></span><br><span class=line>    <span class=type>void</span> *private_data;</span><br><span class=line>    <span class=comment>// 表示一个分区</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>hd_struct</span> <span class=title>part0</span>;</span></span><br><span class=line>    <span class=comment>// 容纳分区表。与part0的关系：disk->part_tbl->part[0] = &disk->part0;</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>disk_part_tbl</span> __<span class=title>rcu</span> *<span class=title>part_tbl</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=type>char</span> disk_name[DISK_NAME_LEN]; <span class=comment>/* name of major driver */</span></span><br><span class=line>    <span class=type>char</span> *(*devnode)(<span class=keyword>struct</span> gendisk *gd, <span class=type>umode_t</span> *mode);</span><br><span class=line></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> events;       <span class=comment>/* supported events */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> async_events; <span class=comment>/* async events, subset of all */</span></span><br><span class=line></span><br><span class=line>    <span class=type>int</span> flags;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>device</span> *<span class=title>driverfs_dev</span>;</span> <span class=comment>// <span class=doctag>FIXME:</span> remove</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>kobject</span> *<span class=title>slave_dir</span>;</span></span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>timer_rand_state</span> *<span class=title>random</span>;</span></span><br><span class=line>    <span class=type>atomic_t</span> sync_io; <span class=comment>/* RAID */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>disk_events</span> *<span class=title>ev</span>;</span></span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>blk_integrity</span> *<span class=title>integrity</span>;</span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>    <span class=type>int</span> node_id;</span><br><span class=line>};</span><br></pre></table></figure><p>操作函数<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// 分配gendisk</span></span><br><span class=line><span class=keyword>struct</span> gendisk *<span class="title function_">alloc_disk</span><span class=params>(<span class=type>int</span> minors)</span>;</span><br><span class=line><span class=comment>// 增加gendisk</span></span><br><span class=line><span class=type>void</span> <span class="title function_">add_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br><span class=line><span class=comment>// 释放gendisk</span></span><br><span class=line><span class=type>void</span> <span class="title function_">del_gendisk</span><span class=params>(<span class=keyword>struct</span> gendisk *gp)</span>;</span><br><span class=line><span class=comment>// gendisk引用计数</span></span><br><span class=line><span class=keyword>struct</span> kobject *<span class="title function_">get_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br><span class=line><span class=type>void</span> <span class="title function_">put_disk</span><span class=params>(<span class=keyword>struct</span> gendisk *disk)</span>;</span><br></pre></table></figure><h3 id=biorequest和request_queue>bio、request和request_queue</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bvec_iter</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=type>sector_t</span> bi_sector;   <span class=comment>/* device address in 512byte sectors */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_size; <span class=comment>/* residual I/O count */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_idx; <span class=comment>/* current index into bvl_vec */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_bvec_done; <span class=comment>/* number of bytes completed in current bvec */</span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bio</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio</span> *<span class=title>bi_next</span>;</span> <span class=comment>/* request queue link */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>block_device</span> *<span class=title>bi_bdev</span>;</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> bi_flags; <span class=comment>/* status, command, etc */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>long</span> bi_rw;    <span class=comment>/* bottom bits READ/WRITE,</span></span><br><span class=line><span class=comment>                             * top bits priority</span></span><br><span class=line><span class=comment>                             */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bvec_iter</span> <span class=title>bi_iter</span>;</span></span><br><span class=line>    <span class=comment>/* Number of segments in this BIO after</span></span><br><span class=line><span class=comment>     * physical address coalescing is performed.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bi_phys_segments;</span><br><span class=line>    ...</span><br><span class=line></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span> *<span class=title>bi_io_vec</span>;</span> <span class=comment>/* the actual vec list */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_set</span> *<span class=title>bi_pool</span>;</span></span><br><span class=line>    <span class=comment>/*</span></span><br><span class=line><span class=comment>     * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class=line><span class=comment>     * double allocations for a small number of bio_vecs. This member</span></span><br><span class=line><span class=comment>     * MUST obviously be kept at the very end of the bio.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span> <span class=title>bi_inline_vecs</span>[0];</span></span><br><span class=line>};</span><br></pre></table></figure><p>与bio对应的数据每次存放的内存不一定是连续的，因此需要一个向量。向量中的每个元素实际是一个[page，offset，len]，我们一般也称它为一个片段。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> <span class=title>bio_vec</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>page</span> *<span class=title>bv_page</span>;</span></span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bv_len;</span><br><span class=line>    <span class=type>unsigned</span> <span class=type>int</span> bv_offset;</span><br><span class=line>};</span><br></pre></table></figure><p>I/O调度算法可将连续的bio合并成一个请求。请求是bio经由I/O调度进行调整后的结果，这是请求和bio的区别。<p>每个块设备或者块设备的分区都对应有自身的request_queue，从I/O调度器合并和排序出来的请求会被分发（Dispatch）到设备级的request_queue。<p>主要API<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment>// 初始化请求队列</span></span><br><span class=line><span class=type>request_queue_t</span> *<span class="title function_">blk_init_queue</span><span class=params>(request_fn_proc *rfn, <span class=type>spinlock_t</span> *lock)</span>;</span><br><span class=line><span class=comment>// 清除请求队列</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_cleanup_queue</span><span class=params>(<span class=type>request_queue_t</span> * q)</span>;</span><br><span class=line><span class=comment>// 分配请求队列</span></span><br><span class=line><span class=type>request_queue_t</span> *<span class="title function_">blk_alloc_queue</span><span class=params>(<span class=type>int</span> gfp_mask)</span>;</span><br><span class=line><span class=comment>// 对于RAMDISK这种完全随机访问的非机械设备，并不需要进行复杂的I/O调度。</span></span><br><span class=line><span class=comment>// 使用如下函数来绑定请求队列和“制造请求”函数</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_queue_make_request</span><span class=params>(<span class=type>request_queue_t</span> * q, make_request_fn * mfn)</span>;</span><br><span class=line><span class=comment>// 提取请求</span></span><br><span class=line><span class=keyword>struct</span> request * <span class="title function_">blk_peek_request</span><span class=params>(<span class=keyword>struct</span> request_queue *q)</span>;</span><br><span class=line><span class=comment>// 启动请求</span></span><br><span class=line><span class=type>void</span> <span class="title function_">blk_start_request</span><span class=params>(<span class=keyword>struct</span> request *req)</span>;</span><br><span class=line><span class=comment>// 报告完成</span></span><br><span class=line><span class=type>void</span> __blk_end_request_all(<span class=keyword>struct</span> request *rq, <span class=type>int</span> error);</span><br><span class=line><span class=type>void</span> <span class="title function_">blk_end_request_all</span><span class=params>(<span class=keyword>struct</span> request *rq, <span class=type>int</span> error)</span>;</span><br><span class=line><span class=comment>// 用blk_queue_make_request（）绕开I/O调度，但是在bio处理完成后应该使用bio_endio</span></span><br><span class=line><span class=type>void</span> <span class="title function_">bio_endio</span><span class=params>(<span class=keyword>struct</span> bio *bio, <span class=type>int</span> error)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 如果是I/O操作故障，可以调用快捷函数bio_io_error（）</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> bio_io_error(bio) bio_endio((bio), -EIO)</span></span><br><span class=line><span class=comment>// 遍历一个请求的所有bio</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> __rq_for_each_bio(_bio, rq) \</span></span><br><span class=line><span class=meta>    <span class=keyword>if</span> ((rq->bio))                  \</span></span><br><span class=line><span class=meta>        for (_bio = (rq)->bio; _bio; _bio = _bio->bi_next)</span></span><br><span class=line><span class=comment>// 遍历一个bio的所有bio_vec</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> __bio_for_each_segment(bvl, bio, iter, start) \</span></span><br><span class=line><span class=meta>    for (iter = (start);                              \</span></span><br><span class=line><span class=meta>         (iter).bi_size &&                            \</span></span><br><span class=line><span class=meta>         ((bvl = bio_iter_iovec((bio), (iter))), 1);  \</span></span><br><span class=line><span class=meta>         bio_advance_iter((bio), &(iter), (bvl).bv_len))</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> bio_for_each_segment(bvl, bio, iter) \</span></span><br><span class=line><span class=meta>    __bio_for_each_segment(bvl, bio, iter, (bio)->bi_iter)</span></span><br><span class=line><span class=comment>// 迭代遍历一个请求所有bio中的所有segment</span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> rq_for_each_segment(bvl, _rq, _iter) \</span></span><br><span class=line><span class=meta>    __rq_for_each_bio(_iter.bio, _rq)        \</span></span><br><span class=line><span class=meta>        bio_for_each_segment(bvl, _iter.bio, _iter.iter)</span></span><br></pre></table></figure><h3 id=io调度器>I/O调度器</h3><p>Linux 2.6以后的内核包含4个I/O调度器，它们分别是Noop I/O调度器（适合Flash）、Anticipatory I/O调度器、Deadline I/O调度器（适合读取多的场景，数据库）与CFQ I/O调度器（适合多媒体应用）。其中，Anticipatory I/O调度器算法已经在2010年从内核中去掉了。<p>可以通过给内核添加启动参数，选择所使用的I/O调度算法<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>kernel elevator=deadline</span><br></pre></table></figure><p>通过类似如下的命令，改变一个设备的调度器<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>echo</span> SCHEDULER > /sys/block/DEVICE/queue/scheduler</span><br></pre></table></figure><h2 id=linux块设备驱动初始化>Linux块设备驱动初始化</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 注册设备</span></span><br><span class=line><span class=comment>// major参数是块设备要使用的主设备号，name为设备名，它会显示在/proc/devices中。</span></span><br><span class=line><span class=comment>// 如果major为0，内核会自动分配一个新的主设备号，register_blkdev（）函数的返回值就是这个主设备号。</span></span><br><span class=line><span class=type>int</span> <span class="title function_">register_blkdev</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> major, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br><span class=line><span class=comment>// 注销设备</span></span><br><span class=line><span class=type>int</span> <span class="title function_">unregister_blkdev</span><span class=params>(<span class=type>unsigned</span> <span class=type>int</span> major, <span class=type>const</span> <span class=type>char</span> *name)</span>;</span><br></pre></table></figure><h2 id=块设备的打开释放>块设备的打开释放</h2><p>块设备驱动的open（）函数和其字符设备驱动的对等体不太相似，前者不以相关的inode和file结构体指针作为参数。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> (*open)(<span class=keyword>struct</span> block_device *bdev, <span class=type>fmode_t</span> mode);</span><br><span class=line><span class=type>void</span> (*release)(<span class=keyword>struct</span> gendisk *disk, <span class=type>fmode_t</span> mode);</span><br></pre></table></figure><h2 id=块设备ioctl函数>块设备ioctl函数</h2><p>与字符设备驱动一样，块设备可以包含一个ioctl（）函数以提供对设备的I/O控制能力。高层的块设备层代码处理了绝大多数I/O控制。例如，<code>drivers/block/floppy.c</code>实现了与软驱相关的命令，<code>drivers/mmc/card/block.c</code>实现了MMC子系统的命令处理。<h2 id=块设备驱动的io请求处理>块设备驱动的I/O请求处理</h2><p>使用请求队列的源码见<code>drivers/memstick/core/ms_block.c</code>。<p>使用请求队列对于一个机械磁盘设备而言的确有助于提高系统的性能，但是对于RAMDISK、ZRAM（Compressed RAM Block Device）等完全可真正随机访问的设备而言，无法从高级的请求队列逻辑中获益。源码见<code>drivers/block/zram/zram_drv.c</code><h2 id=实例vmem_disk驱动>实例：vmem_disk驱动</h2><h3 id=vmem_disk硬件原理>vmem_disk硬件原理</h3><p>vmem_disk是一种模拟磁盘，其数据实际上存储在RAM中。它使用通过vmalloc（）分配出来的内存空间来模拟出一个磁盘，以块设备的方式来访问这片内存。该驱动是对字符设备驱动章节中globalmem驱动的块方式改造。<p>加载vmem_disk.ko后，在使用默认模块参数的情况下，系统会增加4个块设备节点。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>ls</span> -l /dev/vmem_disk*</span><br><span class=line>brw-rw---- 1 root disk 252, 0 2月 25 14:00 /dev/vmem_diska</span><br><span class=line>brw-rw---- 1 root disk 252, 16 2月 25 14:00 /dev/vmem_diskb</span><br><span class=line>brw-rw---- 1 root disk 252, 32 2月 25 14:00 /dev/vmem_diskc</span><br><span class=line>brw-rw---- 1 root disk 252, 48 2月 25 14:00 /dev/vmem_diskd</span><br><span class=line></span><br><span class=line>$ <span class=built_in>sudo</span> mkfs.ext2 /dev/vmem_diska</span><br><span class=line>mke2fs 1.42.9 (4-Feb-2014)</span><br><span class=line>Filesystem label=</span><br><span class=line>OS <span class=built_in>type</span>: Linux</span><br><span class=line>Block size=1024 (<span class=built_in>log</span>=0)</span><br><span class=line>Fragment size=1024 (<span class=built_in>log</span>=0)</span><br><span class=line>Stride=0 blocks, Stripe width=0blocks</span><br><span class=line>64 inodes, 512 blocks</span><br><span class=line>25 blocks (4.88%) reserved <span class=keyword>for</span> the super user</span><br><span class=line>First data block=1</span><br><span class=line>Maximum filesystem blocks=524288</span><br><span class=line>1 block group</span><br><span class=line>8192 blocks per group, 8192fragments per group</span><br><span class=line>64 inodes per group</span><br><span class=line>Allocating group tables: <span class=keyword>done</span></span><br><span class=line>Writing inode tables: <span class=keyword>done</span></span><br><span class=line>Writing superblocks and filesystem accounting information: <span class=keyword>done</span></span><br></pre></table></figure><h1 id=驱动开发常用项>驱动开发常用项</h1><h2 id=驱动属性项>驱动属性项</h2><p><code>linux/device.h</code><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line>// 设备属性处理函数</span><br><span class=line>static ssize_t xxx1_store(struct device *dev,</span><br><span class=line>			      struct device_attribute *attr,</span><br><span class=line>			      const char *buf, size_t n)</span><br><span class=line>{</span><br><span class=line>	int input;</span><br><span class=line>	if (kstrtoint(buf, 10, &input))</span><br><span class=line>		return -EINVAL;</span><br><span class=line>	...</span><br><span class=line>	schedule_work(&work);</span><br><span class=line>	return n;</span><br><span class=line>}</span><br><span class=line>// 声明设备属性结构体dev_attr_xxx1，并赋值xxx1_store为对应的处理函数</span><br><span class=line>static DEVICE_ATTR_WO(xxx1);</span><br><span class=line>static struct attribute *xxx_attrs[] = {</span><br><span class=line>	&dev_attr_xxx1.attr,</span><br><span class=line>	&dev_attr_xxx2.attr,</span><br><span class=line>	NULL,</span><br><span class=line>};</span><br><span class=line>static const struct attribute_group xxx_group = {</span><br><span class=line>	.attrs = xxx_attrs,</span><br><span class=line>};</span><br><span class=line></span><br><span class=line>// 在进行初始化时进行，例如probe中</span><br><span class=line>// 注册设备属性</span><br><span class=line>sysfs_create_group(&dev->kobj, &xxx_group);</span><br><span class=line>// 移除设备属性</span><br><span class=line>sysfs_remove_group(&dev->kobj, &xxx_group);</span><br></pre></table></figure><h2 id=工作队列-1>工作队列</h2><p>内核驱动处理时，遇到比较费时类型的任务时，可以将任务放到工作队列，稍后在合适的时候进行处理。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>// 工作队列结构体</span><br><span class=line>struct work_struct{}</span><br><span class=line>// 工作队列处理函数</span><br><span class=line>void xxx_handle(struct work_struct *work);</span><br><span class=line>// 初始化工作队列</span><br><span class=line>INIT_WORK(&xxx_work, xxx_handle);</span><br><span class=line>// 调度工作队列</span><br><span class=line>schedule_work(&work);</span><br></pre></table></figure><h1 id=附录>附录</h1><h2 id=常用命令>常用命令</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=comment># 加载驱动</span></span><br><span class=line>$ <span class=built_in>sudo</span> insmod globalmem.ko</span><br><span class=line><span class=comment># 卸载驱动</span></span><br><span class=line>$ <span class=built_in>sudo</span> rmmod globalmem</span><br><span class=line></span><br><span class=line><span class=comment># 只查看最新的内核打印消息</span></span><br><span class=line>$ dmesg -W</span><br><span class=line></span><br><span class=line><span class=comment># 查看驱动主设备号</span></span><br><span class=line>$ <span class=built_in>cat</span> /proc/devices | grep globalmem</span><br><span class=line>230 globalmem</span><br><span class=line><span class=comment># 查看驱动设备节点信息</span></span><br><span class=line>$ <span class=built_in>ls</span> -l /dev/globalmem</span><br><span class=line>crwxrwxrwx 1 root root 230, 0 Dec 27 17:40 /dev/globalmem</span><br><span class=line><span class=comment># 查看platform驱动</span></span><br><span class=line><span class=built_in>ls</span> /sys/devices/platform/globalfifo -l</span><br><span class=line>total 0</span><br><span class=line>lrwxrwxrwx 1 root root    0  1月  2 17:00 driver -> ../../../bus/platform/drivers/globalfifo</span><br><span class=line>-rw-r--r-- 1 root root 4096  1月  2 17:03 driver_override</span><br><span class=line>-r--r--r-- 1 root root 4096  1月  2 17:03 modalias</span><br><span class=line>drwxr-xr-x 2 root root    0  1月  2 17:03 power</span><br><span class=line>lrwxrwxrwx 1 root root    0  1月  2 17:03 subsystem -> ../../../bus/platform</span><br><span class=line>-rw-r--r-- 1 root root 4096  1月  2 17:00 uevent</span><br><span class=line></span><br><span class=line><span class=comment># 创建设备节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem c 230 0</span><br><span class=line><span class=comment># 删除设备节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>unlink</span> /dev/globalmem</span><br><span class=line><span class=comment># 创建支持多设备的节点</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem0 c 230 0</span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>mknod</span> /dev/globalmem1 c 230 1</span><br><span class=line></span><br><span class=line><span class=comment># 创建的设备普通用户没有写入权限，需要增加写入权限</span></span><br><span class=line><span class=comment># 或者给予全权限</span></span><br><span class=line>$ <span class=built_in>sudo</span> <span class=built_in>chmod</span> 777 /dev/globalmem*</span><br><span class=line></span><br><span class=line><span class=comment># 向设备写入数据</span></span><br><span class=line>$ <span class=built_in>echo</span> <span class=string>"hello world 0"</span> >> /dev/globalmem0</span><br><span class=line><span class=comment># 读取设备中的数据</span></span><br><span class=line>$ <span class=built_in>cat</span> /dev/globalmem0</span><br><span class=line>hello world 0</span><br></pre></table></figure><h2 id=参考>参考</h2><p><a href=https://github.com/kevinwangkk/LDD4.0_note/blob/master/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%80%E6%96%B0%E7%9A%84Linux4.0%E5%86%85%E6%A0%B8.pdf rel=noopener target=_blank>Linux设备驱动开发详解：基于最新的Linux4.0内核.pdf</a><p><a href=https://blog.csdn.net/cotex_a9/category_12427627.html rel=noopener target=_blank>嵌入式王道长-Linux内核驱动开发</a></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/24/Xv6-RISC-V%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/24/Xv6-RISC-V%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ itemprop=url>Xv6-RISC-V阅读笔记</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-24 09:44:41" datetime=2024-04-24T09:44:41+08:00>2024-04-24</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Xv6/ itemprop=url rel=index><span itemprop=name>Xv6</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>6.4k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>23 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><p><a href=https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf rel=noopener target=_blank>参考原文</a><h1 id=chapter-1-系统接口>Chapter 1 系统接口</h1><h2 id=unix-utilities实验>Unix utilities实验</h2><p><a href=https://pdos.csail.mit.edu/6.828/2023/labs/util.html rel=noopener target=_blank>实验说明</a><h3 id=启动系统>启动系统</h3><h3 id=sleep>sleep</h3><p>重点：使用<code>user/user.h</code>的sleep接口实现，单位为jiffies(1/10)。<h3 id=pingpong>pingpong</h3><p>重点：使用pip接口通信。<h3 id=primes>primes</h3><p>目的：主进程准备好2-35的数字写入管道。<p>从管道中读取数字n（此数字为素数），创建一个子进程，并将剩余的非n的倍数的数写入子管道中。然后进程等待子进程的退出。子进程会重复父进程的动作，直到读取的数字到达35，则不再创建子进程。<h3 id=find>find</h3><p>重点：熟悉文件属性读取，和路径拼接。<h3 id=xargs>xargs</h3><p>重点：使用exec接口实现，并需要构建新的参数数组。<h1 id=chapter-2-系统结构>Chapter 2 系统结构</h1><blockquote><p>RISC-V has three modes in which the CPU can execute instructions: machine mode, supervisor mode, and user mode.</blockquote><blockquote><p>An application can execute only user-mode instructions and is said to be running in user space, while the software in supervisor mode can also execute privileged instructions and is said to be running in kernel space.</blockquote><blockquote><p>CPUs provide a special instruction ( RISC-V provides the <code>ecall</code> instruction ) that switches the CPU from user mode to supervisor mode and enters the kernel at an entry point specified by the kernel.</blockquote><blockquote><p>the entire operating system resides in the kernel, so that the implementations of all system calls run in supervisor mode. This organization is called a monolithic kernel.</blockquote><blockquote><p>OS designers can minimize the amount of operating system code that runs in supervisor mode, and execute the bulk of the operating system in user mode. This kernel organization is called a microkernel.</blockquote><p>源码文件功能描述如下<table><thead><tr class=header><th>文件名<th>功能描述<tbody><tr class=odd><td>bio.c<td>Disk block cache for the file system.<tr class=even><td>console.c<td>Connect to the user keyboard and screen.<tr class=odd><td>entry.S<td>Very first boot instructions.<tr class=even><td>exec.c<td>exec() system call.<tr class=odd><td>file.c<td>File descriptor support.<tr class=even><td>fs.c<td>File system.<tr class=odd><td>kalloc.c<td>Physical page allocator.<tr class=even><td>kernelvec.S<td>Handle traps from kernel, and timer interrupts.<tr class=odd><td>log.c<td>File system logging and crash recovery.<tr class=even><td>main.c<td>Control initialization of other modules during boot.<tr class=odd><td>pipe.c<td>Pipes.<tr class=even><td>plic.c<td>RISC-V interrupt controller.<tr class=odd><td>printf.c<td>Formatted output to the console.<tr class=even><td>proc.c<td>Processes and scheduling.<tr class=odd><td>sleeplock.c<td>Locks that yield the CPU.<tr class=even><td>spinlock.c<td>Locks that don’t yield the CPU.<tr class=odd><td>start.c<td>Early machine-mode boot code.<tr class=even><td>string.c<td>C string and byte-array library.<tr class=odd><td>swtch.S<td>Thread switching.<tr class=even><td>syscall.c<td>Dispatch system calls to handling function.<tr class=odd><td>sysfile.c<td>File-related system calls.<tr class=even><td>sysproc.c<td>Process-related system calls.<tr class=odd><td>trampoline.S<td>Assembly code to switch between user and kernel.<tr class=even><td>trap.c<td>C code to handle and return from traps and interrupts.<tr class=odd><td>uart.c<td>Serial-port console device driver.<tr class=even><td>virtio_disk.c<td>Disk device driver.<tr class=odd><td>vm.c<td>Manage page tables and address spaces.</table><p>进程虚拟空间分布<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>地址    功能域</span><br><span class=line></span><br><span class=line>MAXVA   &lt;---------></span><br><span class=line>        trampoline</span><br><span class=line>        &lt;---------></span><br><span class=line>        trapframe</span><br><span class=line>        &lt;---------></span><br><span class=line>        heap</span><br><span class=line>        &lt;---------></span><br><span class=line>        user stack</span><br><span class=line>        &lt;---------></span><br><span class=line>        user text</span><br><span class=line>        and data</span><br><span class=line>        (followed by global variables)</span><br><span class=line>        (Instructions come first)</span><br><span class=line>0       &lt;---------></span><br></pre></table></figure><p>risc-v指针宽度为64位，但硬件只使用低39位用于在页表中寻找虚拟地址，而xv6系统中只使用了38位。因此最大地址为<code>2^38 - 1=0x3f,ffff,ffff MAXVA</code>(kernel/riscv.h:363)<p>进程重要信息存储在<code>struct proc</code>(kernel/proc.h:85)<blockquote><p>RISC-V <code>ecall</code> instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point.</blockquote><p>When the system call completes, the kernel switches back to the user stack and returns to user space by calling the <code>sret</code> instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction.<p>启动流程：<ul><li>boot loader将kernel加载到内存<code>0x8000 0000</code><li>在machine mode下，跳转到<code>_entry</code>(kernel/entry.S:7)，设置堆栈，并跳转运行C代码<li>在C代码入口函数<code>start</code>(kernel/start.c:21)中，切换到supervisor mode，配置时钟中断，并跳转到主函数。<li>在主函数<code>main</code>(kernel/main.c:11)中，初始化设备和子系统，创建第一个进程<li>在初始化进程<code>userinit</code>(kernel/proc.c:233)中，寄存器a7装载<code>SYS_EXEC</code>(kernel/syscall.h:8)后再次进入内核<li>在内核系统调用处理函数<code>syscall</code>(kernel/syscall.c:132)中，启动<code>/init</code>进程<li>系统调用完成后，返回进程<code>init</code>(user/init.c)，创建一个新console设备文件，并打开文件描述符0,1,2。</ul><blockquote><p>it sets the previous privilege mode to supervisor in the register mstatus, it sets the return address to main by writing main’s address into the register mepc, disables virtual address translation in supervisor mode by writing 0 into the page-table register satp, and delegates all interrupts and exceptions to supervisor mode.</blockquote><h2 id=system-call实验>system call实验</h2><h3 id=system-call-tracing>System call tracing</h3><p>新增一个<code>trace</code>系统调用，它接收一个整数参数，它表明哪些系统调用被标记。当被标记的系统调用返回时，需要打印<code>&lt;pid>: syscall &lt;call name> -> &lt;return value></code>。此标记对子进程和forks都有效，但对其他进程无效。<p>关键点<ul><li><code>user/trace.c</code>中设置调用<code>trace(x)</code>后需要再<code>trace(0)</code>清空进程标记；<li><code>user/user.h</code>中增加用户调用系统函数<code>int trace(int sys_mask);</code>，<code>user/usys.pl</code>增加<code>trace</code>生成相关汇编代码；<li><code>kernel/syscall.h</code>新增宏编号<code>#define SYS_trace 22</code>，<code>kernel/sysproc.c</code>新增标记实现函数<code>uint64 sys_trace(void)</code><li><code>syscall</code>增加标记打印逻辑，需要注意<code>allocproc</code>中共用<code>struct proc proc[NPROC];</code>，申请后要清空之前的标记；</ul><h3 id=sysinfo>Sysinfo</h3><p>新增一个<code>sysinfo</code>系统调用，它会收集系统空闲内存字节大小<code>freemem</code>和正在使用的进程数量<code>nproc</code>。需要提供用户测试程序<code>sysinfotest</code>调用这个接口，若整个调用没有问题，则打印<code>"sysinfotest: OK"</code>。<p>关键点<ul><li>需要使用接口<code>copyout</code>将内核空间的数据拷贝到用户空间中</ul><h2 id=练习>练习</h2><ol type=1><li>增加一个系统调用，返回系统剩余可用内存大小</ol><h1 id=chapter-3-页表>Chapter 3 页表</h1><h2 id=创建地址空间>创建地址空间</h2><p>核心的数据结构<code>pagetable_t kernel_pagetable</code>(kernel/vm.c:1)中，核心的功能函数是<code>walk</code>，用于查找虚拟地址对应的PTE。<p><code>main</code>中调用<code>kvminit</code>(kernel/vm.c:54)创建内核页表，再调用<code>kvmmake</code>，最终通过<code>kvmmap</code>、<code>mappages</code>和<code>walk</code>完成物理地址虚拟地址映射。<p><code>main</code>中调用<code>kvminithart</code>(kernel/vm.c:62)安装内核页表。主要讲根页表的地址设置到<code>satp</code>寄存器中，设置前后需要刷新<code>TLB</code>缓存。<blockquote><p>The RISC-V has an instruction sfence.vma that flushes the current CPU’s TLB. Xv6 executes sfence.vma in kvminithart after reloading the satp register</blockquote><h2 id=物理内存分配>物理内存分配</h2><p>分配器定义在<code>kalloc.c</code>(kernel/kalloc.c:1)。每个空闲页的列表元素都是一个<code>struct run</code>。<p><code>main</code>中调用<code>kinit</code>(kernel/kalloc.c:27)来初始化分配器。它将初始化空闲列表<code>kmem->freelist</code>(kernel/kalloc.c:21)用于保存内核结束位置到<code>PHYSTOP</code>区间的每一页。<h2 id=进程地址空间>进程地址空间</h2><p>每个进程都有独立的页表。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>MAXVA   &lt;---------></span><br><span class=line>        trampoline  RX--</span><br><span class=line>        &lt;---------></span><br><span class=line>        trapframe   R-W-</span><br><span class=line>        &lt;---------></span><br><span class=line>        unused</span><br><span class=line>        &lt;---------></span><br><span class=line>        heap        R-WU</span><br><span class=line>        &lt;---------></span><br><span class=line>        stack       R-WU</span><br><span class=line>        &lt;---------></span><br><span class=line>        guard page</span><br><span class=line>        &lt;---------></span><br><span class=line>        data        R-WU</span><br><span class=line>        &lt;---------></span><br><span class=line>        unused</span><br><span class=line>        &lt;---------></span><br><span class=line>        text        RX-U</span><br><span class=line>0       &lt;---------></span><br></pre></table></figure><p>一个进程的用户内存从虚拟地址零开始，可以增长到<code>MAXVA</code>(kernel/riscv.h:360)，允许最大使用256GB内存。<p>零地址放置的text代码，没有写入权限，当异常的程序试图向零地址写入数据，会出发<code>page fault</code>。<h2 id=sbrk>sbrk</h2><p><code>sbrk</code>是进程为调整内存时的系统调用。它由函数<code>growproc</code>(kernel/proc.c:260)实现。<h2 id=exec>exec</h2><p><code>exec</code>是一个系统调用，它可以用从文件读取的数据替换进程用户空间数据，这样的文件被称为二进制或可行性文件。函数<code>exec</code>(kernel/exec.c:23)会读取并解析ELF格式的文件，它包含<code>struct elfhdr</code>ELF文件头部和一系列<code>struct proghdr</code>程序区域头部。每个程序区域头部描述程序必须加载到内存的位置。<p><code>/init</code>程序区域头部像下面这样<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>$ objdump -p user/_init </span><br><span class=line></span><br><span class=line>user/_init:     file format elf64-little</span><br><span class=line></span><br><span class=line>Program Header:</span><br><span class=line>0x70000003 off    0x0000000000006bac vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**0</span><br><span class=line>         filesz 0x0000000000000033 memsz 0x0000000000000000 flags r--</span><br><span class=line>    LOAD off    0x0000000000001000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12</span><br><span class=line>         filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x</span><br><span class=line>    LOAD off    0x0000000000002000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12</span><br><span class=line>         filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-</span><br><span class=line>   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4</span><br><span class=line>         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></table></figure><p>值得注意的是，头部信息中<code>filesz</code>可能会小于<code>memsz</code>，那时因为这些变量值为0，文件中无需存储，但加载时需要申请<code>memsz</code>大小的空间并清零。<p>然后，函数需要拷贝参数列表，并将堆栈和PC设置好。最后将释放旧页表，使用新页表。<h2 id=练习-1>练习</h2><ol type=1><li>解析riscv的设备树，找出总共拥有多少物理内存<li>写一个用户程序调用<code>sbrk(1)</code>，观察调用前后页表的变化。内核申请了多少空间？新内存的PTE包含哪些数据？<li>修改源码让内核使用超级页<li>在Unix系统中，若<code>exec</code>处理的可执行文件以<code>#!</code>开头，则会使用第一行剩余部分替换程序作为解释文件执行。修改源码让内核支持这个特性。<li>实现一个地址空间随机分布的内核。</ol><h1 id=chapter-4-traps和系统调用>Chapter 4 traps和系统调用</h1><h2 id=riscv的trap机制>riscv的trap机制</h2><blockquote><p>Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occurred.</blockquote><p>在文件<code>riscv.h</code>(kernel/riscv.h:1)中包含系统用到的所有描述。这里列举最重要的寄存器<ul><li><code>stvec</code>: 内核写入trap处理程序的地址<li><code>sepc</code>: 当trap发生时，处理器会保存<code>pc</code>；当从trap返回时，调用<code>sret</code>会从此寄存器恢复<code>pc</code>。<li><code>scause</code>: 处理器会存放一个数字描述trap的原因<li><code>sscratch</code>: trap处理程序使用<code>sscratch</code>来避免改写用户寄存器<li><code>sstatus</code>: SIE位控制设备中断是否使能；SPP位指示trap触发前是user mode还是supervisor mode；</ul><p>xv6只将它们使用在计时器中断的特殊场景<p>硬件处理所有类型trap流程：<ul><li>若<code>sstatus</code>的SIE位被清零，则后面的步骤略过<li><code>sstatus</code>的SIE位清零<li>拷贝<code>pc</code>值到<code>sepc</code><li>保存当前模式到<code>sstatus</code>的SPP位<li>设置<code>scause</code><li>模式切换为supervisor mode<li>拷贝<code>stvec</code>到<code>pc</code><li>继续从<code>pc</code>处开始执行</ul><blockquote><p>Note that the CPU doesn’t switch to the kernel page table, doesn’t switch to a stack in the kernel, and doesn’t save any registers other than the pc.</blockquote><h2 id=用户空间的traps流程>用户空间的traps流程</h2><p>用户空间trap路径是：<code>uservec</code>(kernel/trampoline.S:21)-><code>usertrap</code>(kernel/trap.c:37)-return-><code>usertrapret</code>(kernel/trap.c:90)->userret(kernel/trampoline.S:101)<p>xv6使用trampoline页来存储<code>stvec</code>，它页包含<code>uservec</code>。trampoline页会被每个进程映射到TRAMPOLINE的地址处。<p><code>uservec</code>函数会将32个用户寄存器存储到TRAPFRAME地址所在的<code>trapframe</code>结构中，然后将寄存器<code>satp</code>切换为内核页表，再调用<code>usertrap</code>函数。<p><code>usertrap</code>(kernel/trap.c:37)函数会检测trap的原因并处理它。首先将设置<code>stvec</code>为<code>kernelvec</code>，以便处理内核trap。保存<code>sepc</code>寄存器。如果trap是系统调用，则调用<code>syscall</code>处理它；若是设备中断，<code>devintr</code>处理它；否则，是一种异常场景，调用内核终止异常的进程。若是系统调用，则在函数结束时会调用<code>usertrapret</code><p>返回用户空间的第一步是调用<code>usertrapret</code>(kernel/trap.c:90)。它会将<code>stvec</code>设置回<code>uservec</code>，<code>uservec</code>的映射地址可以通过TRAMPOLINE、trampoline和uservec计算出来（注意内核中这些是物理地址）。然后恢复<code>pc</code>，最后调用<code>userret</code>函数并将<code>a0</code>设置为用户页表。<p><code>userret</code>(kernel/trampoline.S:101)函数将切换<code>satp</code>为用户页表，并恢复32个用户寄存器。最后调用<code>sret</code>返回用户空间。<h2 id=系统调用流程>系统调用流程</h2><p>以initcode.S中第一个系统调用<code>exec</code>为例。<p>initcode.S在寄存器<code>a0</code>和<code>a1</code>存放着<code>exec</code>的参数，并将系统调用编号存放在<code>a7</code>中。根据系统调用编号在<code>syscalls</code>(kernel/syscall.c:107)数组中匹配到处理函数。指令<code>ecall</code>会触发trap切换到内核中并引发<code>uservec</code>、<code>usertrap</code>和<code>syscall</code>执行。<h2 id=系统调用参数列表>系统调用参数列表</h2><p>内核trap代码将用户寄存器放在当前进程的trap frame上，可以通过内核函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>返回第n个参数，它们通过调用<code>argraw</code>实现(kernel/syscall.c:34)。<p>有些参数通过用户地址传递，<code>fechstr</code>(kernel/syscall.c:25)函数能够拷贝用户传递的字符串。<h2 id=内核空间的traps流程>内核空间的traps流程</h2><p>内核空间trap路径是：<code>kernelvec</code>(kernel/kernelvec.S:12)-><code>kerneltrap</code>(kernel/trap.c:135)-><code>kernelvec</code>(kernel/kernelvec.S:12)<p>若trap不是设备中断，则异常会直接导致xv6内核出panic。<p>当处理器遇到trap进入内核空间时，总会禁用中断，直到设置<code>stvec</code>后。<h2 id=缺页异常>缺页异常</h2><p>若发生在用户空间，内核将终止相关进程。若发生在内核空间，则会直接panic。<p>许多内核利用缺页异常来实现写时复制（copy-on-write, COW）机制。COW fork的基本方法是，为父进程和子进程初始化共享所有物理页，但将他们的全部设置为只读。当进程向某页写入数据时，会触发store page faults。此时内核需要重新申请新的一页将数据拷贝过来，并再次进行映射。一个重要的优化项是，对于缺页发生在仅从该进程中引用的，无需进行拷贝。<p>另一个广泛使用的特性是惰性分配（lazy allocation）。当一个应用调用<code>sbrk</code>请求更多内存，内核只调整其使用大小，但不会申请物理内存和创建PTEs。当这些新地址被访问时，才会申请对应的内存页并完成映射。<p>还有一个广泛使用的特性是需求分页（demand paging）。当大型程序启动时，内核无需将所有数据加载到内存中，而仅仅配置足够的用户地址空间，并将其设置为无效。当发生页错误时，内核将页的内容读入并映射到用户空间。<p>为应对程序运行时需要的空间比硬件RAM大的场景，操作系统可以实现磁盘映射（paging to disk）。<h2 id=练习-2>练习</h2><ol type=1><li>配置内核页表，让内核可以直接使用用户空间地址；<li>实现惰性内存分配机制；<li>实现COW fork；<li>是否有方法消除TRAPFRAME页映射到每个用户地址空间？比如，修改<code>uservec</code>函数将32个用户寄存器存入内核栈，或将其存入<code>proc</code>结构中？<li>是否有方法消除TRAMPOLINE页映射？</ol><h1 id=中断和设备驱动>中断和设备驱动</h1><p>在xv6中，内核trap会处理和识别设备中断，最终交于<code>devintr</code>(kernel/trap.c:178)。<blockquote><p>Many device drivers execute code in two contexts: a top half that runs in a process’s kernel thread, and a bottom half that executes at interrupt time.</blockquote><h2 id=终端输入>终端输入</h2><p>终端驱动(kernel/console.c)是一个简单的驱动框架的示例。<blockquote><p>The UART hardware that the driver talks to is a 16550 chip [13] emulated by QEMU. On a real computer, a 16550 would manage an RS232 serial link connecting to a terminal or other computer. When running QEMU, it’s connected to your keyboard and display.</blockquote><p>UART的基地址是0x10000000(UART0, kernel/memlayout.h:21)，UART0各寄存器定义在文件(kernel/uart.c:22)中。<p>xv6的<code>main</code>调用<code>consoleinit</code>(kernel/console.c:182)函数，然后再调用<code>uartinit</code>(kernel/uart.c:53)函数来初始化UART硬件。<p>在init.c(user/init.c:19)打开的文件描述符，它能够读取xv6的命令。调用<code>read</code>系统调用，通过内核来调用<code>consoleread</code>(kernel/console.c:80)。它会一直等待中断并缓存数据到<code>cons.buf</code>中，直到整个行输入完成，会将缓存中数据拷贝给用户最终返回到用户空间。<p>当用户输入一个字符，UART硬件设备会想处理器产生一个中断，它会激活xv6的trap处理程序。设备中断最后会调用<code>devintr</code>(kernel/trap.c:178)进行处理。接着，通过PLIC硬件单元来分辨是哪个设备中断，如果是UART设备<code>devintr</code>会调用<code>uartintr</code>。<p><code>uartintr</code>(kernel/uart.c:176)会从UART硬件读取任意输入字符，并交于<code>consoleintr</code>(kernel/console.c:136)进行处理；<code>consoleintr</code>的任务就是将输入放到<code>cons.buf</code>，直到整行输入完成，立即唤醒<code>consoleread</code>。<h2 id=终端输出>终端输出</h2><p>在一个连接到终端的文件描述符的<code>write</code>系统调用，最终会调用<code>uartputc</code>(kernel/uart.c:87)。对于每个字符，会调用<code>uartstart</code>来开启设备发送。<h2 id=驱动的并发>驱动的并发</h2><blockquote><p>These calls acquire a lock, which protects the console driver’s data structures from concurrent access.</blockquote><h2 id=计时器中断>计时器中断</h2><blockquote><p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the yield calls in usertrap and kerneltrap cause this switching.</blockquote><blockquote><p>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode.</blockquote><p>代码在start.c配置接收计时器中断(kernel/start.c:63)。部分工作的目的是编写CLINT硬件（core-local interruptor），在特定延时后产生一个中断。最终，<code>start</code>配置<code>mtvec</code>到<code>timervec</code>并使能计时器中断。<blockquote><p>A timer interrupt can occur at any point when user or kernel code is executing; there’s no way for the kernel to disable timer interrupts during critical operations.</blockquote><blockquote><p>The basic strategy is for the handler to ask the RISC-V to raise a “software interrupt” and immediately return.</blockquote><p>在machine mode的中断处理程序是<code>timervec</code>(kernel/kernelvec.S:95)，它主要配置CLINT的<code>MTIMECMP</code>寄存器，并设置<code>sip</code>为2后立刻返回。<h2 id=练习-3>练习</h2><ol type=1><li>修改uart.c完全不使用中断，同时也需要修改console.c<li>增加一个以太网卡驱动</ol><h1 id=chapter-6-锁>Chapter 6 锁</h1><blockquote><p>Xv6 uses a number of concurrency control techniques, depending on the situation; many more are possible. This chapter focuses on a widely used technique: the lock.</blockquote><h2 id=竞争>竞争</h2><h2 id=锁>锁</h2><blockquote><p>On the RISC-V this instruction is <code>amoswap r, a</code>. <code>amoswap</code> reads the value at the memory address <code>a</code>, writes the contents of register <code>r</code> to that address, and puts the value it read into <code>r</code>.</blockquote><blockquote><p>It performs this sequence atomically, using special hardware to prevent any other CPU from using the memory address between the read and the write.</blockquote><blockquote><p>Xv6’s acquire (kernel/spinlock.c:22) uses the portable C library call __sync_lock_test_and_set, which boils down to the amoswap instruction; the return value is the old (swapped) contents of lk->locked.</blockquote><p><code>acquire</code>(kernel/spinlock.c:22)利用riscv处理器的指令<code>amoswap.w.aq a0, a0, (s1)</code>实现。当获取锁成功时<code>lk->locked</code>为1。<p><code>release</code>(kernel/spinlock.c:47)利用riscv处理器的指令<code>amoswap.w zero, zero, (s1)</code>实现。当释放锁成功时<code>lk->locked</code>为0。<h2 id=使用锁>使用锁</h2><blockquote><p>A hard part about using locks is deciding how many locks to use and which data and invariants each lock should protect.</blockquote><h2 id=再入锁>再入锁</h2><blockquote><p>It might appear that some deadlocks and lock-ordering challenges could be avoided by using re-entrant locks, which are also called recursive locks. The idea is that if the lock is held by a process and if that process attempts to acquire the lock again, then the kernel could just allow this (since the process already has the lock), instead of calling panic, as the xv6 kernel does.</blockquote><h2 id=锁和中断处理程序>锁和中断处理程序</h2><blockquote><p>Some xv6 spinlocks protect data that is used by both threads and interrupt handlers.</blockquote><blockquote><p>To avoid this situation, if a spinlock is used by an interrupt handler, a CPU must never hold that lock with interrupts enabled.</blockquote><p>例如，<code>clockintr</code>计时器中断处理会增加<code>ticks</code>(kernel/trap.c:164)，同时内核线程<code>sys_sleep</code>(kernel/sysproc.c:59)会读取<code>ticks</code>的值。锁<code>tickslock</code>会让两次访问串行化。<h2 id=指令和内存顺序>指令和内存顺序</h2><blockquote><p>It is natural to think of programs executing in the order in which source code statements appear. That’s a reasonable mental model for single-threaded code, but is incorrect when multiple threads interact through shared memory.</blockquote><blockquote><p>To tell the hardware and compiler not to re-order, xv6 uses __sync_synchronize() in both acquire (kernel/spinlock.c:22) and release (kernel/spinlock.c:47). __sync_synchronize() is a memory barrier: it tells the compiler and CPU to not reorder loads or stores across the barrier.</blockquote><h2 id=睡眠锁>睡眠锁</h2><blockquote><p>Xv6 provides such locks in the form of sleep-locks. acquiresleep (kernel/sleeplock.c:22) yields the CPU while waiting</blockquote><h2 id=练习-4>练习</h2><ol type=1><li>若屏蔽<code>kalloc</code>(kernel/kalloc.c:69)<code>acquire</code>和<code>release</code>的调用，会出现哪些问题？若没有看到问题，原因是什么？<li>在<code>kfree</code>中屏蔽锁（恢复<code>kalloc</code>中的锁），会出现哪些问题？<li>修改<code>kalloc.c</code>源码让内存申请支持并发，CPU不用相互等待。<li>使用POSIX线程进行编码。例如，实现一个并行哈希表并测试<code>puts/gets</code>数据量是否随着核数量的增加而增加。<li>在xv6中实现pthreads的子集。实现一个用户级的线程库，这样一个用户进程就可以有多个线程，并安排这些线程运行在不同的cpu上并行运行。想出一个设计，正确地处理一个线程进行阻塞系统调用，并改变其共享地址空间。</ol><h1 id=调度>调度</h1><h2 id=复用>复用</h2><blockquote><p>Xv6 multiplexes by switching each CPU from one process to another in two situations. First, xv6’s sleep and wakeup mechanism switches when a process waits for device or pipe I/O to complete, or waits for a child to exit, or waits in the sleep system call. Second, xv6 periodically forces a switch to cope with processes that compute for long periods without sleeping.</blockquote><h2 id=上下文切换>上下文切换</h2><blockquote><p>it just saves and restores sets of 32 RISC-V registers, called contexts.</blockquote><p>当进程想放弃CPU时，内核线程会调用<code>swtch</code>来保存它的上下文并返回调度器上下文。每个上下文都包含在<code>struct context</code>(kernel/proc.h:2)，进程的<code>struct proc</code>和CPU的<code>struct cpu</code>都包含上下文。<p><code>swtch</code>(kernel/swtch.S:3)只保存被调用者保存的寄存器。C编译器会生成代码保存调用者保存的寄存器到栈上。<blockquote><p>When swtch returns, it returns to the instructions pointed to by the restored ra register, that is, the instruction from which the new thread previously called swtch.</blockquote><h2 id=调度-1>调度</h2><p>当调用函数<code>swtch</code>后，会切换到调度器的栈。调度器会继续在循环中查找可以切换的进程，并再次调用<code>swtch</code>进行切换。<blockquote><p>We just saw that xv6 holds p->lock across calls to swtch: the caller of swtch must already hold the lock, and control of the lock passes to the switched-to code.</blockquote><h2 id=mycpu和myproc>mycpu和myproc</h2><blockquote><p>Xv6 maintains a struct cpu for each CPU (kernel/proc.h:22), which records the process currently running on that CPU (if any), saved registers for the CPU’s scheduler thread, and the count of nested spinlocks needed to manage interrupt disabling.</blockquote><blockquote><p>RISC-V numbers its CPUs, giving each a hartid. Xv6 ensures that each CPU’s hartid is stored in that CPU’s tp register while in the kernel. This allows mycpu to use tp to index an array of cpu structures to find the right one.</blockquote><blockquote><p>It would be more convenient if xv6 could ask the RISC-V hardware for the current hartid whenever needed, but RISC-V allows that only in machine mode, not in supervisor mode.</blockquote><blockquote><p>The return value of myproc is safe to use even if interrupts are enabled: if a timer interrupt moves the calling process to a different CPU, its struct proc pointer will stay the same.</blockquote><h2 id=睡眠和唤醒>睡眠和唤醒</h2><blockquote><p>Sleep and wakeup are often called sequence coordination or conditional synchronization mechanisms.</blockquote><h2 id=管道>管道</h2><blockquote><p>A more complex example that uses sleep and wakeup to synchronize producers and consumers is xv6’s implementation of pipes. Each pipe is represented by a struct pipe, which contains a lock and a data buffer.</blockquote><blockquote><p>Let’s suppose that calls to piperead and pipewrite happen simultaneously on two different CPUs.</blockquote><h2 id=进程锁>进程锁</h2><blockquote><p>The lock associated with each process (p->lock) is the most complex lock in xv6. A simple way to think about p->lock is that it must be held while reading or writing any of the following struct proc fields: p->state, p->chan, p->killed, p->xstate, and p->pid.</blockquote><h2 id=练习-5>练习</h2><ol type=1><li></ol><h1 id=文件系统>文件系统</h1><h2 id=概述>概述</h2><blockquote><p>The xv6 file system implementation is organized in seven layers</blockquote><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>&lt;----------------></span><br><span class=line>File descriptor</span><br><span class=line>&lt;----------------></span><br><span class=line>Pathname</span><br><span class=line>&lt;----------------></span><br><span class=line>Directory</span><br><span class=line>&lt;----------------></span><br><span class=line>Inode</span><br><span class=line>&lt;----------------></span><br><span class=line>Logging</span><br><span class=line>&lt;----------------></span><br><span class=line>Buffer cache</span><br><span class=line>&lt;----------------></span><br><span class=line>Disk</span><br><span class=line>&lt;----------------></span><br></pre></table></figure><blockquote><p>Disk hardware traditionally presents the data on the disk as a numbered sequence of 512-byte blocks (also called sectors): sector 0 is the first 512 bytes, sector 1 is the next, and so on.</blockquote><blockquote><p>The file system does not use block 0 (it holds the boot sector). Block 1 is called the superblock; it contains metadata about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). Blocks starting at 2 hold the log. After the log are the inodes, with multiple inodes per block. After those come bitmap blocks tracking which data blocks are in use. The remaining blocks are data blocks</blockquote><p>xv6文件系统结构<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>0       &lt;----------------></span><br><span class=line>        boot</span><br><span class=line>1       &lt;----------------></span><br><span class=line>        super</span><br><span class=line>2       &lt;----------------></span><br><span class=line>        log</span><br><span class=line></span><br><span class=line>        &lt;----------------></span><br><span class=line>        inodes</span><br><span class=line></span><br><span class=line></span><br><span class=line>        &lt;----------------></span><br><span class=line>        bit map</span><br><span class=line>        &lt;----------------></span><br><span class=line>        data</span><br><span class=line></span><br><span class=line>        ....</span><br><span class=line></span><br><span class=line>        data</span><br><span class=line>        &lt;----------------></span><br></pre></table></figure><h2 id=缓存层>缓存层</h2><p>代码在<code>bio.c</code>中，缓存层有两个任务<ul><li>同步访问硬盘块block。确保只有一个块的副本在内存中，且同一时间只有一个内核线程在使用它。<li>缓存热门数据块block。</ul><blockquote><p>The main interface exported by the buffer cache consists of bread and bwrite. A kernel thread must release a buffer by calling brelse when it is done with it.</blockquote><blockquote><p>bread (kernel/bio.c:93) calls bget to get a buffer for the given sector (kernel/bio.c:97).</blockquote><blockquote><p>When the caller is done with a buffer, it must call brelse to release it.</blockquote><h2 id=日志层>日志层</h2><blockquote><p>One of the most interesting problems in file system design is crash recovery.</blockquote><blockquote><p>Xv6 solves the problem of crashes during file-system operations with a simple form of logging.</blockquote><blockquote><p>Once the system call has logged all of its writes, it writes a special commit record to the disk indicating that the log contains a complete operation. At that point the system call copies the writes to the on-disk file system data structures. After those writes have completed, the system call erases the log on disk.</blockquote><h2 id=block块分配器>block块分配器</h2><blockquote><p>File and directory content is stored in disk blocks, which must be allocated from a free pool. Xv6’s block allocator maintains a free bitmap on disk, with one bit per block.</blockquote><h2 id=inode层>inode层</h2><blockquote><p>It might refer to the on-disk data structure containing a file’s size and list of data block numbers. Or “inode” might refer to an in-memory inode</blockquote><p>磁盘上数据展现形式<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line>dinode</span><br><span class=line>|----------------|</span><br><span class=line>type</span><br><span class=line>|----------------|</span><br><span class=line>major</span><br><span class=line>|----------------|</span><br><span class=line>minor</span><br><span class=line>|----------------|</span><br><span class=line>nlink</span><br><span class=line>|----------------|</span><br><span class=line>size</span><br><span class=line>|----------------|</span><br><span class=line>address 1           -->     data0_1</span><br><span class=line>|----------------|</span><br><span class=line>...</span><br><span class=line>|----------------|</span><br><span class=line>address 12          -->     data0_12</span><br><span class=line>|----------------|</span><br><span class=line>indirect            -->     indirect block</span><br><span class=line>|----------------|          |----------------|</span><br><span class=line>                            address 1           -->     data1_1</span><br><span class=line>                            |----------------|</span><br><span class=line>                            ...</span><br><span class=line>                            |----------------|</span><br><span class=line>                            address 256         -->     data1_256</span><br><span class=line>                            |----------------|</span><br></pre></table></figure><h2 id=文件夹层>文件夹层</h2><blockquote><p>A directory is implemented internally much like a file.</blockquote><h2 id=目录名称>目录名称</h2><h2 id=文件描述符层>文件描述符层</h2><blockquote><p>All the open files in the system are kept in a global file table, the ftable.</blockquote><blockquote><p>The functions sys_link and sys_unlink edit directories, creating or removing references to inodes. They are another good example of the power of using transactions.</blockquote><h2 id=练习-6>练习</h2><h1 id=附录>附录</h1><h2 id=ch.1-unix-utilities实验代码>CH.1 Unix utilities实验代码</h2><h3 id=sleep-1>sleep</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/types.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"user/user.h"</span></span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span> *argv[])</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> seconds;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (argc &lt;= <span class=number>1</span>)</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>fprintf</span>(<span class=number>2</span>, <span class=string>"sleep: need one arg\n"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// ticks = 1/10 seconds</span></span><br><span class=line>    seconds = <span class=number>10</span> * atoi(argv[<span class=number>1</span>]);</span><br><span class=line>    <span class=keyword>if</span> (seconds &lt; <span class=number>0</span>)</span><br><span class=line>    {</span><br><span class=line>        seconds = <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    sleep(seconds);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=pingpong-1>pingpong</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/types.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"user/user.h"</span></span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span> *argv[])</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> p1[<span class=number>2</span>]; <span class=comment>// parent->child</span></span><br><span class=line>    <span class=type>int</span> p2[<span class=number>2</span>]; <span class=comment>// child->parent</span></span><br><span class=line>    pipe(p1);</span><br><span class=line>    pipe(p2);</span><br><span class=line>    <span class=keyword>if</span> (fork() == <span class=number>0</span>)</span><br><span class=line>    {</span><br><span class=line>        <span class=type>char</span> buffer[<span class=number>5</span>];</span><br><span class=line>        close(p1[<span class=number>1</span>]);</span><br><span class=line>        close(p2[<span class=number>0</span>]);</span><br><span class=line>        read(p1[<span class=number>0</span>], buffer, <span class=keyword>sizeof</span>(buffer));</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"%d: received %s\n"</span>, getpid(), buffer);</span><br><span class=line>        write(p2[<span class=number>1</span>], <span class=string>"pong"</span>, <span class=number>5</span>);</span><br><span class=line>        close(p1[<span class=number>0</span>]);</span><br><span class=line>        close(p2[<span class=number>1</span>]);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>else</span></span><br><span class=line>    {</span><br><span class=line>        <span class=type>char</span> buffer[<span class=number>5</span>];</span><br><span class=line>        close(p1[<span class=number>0</span>]);</span><br><span class=line>        close(p2[<span class=number>1</span>]);</span><br><span class=line>        write(p1[<span class=number>1</span>], <span class=string>"ping"</span>, <span class=number>5</span>);</span><br><span class=line>        read(p2[<span class=number>0</span>], buffer, <span class=keyword>sizeof</span>(buffer));</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"%d: received %s\n"</span>, getpid(), buffer);</span><br><span class=line>        close(p1[<span class=number>1</span>]);</span><br><span class=line>        close(p2[<span class=number>0</span>]);</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=primes-1>primes</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/types.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"user/user.h"</span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>define</span> MAX_NUMBER 35</span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>()</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> p0[<span class=number>2</span>]; <span class=comment>// parent->child</span></span><br><span class=line>    <span class=type>int</span> n, prime;</span><br><span class=line>    pipe(p0);</span><br><span class=line></span><br><span class=line>    <span class=comment>// feeds the numbers 2 through 35</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> i = <span class=number>2</span>; i &lt;= MAX_NUMBER; ++i)</span><br><span class=line>        write(p0[<span class=number>1</span>], &i, <span class=keyword>sizeof</span>(i));</span><br><span class=line></span><br><span class=line>    <span class=keyword>while</span> (read(p0[<span class=number>0</span>], &n, <span class=keyword>sizeof</span>(n)))</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"%d prime %d\n"</span>, getpid(), n);</span><br><span class=line>        prime = n;</span><br><span class=line>        <span class=type>int</span> p1[<span class=number>2</span>]; <span class=comment>// child -> grandchild</span></span><br><span class=line>        pipe(p1);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (fork() == <span class=number>0</span>)</span><br><span class=line>        {</span><br><span class=line>            <span class=comment>// child</span></span><br><span class=line>            close(p0[<span class=number>0</span>]);</span><br><span class=line>            close(p0[<span class=number>1</span>]);</span><br><span class=line>            p0[<span class=number>0</span>] = p1[<span class=number>0</span>];</span><br><span class=line>            p0[<span class=number>1</span>] = p1[<span class=number>1</span>];</span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>else</span></span><br><span class=line>        {</span><br><span class=line>            <span class=comment>// parent</span></span><br><span class=line>            <span class=keyword>while</span> (n &lt; MAX_NUMBER && read(p0[<span class=number>0</span>], &n, <span class=keyword>sizeof</span>(n)))</span><br><span class=line>                <span class=keyword>if</span> (n % prime != <span class=number>0</span>)</span><br><span class=line>                    write(p1[<span class=number>1</span>], &n, <span class=keyword>sizeof</span>(n));</span><br><span class=line></span><br><span class=line>            <span class=comment>// close all resources</span></span><br><span class=line>            close(p0[<span class=number>0</span>]);</span><br><span class=line>            close(p0[<span class=number>1</span>]);</span><br><span class=line>            close(p1[<span class=number>0</span>]);</span><br><span class=line>            close(p1[<span class=number>1</span>]);</span><br><span class=line>            <span class=comment>// wait children</span></span><br><span class=line>            <span class=keyword>if</span> (n &lt; MAX_NUMBER)</span><br><span class=line>                wait(<span class=number>0</span>);</span><br><span class=line>            <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    wait(<span class=number>0</span>);</span><br><span class=line>    <span class=built_in>printf</span>(<span class=string>"%d exit\n"</span>, getpid());</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=find-1>find</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/types.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"user/user.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/fs.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/stat.h"</span></span></span><br><span class=line></span><br><span class=line><span class=type>void</span> <span class="title function_">cmp_file</span><span class=params>(<span class=type>char</span> *path, <span class=type>char</span> *name)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>char</span> *str1, *str2;</span><br><span class=line>    <span class=keyword>for</span> (str1 = path + <span class=built_in>strlen</span>(path), str2 = name + <span class=built_in>strlen</span>(name); str1 >= path && str2 >= name && *str1 == *str2; --str1, --str2)</span><br><span class=line>        ; <span class=comment>// printf("%c %c\n", *str1, *str2);</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> ((<span class=type>int</span>)(str2 - name) == <span class=number>-1</span>)</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"%s\n"</span>, path);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=type>void</span> <span class="title function_">find</span><span class=params>(<span class=type>char</span> *path, <span class=type>char</span> *patern)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> fd;</span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>dirent</span> <span class=title>de</span>;</span></span><br><span class=line>    <span class=class><span class=keyword>struct</span> <span class=title>stat</span> <span class=title>st</span>;</span></span><br><span class=line>    <span class=type>char</span> buf[<span class=number>512</span>], *p;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> ((fd = open(path, <span class=number>0</span>)) &lt; <span class=number>0</span>)</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>fprintf</span>(<span class=number>2</span>, <span class=string>"find: connot open %s\n"</span>, path);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (fstat(fd, &st) &lt; <span class=number>0</span>)</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>fprintf</span>(<span class=number>2</span>, <span class=string>"find: connot stat %s\n"</span>, path);</span><br><span class=line>        close(fd);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>switch</span> (st.type)</span><br><span class=line>    {</span><br><span class=line>    <span class=keyword>case</span> T_DEVICE:</span><br><span class=line>    <span class=keyword>case</span> T_FILE:</span><br><span class=line>        cmp_file(path, patern);</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>case</span> T_DIR:</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>strlen</span>(path) + <span class=number>1</span> + DIRSIZ + <span class=number>1</span> > <span class=keyword>sizeof</span>(buf))</span><br><span class=line>        {</span><br><span class=line>            <span class=built_in>printf</span>(<span class=string>"find: path too long\n"</span>);</span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=built_in>strcpy</span>(buf, path);</span><br><span class=line>        p = buf + <span class=built_in>strlen</span>(buf);</span><br><span class=line>        <span class=keyword>if</span> (*(p - <span class=number>1</span>) != <span class=string>'/'</span>)</span><br><span class=line>            *p++ = <span class=string>'/'</span>;</span><br><span class=line>        <span class=keyword>while</span> (read(fd, &de, <span class=keyword>sizeof</span>(de)) == <span class=keyword>sizeof</span>(de))</span><br><span class=line>        {</span><br><span class=line>            <span class=keyword>if</span> (de.inum == <span class=number>0</span> || <span class=built_in>strcmp</span>(<span class=string>"."</span>, de.name) == <span class=number>0</span> || <span class=built_in>strcmp</span>(<span class=string>".."</span>, de.name) == <span class=number>0</span>)</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            memmove(p, de.name, DIRSIZ);</span><br><span class=line>            p[DIRSIZ] = <span class=number>0</span>;</span><br><span class=line>            find(buf, patern);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    close(fd);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span> *argv[])</span></span><br><span class=line>{</span><br><span class=line>    <span class=keyword>if</span> (argc &lt;= <span class=number>2</span>)</span><br><span class=line>    {</span><br><span class=line>        <span class=built_in>fprintf</span>(<span class=number>2</span>, <span class=string>"find: need more args\n"</span>);</span><br><span class=line>        <span class=built_in>exit</span>(<span class=number>-1</span>);</span><br><span class=line>    }</span><br><span class=line>    find(argv[<span class=number>1</span>], argv[<span class=number>2</span>]);</span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h3 id=xargs-1>xargs</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/types.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"kernel/param.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"user/user.h"</span></span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span> *argv[])</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>char</span> buffer[<span class=number>512</span>];</span><br><span class=line>    <span class=type>char</span> *newarg[MAXARG];</span><br><span class=line>    <span class=type>int</span> i;</span><br><span class=line>    <span class=type>int</span> new_idx;</span><br><span class=line>    <span class=keyword>for</span> (i = <span class=number>1</span>, new_idx = <span class=number>0</span>; i &lt; argc; ++i)</span><br><span class=line>        <span class=keyword>if</span> (argv[i][<span class=number>0</span>] == <span class=string>'-'</span>)</span><br><span class=line>            i += <span class=number>1</span>;</span><br><span class=line>        <span class=keyword>else</span></span><br><span class=line>            newarg[new_idx++] = argv[i];</span><br><span class=line>    <span class=keyword>while</span> (*gets(buffer, <span class=keyword>sizeof</span>(buffer)) != <span class=string>'\0'</span>)</span><br><span class=line>    {</span><br><span class=line>        buffer[<span class=built_in>strlen</span>(buffer) - <span class=number>1</span>] = <span class=string>'\0'</span>;</span><br><span class=line>        newarg[new_idx] = buffer;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (fork() == <span class=number>0</span>)</span><br><span class=line>        {</span><br><span class=line>            exec(newarg[<span class=number>0</span>], newarg);</span><br><span class=line>            <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>        }</span><br><span class=line>        wait(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=built_in>exit</span>(<span class=number>0</span>);</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><h2 id=ch.2-system-calls实验代码>CH.2 system calls实验代码</h2></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/24/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/24/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ itemprop=url>GDB使用说明</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-24 09:05:01" datetime=2024-04-24T09:05:01+08:00>2024-04-24</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/GDB/ itemprop=url rel=index><span itemprop=name>GDB</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>1.1k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>4 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=gdb-常用命令>GDB-常用命令</h1><p>打开GDB调试开关命令：<code>set debug remote 1</code><h1 id=gdb-远程序列化协议>GDB-远程序列化协议</h1><h2 id=简介>简介</h2><p>所有GDB命令和响应都是以包（packet）形式进行送。一个包的基本结构：<code>$包数据#2字节校验和</code><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$packet-data#checksum</span><br></pre></table></figure><p>2字节校验和是计算<code>$</code>和<code>#</code>之间的所有字符数值和，并取模256后的两位十六进制数。<p>GDB 5.0之前的协议需要包含两字节序列编号<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$sequence-id:packet-data#checksum</span><br></pre></table></figure><p>当主机或目标机接收到第一个包，预期的一个响应是确认：可以是<code>+</code>（表明包接收正确）或<code>-</code>（请求重传）<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>-> $packet-data#checksum</span><br><span class=line>&lt;- +</span><br></pre></table></figure><p>连接一旦建立，可以禁用<code>+</code>/<code>-</code>确认。<p>主机（GDB）发送命令，而目标机（调试目标）发送响应。<p>包数据不能包含非法字符<code>#</code>和<code>$</code>。<p>若包数据中可以使用<code>,</code> <code>;</code> 或<code>:</code>作为分隔符。除特别说明，所有数字均使用十六进制表示。<p>GDB 5.0之前的协议不能使用<code>:</code>作为分隔符（与sequence-id的分隔符冲突）。<p>在许多包中二进制数据都以两位十六进制字符表示。<p>二进制数据<code>7d</code>（ASCII字符<code>}</code>)作为转义字符。任何转义字符传输时需要跟一个与<code>0x20</code>异或后的结果。例如，单字节<code>0x7d</code>在传输时会转为两个字节<code>0x7d 0x5d</code>。常见的转义字符有<code>0x23 #</code> <code>0x24 $</code> <code>0x7d }</code> <code>0x2a *</code>。<p>响应数据可以使用运行长度编号来节省空间。例如：编号后<code>'0* '</code> 表示编码字符串<code>'0000'</code>，<code>*</code>后面的空格表示重复<code>0</code>字符32-29=3次。<p>对于可打印字符<code>#</code>和<code>$</code>或数值超过126的都不可使用。对于7次重复（字符<code>$</code>）可以使用5次（字符<code>"</code>）来分开表示。例如，<code>'00000000'</code>编码后为<code>'0*"00'</code>。<p>对于不支持的命令，会返回空响应<code>$#00</code>。<p>在最小场景中，目标机必须支持<code>?</code>命令来告诉GDB停止的原因，<code>g</code>和<code>G</code>命令用于寄存器访问，<code>m</code>和<code>M</code>命令用于内存访问。对于单线程目标要实现<code>c</code>命令，并支持单步调试命令<code>s</code>。多线程目标需要支持<code>vCont</code>命令。其他所有命令都是可选的。<h2 id=包>包</h2><p>下表中，命令中的空格表示语义分隔，但实际数据包不需要发送。<table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class=header><th>命令<th>说明<tbody><tr class=odd><td>!<td>使能扩展模式<tr class=even><td>?<td>当连接第一次建立后，会被询问目标机停止的原因。回复与step和continue一样。<tr class=odd><td>A arglen,argnum,arg,…<td>初始化<code>argv[]</code>参数数组传递给程序。其中arglen是十六进制编码后的字节流参数arg的长度。<tr class=even><td>b baud<td>（不推荐使用）改变串行通信速率<tr class=odd><td>B addr,mode<td>（不推荐使用，使用Z和z包替代）设置(mode是S)或清除（mode是C）在addr处的断点。<tr class=even><td>bc<td>向后继续执行。目标系统反向执行。<tr class=odd><td>bs<td>向后单步执行。反向执行一条执行。<tr class=even><td>c [addr]<td>从addr处继续执行；addr省略时，从当前地址继续。<tr class=odd><td>C sig[;addr]<td>与c命令一样，额外可携带一个信号量sig（十六进制数）<tr class=even><td>d<td>（不推荐使用）其他调试标志<tr class=odd><td>D<br>D;pid<td>通知远端目标机GDB断开连接。第二种包含进程编号，只对特定的进程生效。<tr class=even><td>F RC,EE,CF;XX<td>文件I/O扩展协议命令<tr class=odd><td>g<td>读取通用寄存器<br>回复：‘XX…’<br>寄存器每个字节由两个十六进制表示。当目标寄存器不可用时，会使用字符<code>x</code>进行占位。<tr class=even><td>G XX…<td>写通用寄存器<tr class=odd><td>z0,addr,kind<br>Z0,addr,kind<br>[;con_list…]<br>[;cmds:persis,cmd_list]<td>插入（Z0）或移除（z0）在addr处kind类型的一个软件断点<tr class=even><td>z1,addr,kind<br>Z1,addr,kind<br>[;con_list…]<br>[;cmds:persis,cmd_list]<td>插入（Z1）或移除（z1）在addr处kind类型的一个硬件断点<tr class=odd><td>z2,addr,kind<br>Z2,addr,kind<td>插入（Z2）或移除（z2）在addr处的一个写监控点。监控的字节数由kind指定<tr class=even><td>z3,addr,kind<br>Z3,addr,kind<td>插入（Z3）或移除（z3）在addr处的一个读监控点。监控的字节数由kind指定<tr class=odd><td>z4,addr,kind<br>Z4,addr,kind<td>插入（Z4）或移除（z4）在addr处的一个访问监控点。监控的字节数由kind指定<tr class=even><td>…<td></table><h2 id=停止回复包>停止回复包</h2><h2 id=通用包>通用包</h2><p>以<code>q</code>开头的是通用询问包；以<code>Q</code>开头的是通用设置包；<h2 id=参考>参考</h2><p>详见<a href=https://sourceware.org/gdb/download/onlinedocs/ rel=noopener target=_blank>官方文档</a> Appendix E gdb Remote Serial Protocol章节</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/08/Verilog-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/08/Verilog-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/ itemprop=url>Verilog-硬件描述语言使用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-08 11:34:41" datetime=2024-04-08T11:34:41+08:00>2024-04-08</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E7%A1%AC%E4%BB%B6/ itemprop=url rel=index><span itemprop=name>硬件</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>5k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>18 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=语言简介>语言简介</h1><p>Verilog在线学习<a href=https://hdlbits.01xz.net/wiki/Main_Page rel=noopener target=_blank>HDLBits主页</a><h2 id=基本语句>基本语句</h2><h3 id=常量>常量</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>3'b101 	// binary 101</span><br><span class=line>4'hf 	// binary 1111</span><br><span class=line>4'd10	// binary 1010</span><br></pre></table></figure><h3 id=线wire>线wire</h3><p>物理线路没有方向，但建模上需要指定方向。<p>创造一个模型，有三个输入和四个输出<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>a -> w</span><br><span class=line>b -> x</span><br><span class=line>b -> y</span><br><span class=line>c -> z</span><br></pre></table></figure><p><img src=https://hdlbits.01xz.net/mw/images/1/15/Wire4.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input a,b,c,</span><br><span class=line>    output w,x,y,z );</span><br><span class=line>    </span><br><span class=line>    assign w=a;</span><br><span class=line>    assign x=b;</span><br><span class=line>    assign y=b;</span><br><span class=line>    assign z=c;</span><br><span class=line></span><br><span class=line>	// If we're certain about the width of each signal, using </span><br><span class=line>	// the concatenation operator is equivalent and shorter:</span><br><span class=line>	// assign {w,x,y,z} = {a,b,b,c};</span><br><span class=line></span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=非门inverter>非门Inverter</h3><p>电路中产生一个非门<p><img src=https://hdlbits.01xz.net/mw/images/9/9e/Notgate.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>module top_module( input in, output out );</span><br><span class=line>	assign out = !in;</span><br><span class=line>	// similar</span><br><span class=line>	// 	assign out = ~in;</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=与门and-gate>与门AND gate</h3><p>电路中产生一个与门<p><img src=https://hdlbits.01xz.net/mw/images/7/78/Andgate.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input a, </span><br><span class=line>    input b, </span><br><span class=line>    output out );</span><br><span class=line></span><br><span class=line>    assign out = a & b;</span><br><span class=line>    </span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=或非门nor-gate>或非门Nor gate</h3><p>电路中产生一个或非门<p><img src=https://hdlbits.01xz.net/mw/images/5/5b/Norgate.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input a, </span><br><span class=line>    input b, </span><br><span class=line>    output out );</span><br><span class=line></span><br><span class=line>    assign out = ~(a | b);</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=异或非门xnor-gate>异或非门XNOR gate</h3><p>电路中产生一个异或非门<p><img src=https://hdlbits.01xz.net/mw/images/6/6d/Xnorgate.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input a, </span><br><span class=line>    input b, </span><br><span class=line>    output out );</span><br><span class=line></span><br><span class=line>    assign out = ~(a ^ b);</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=声明线declaring-wires>声明线Declaring wires</h3><p><img src=https://hdlbits.01xz.net/mw/images/3/3a/Wiredecl2.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>`default_nettype none</span><br><span class=line>module top_module(</span><br><span class=line>    input a,</span><br><span class=line>    input b,</span><br><span class=line>    input c,</span><br><span class=line>    input d,</span><br><span class=line>    output out,</span><br><span class=line>    output out_n   ); </span><br><span class=line></span><br><span class=line>    wire w1, w2, w3;    </span><br><span class=line>    assign out = w3;</span><br><span class=line>    assign out_n = ~w3;</span><br><span class=line>  </span><br><span class=line>    assign w3 = w1 | w2;</span><br><span class=line>    assign w1 = a & b;</span><br><span class=line>    assign w2 = c & d;</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=芯片>7458芯片</h3><p><img src=https://hdlbits.01xz.net/mw/images/e/e1/7458.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>module top_module ( </span><br><span class=line>    input p1a, p1b, p1c, p1d, p1e, p1f,</span><br><span class=line>    output p1y,</span><br><span class=line>    input p2a, p2b, p2c, p2d,</span><br><span class=line>    output p2y );</span><br><span class=line></span><br><span class=line>	wire wp11,wp12;</span><br><span class=line>    assign p1y = wp11 | wp12;</span><br><span class=line>    assign wp11 = p1a & p1b & p1c;</span><br><span class=line>    assign wp12 = p1f & p1e & p1d;</span><br><span class=line>    </span><br><span class=line>    wire wp21,wp22;</span><br><span class=line>    assign p2y = wp21 | wp22;</span><br><span class=line>    assign wp21 = p2a & p2b;</span><br><span class=line>    assign wp22 = p2c & p2d;</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h2 id=向量vector>向量Vector</h2><h3 id=基本使用>基本使用</h3><p>声明语法：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>type [upper:lower] vector_name;</span><br></pre></table></figure><p>类型可以是wire, reg等等<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>wire [7:0] w;         // 8-bit wire</span><br><span class=line>reg  [4:1] x;         // 4-bit reg</span><br><span class=line>output reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)</span><br><span class=line>input wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)</span><br><span class=line>output [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.</span><br><span class=line>wire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.</span><br></pre></table></figure><p>隐含声明可能导致意想不到的结果<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>wire [2:0] a, c;   // Two vectors</span><br><span class=line>assign a = 3'b101;  // a = 101</span><br><span class=line>assign b = a;       // b =   1  implicitly-created wire</span><br><span class=line>assign c = b;       // c = 001  &lt;-- bug</span><br><span class=line>my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.</span><br><span class=line>                    // This could be a bug if the port was intended to be a </span><br></pre></table></figure><p>unpacked数组维度跟在名称后，packed数组维度放在名称前<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>reg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.</span><br><span class=line>reg mem2 [28:0];         // 29 unpacked elements, each of which is a 1-bit reg.</span><br></pre></table></figure><p>描绘如下电路<p><img src=https://hdlbits.01xz.net/mw/images/a/ae/Vector0.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>module top_module ( </span><br><span class=line>    input wire [2:0] vec,</span><br><span class=line>    output wire [2:0] outv,</span><br><span class=line>    output wire o2,</span><br><span class=line>    output wire o1,</span><br><span class=line>    output wire o0  ); // Module body starts after module declaration</span><br><span class=line></span><br><span class=line>    assign {o2,o1,o0} = vec[2:0];</span><br><span class=line>    assign outv = vec;</span><br><span class=line>    </span><br><span class=line>    // This is ok too</span><br><span class=line>   	//assign o0 = vec[0];</span><br><span class=line>	//assign o1 = vec[1];</span><br><span class=line>	//assign o2 = vec[2];</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><p>将字数据（2字节）按高低位分离<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>`default_nettype none     // Disable implicit nets. Reduces some types of bugs.</span><br><span class=line>module top_module( </span><br><span class=line>    input wire [15:0] in,</span><br><span class=line>    output wire [7:0] out_hi,</span><br><span class=line>    output wire [7:0] out_lo );</span><br><span class=line></span><br><span class=line>    assign out_hi = in[15:8];</span><br><span class=line>    assign out_lo = in[7:0];</span><br><span class=line>    </span><br><span class=line>    // Concatenation operator also works: assign {out_hi, out_lo} = in;</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=向量门>向量门</h3><p>按位与<code>&</code>和逻辑与<code>&</code>对于N-bit位输入来说，会产生不同结果。前者会产生N-bit位输出，而后者只产生1-bit位输出（作为布尔值，非0值为true，0值为false）。<p>描绘如下电路，<code>out_not</code>高5-3位为<code>b</code>的非，其余为<code>a</code>的非。<p><img src=https://hdlbits.01xz.net/mw/images/1/1b/Vectorgates.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input [2:0] a,</span><br><span class=line>    input [2:0] b,</span><br><span class=line>    output [2:0] out_or_bitwise,</span><br><span class=line>    output out_or_logical,</span><br><span class=line>    output [5:0] out_not</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>    assign out_or_bitwise = a | b;</span><br><span class=line>    assign out_or_logical = a || b;</span><br><span class=line>    // ! is logical inverse</span><br><span class=line>    assign out_not = {~b, ~a};</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=颠倒8位>颠倒8位</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input [7:0] in,</span><br><span class=line>	output [7:0] out</span><br><span class=line>);</span><br><span class=line>	assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};</span><br><span class=line>	//assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;</span><br><span class=line>	</span><br><span class=line>	/*</span><br><span class=line>	// I know you're dying to know how to use a loop to do this:</span><br><span class=line></span><br><span class=line>	// Create a combinational always block. This creates combinational logic that computes the same result</span><br><span class=line>	// as sequential code. for-loops describe circuit *behaviour*, not *structure*, so they can only be used </span><br><span class=line>	// inside procedural blocks (e.g., always block).</span><br><span class=line>	// The circuit created (wires and gates) does NOT do any iteration: It only produces the same result</span><br><span class=line>	// AS IF the iteration occurred. In reality, a logic synthesizer will do the iteration at compile time to</span><br><span class=line>	// figure out what circuit to produce. (In contrast, a Verilog simulator will execute the loop sequentially</span><br><span class=line>	// during simulation.)</span><br><span class=line>	always @(*) begin	</span><br><span class=line>		for (int i=0; i&lt;8; i++)	// int is a SystemVerilog type. Use integer for pure Verilog.</span><br><span class=line>			out[i] = in[8-i-1];</span><br><span class=line>	end</span><br><span class=line></span><br><span class=line></span><br><span class=line>	// It is also possible to do this with a generate-for loop. Generate loops look like procedural for loops,</span><br><span class=line>	// but are quite different in concept, and not easy to understand. Generate loops are used to make instantiations</span><br><span class=line>	// of "things" (Unlike procedural loops, it doesn't describe actions). These "things" are assign statements,</span><br><span class=line>	// module instantiations, net/variable declarations, and procedural blocks (things you can create when NOT inside </span><br><span class=line>	// a procedure). Generate loops (and genvars) are evaluated entirely at compile time. You can think of generate</span><br><span class=line>	// blocks as a form of preprocessing to generate more code, which is then run though the logic synthesizer.</span><br><span class=line>	// In the example below, the generate-for loop first creates 8 assign statements at compile time, which is then</span><br><span class=line>	// synthesized.</span><br><span class=line>	// Note that because of its intended usage (generating code at compile time), there are some restrictions</span><br><span class=line>	// on how you use them. Examples: 1. Quartus requires a generate-for loop to have a named begin-end block</span><br><span class=line>	// attached (in this example, named "my_block_name"). 2. Inside the loop body, genvars are read only.</span><br><span class=line>	generate</span><br><span class=line>		genvar i;</span><br><span class=line>		for (i=0; i&lt;8; i = i+1) begin: my_block_name</span><br><span class=line>			assign out[i] = in[8-i-1];</span><br><span class=line>		end</span><br><span class=line>	endgenerate</span><br><span class=line>	*/</span><br><span class=line>	</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=重复操作>重复操作</h3><p>声明语法：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>{num{vector}}</span><br></pre></table></figure><p>示例<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)</span><br><span class=line>{2{a,b,c}}          // The same as {a,b,c,a,b,c}</span><br><span class=line>{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with</span><br><span class=line>                    // the second vector, which is two copies of 3'b110.</span><br></pre></table></figure><p>将8位数据扩展为32位，高24位为符号位（bit[7]），余下8位为输入<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input [7:0] in,</span><br><span class=line>	output [31:0] out</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	// Concatenate two things together:</span><br><span class=line>	// 1: {in[7]} repeated 24 times (24 bits)</span><br><span class=line>	// 2: in[7:0] (8 bits)</span><br><span class=line>	assign out = { {24{in[7]}}, in };</span><br><span class=line>	</span><br><span class=line>endmodule</span><br></pre></table></figure><p>描述电路<p><img src=https://hdlbits.01xz.net/mw/images/a/ac/Vector5.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input a, b, c, d, e,</span><br><span class=line>	output [24:0] out</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	wire [24:0] top, bottom;</span><br><span class=line>	assign top    = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };</span><br><span class=line>	assign bottom = {5{a,b,c,d,e}};</span><br><span class=line>	assign out = ~top ^ bottom;	// Bitwise XNOR</span><br><span class=line></span><br><span class=line>	// This could be done on one line:</span><br><span class=line>	// assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};</span><br><span class=line>	</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h2 id=模块module>模块Module</h2><h3 id=基本使用-1>基本使用</h3><p>基本语法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>module mod_a ( input in1, input in2, output out );</span><br><span class=line>    // Module body</span><br><span class=line>endmodule</span><br></pre></table></figure><p>线与模块端口连接有两种方式：通过位置和通过名称<p>通过位置连接，模块实例<code>instance1</code>三个端口分别连接线<code>wa</code>, <code>wb</code>, <code>wc</code>：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>mod_a instance1 ( wa, wb, wc );</span><br></pre></table></figure><p>通过名称连接，模块实例<code>instance2</code>三个端口名称与对应线连接：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );</span><br></pre></table></figure><p>描述电路，其中模块<code>mod_a</code>在其他地方描述<p><img src=https://hdlbits.01xz.net/mw/images/c/c0/Module.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input a,</span><br><span class=line>	input b,</span><br><span class=line>	output out</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	// Create an instance of "mod_a" named "inst1", and connect ports by name:</span><br><span class=line>	mod_a inst1 ( </span><br><span class=line>		.in1(a), 	// Port"in1"connects to wire "a"</span><br><span class=line>		.in2(b),	// Port "in2" connects to wire "b"</span><br><span class=line>		.out(out)	// Port "out" connects to wire "out" </span><br><span class=line>				// (Note: mod_a's port "out" is not related to top_module's wire "out". </span><br><span class=line>				// It is simply coincidence that they have the same name)</span><br><span class=line>	);</span><br><span class=line></span><br><span class=line>/*</span><br><span class=line>	// Create an instance of "mod_a" named "inst2", and connect ports by position:</span><br><span class=line>	mod_a inst2 ( a, b, out );	// The three wires are connected to ports in1, in2, and out, respectively.</span><br><span class=line>*/</span><br><span class=line>	</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=移位模块>移位模块</h3><p>给已经实现的D触发器（D flip-flop）模块<code>module my_dff ( input clk, input d, output q );</code>，按下图描述电路<p><img src=https://hdlbits.01xz.net/mw/images/6/60/Module_shift.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>module top_module ( input clk, input d, output q );</span><br><span class=line>    wire q1,q2;</span><br><span class=line>    </span><br><span class=line>    my_dff d1 (clk, d, q1);</span><br><span class=line>    my_dff d2 (clk, q1, q2);</span><br><span class=line>    my_dff d3 (clk, q2, q);</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=位移位器>8位移位器</h3><p>描绘电路<p><img src=https://hdlbits.01xz.net/mw/images/7/76/Module_shift8.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input clk,</span><br><span class=line>	input [7:0] d,</span><br><span class=line>	input [1:0] sel,</span><br><span class=line>	output reg [7:0] q</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	wire [7:0] o1, o2, o3;		// output of each my_dff8</span><br><span class=line>	</span><br><span class=line>	// Instantiate three my_dff8s</span><br><span class=line>	my_dff8 d1 ( clk, d, o1 );</span><br><span class=line>	my_dff8 d2 ( clk, o1, o2 );</span><br><span class=line>	my_dff8 d3 ( clk, o2, o3 );</span><br><span class=line></span><br><span class=line>	// This is one way to make a 4-to-1 multiplexer</span><br><span class=line>	always @(*) begin		// Combinational always block</span><br><span class=line>		case(sel)</span><br><span class=line>			2'h0: q = d;</span><br><span class=line>			2'h1: q = o1;</span><br><span class=line>			2'h2: q = o2;</span><br><span class=line>			2'h3: q = o3;</span><br><span class=line>		endcase</span><br><span class=line>	end</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=全加器>全加器</h3><p>add16全加器已经定义<code>module add16 ( input[15:0] **a**, input[15:0] **b**, input **cin**, output[15:0] **sum**, output **cout** );</code>，它包含16个add1全加器，描述电路<p><img src=https://hdlbits.01xz.net/mw/images/f/f3/Module_fadd.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>    input [31:0] a,</span><br><span class=line>    input [31:0] b,</span><br><span class=line>    output [31:0] sum</span><br><span class=line>);</span><br><span class=line>	wire o1,o2;</span><br><span class=line>    </span><br><span class=line>    add16 inst1(a[15:0],b[15:0],0,sum[15:0],o1);</span><br><span class=line>    add16 inst2(a[31:16],b[31:16],o1,sum[31:16],o2);</span><br><span class=line>endmodule</span><br><span class=line></span><br><span class=line>module add1 ( input a, input b, input cin,   output sum, output cout );</span><br><span class=line>// Full adder module here</span><br><span class=line>    assign sum = cin ? ~(a^b) : a^b;</span><br><span class=line>    assign cout = cin ? a|b : a&b;</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=加减器>加减器</h3><p>减法器由全加器变化而来，只需将对第二个操作数取补码即可（反码加一）。等效的电路可以有两种效果：<code>a+b+0</code>和<code>a+~b+1</code>。<p><img src=https://hdlbits.01xz.net/mw/images/a/ae/Module_addsub.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>module top_module(</span><br><span class=line>    input [31:0] a,</span><br><span class=line>    input [31:0] b,</span><br><span class=line>    input sub,</span><br><span class=line>    output [31:0] sum</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>    wire o1,o2;</span><br><span class=line>    wire [31:0] b1 = b^{32{sub}};</span><br><span class=line>    </span><br><span class=line>    add16 inst1(a[15:0],b1[15:0],sub,sum[15:0],o1);</span><br><span class=line>    add16 inst2(a[31:16],b1[31:16],o1,sum[31:16],o2);</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h2 id=过程procedure>过程Procedure</h2><p>对于综合硬件，有两种相关always块：<ul><li>组合型：<code>always @(*)</code><li>时序型：<code>always @(posedge clk)</code></ul><p>块语句需要使用<code>begin</code>和<code>end</code>标记出来，若语句只有“单句”时，块标记可以省略。<h3 id=always块>Always块</h3><p>对于简单的场景，组合型always块等价于assign语句。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>assign out1 = a & b | c ^ d;</span><br><span class=line>always @(*) out2 = a & b | c ^ d;</span><br></pre></table></figure><p>assign语句左边符号对应的类型是net（例如：wire），而过程赋值对应的类型是variable（例如：reg）。两者的差异不会对综合的电路产生任何影响，只是一种不成文的约定。<p>在VHDL中有三种赋值类型：<ul><li>持续赋值<code>assign x = y;</code><li>过程阻塞赋值，在过程中使用<code>x = y;</code><li>过程非阻塞赋值，在过程中使用<code>x &lt;= y;</code></ul><p>在组合alsways块中，使用阻塞赋值。在时序always块中，使用非阻塞赋值。<p>使用三种方式，用异或门构建电路。值得注意的是，第三种方式产生的结果会因为有触发器而产生延时。<p><img src=https://hdlbits.01xz.net/mw/images/4/40/Alwaysff.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module(</span><br><span class=line>    input clk,</span><br><span class=line>    input a,</span><br><span class=line>    input b,</span><br><span class=line>    output wire out_assign,</span><br><span class=line>    output reg out_always_comb,</span><br><span class=line>    output reg out_always_ff   );</span><br><span class=line></span><br><span class=line>    assign out_assign = a^b;</span><br><span class=line>    always @(*) out_always_comb = a^b;</span><br><span class=line>    always @(posedge clk) out_always_ff &lt;= a^b;</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=if语句>if语句</h3><p>描绘一个2-1选择器<p><img src=https://hdlbits.01xz.net/mw/images/9/9d/Always_if_mux.png><p>对应的值表<table><thead><tr class=header><th style="text-align: left;">sel_b1<th style="text-align: left;">sel_b2<th style="text-align: left;">out_assign out_always<tbody><tr class=odd><td style="text-align: left;">0<td style="text-align: left;">0<td style="text-align: left;">a<tr class=even><td style="text-align: left;">0<td style="text-align: left;">1<td style="text-align: left;">a<tr class=odd><td style="text-align: left;">1<td style="text-align: left;">0<td style="text-align: left;">a<tr class=even><td style="text-align: left;">1<td style="text-align: left;">1<td style="text-align: left;">b</table><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module(</span><br><span class=line>    input a,</span><br><span class=line>    input b,</span><br><span class=line>    input sel_b1,</span><br><span class=line>    input sel_b2,</span><br><span class=line>    output wire out_assign,</span><br><span class=line>    output reg out_always   ); </span><br><span class=line></span><br><span class=line>    assign out_assign = sel_b1&sel_b2 ? b : a;</span><br><span class=line>    </span><br><span class=line>    always @(*) begin</span><br><span class=line>        if (sel_b1&sel_b2) begin</span><br><span class=line>            out_always = b;</span><br><span class=line>        end</span><br><span class=line>        else begin</span><br><span class=line>            out_always = a;</span><br><span class=line>        end</span><br><span class=line>    end</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=if语句锁存>if语句锁存</h3><p>修复下图错误，当<code>cpu_overheated</code>时，产生关闭信号（<code>shut_off_computer</code>设置为1）。<p>修改前，错误的示意图<p><img src=https://hdlbits.01xz.net/mw/images/d/d1/Always_if2.png><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module (</span><br><span class=line>    input      cpu_overheated,</span><br><span class=line>    output reg shut_off_computer,</span><br><span class=line>    input      arrived,</span><br><span class=line>    input      gas_tank_empty,</span><br><span class=line>    output reg keep_driving  ); //</span><br><span class=line></span><br><span class=line>    always @(*) begin</span><br><span class=line>        if (cpu_overheated)</span><br><span class=line>           shut_off_computer = 1;</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>    always @(*) begin</span><br><span class=line>        if (~arrived)</span><br><span class=line>           keep_driving = ~gas_tank_empty;</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><p>修改后<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module (</span><br><span class=line>    input      cpu_overheated,</span><br><span class=line>    output reg shut_off_computer,</span><br><span class=line>    input      arrived,</span><br><span class=line>    input      gas_tank_empty,</span><br><span class=line>    output reg keep_driving  ); //</span><br><span class=line></span><br><span class=line>    always @(*) begin</span><br><span class=line>        if (cpu_overheated)</span><br><span class=line>           shut_off_computer = 1;</span><br><span class=line>        else</span><br><span class=line>           shut_off_computer = 0;</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>    always @(*) begin</span><br><span class=line>        if (~arrived)</span><br><span class=line>           keep_driving = ~gas_tank_empty;</span><br><span class=line>        else</span><br><span class=line>           keep_driving = 0;</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=case语句>case语句</h3><p>基本语法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>case (cond)</span><br><span class=line>	2'h0: statments0;</span><br><span class=line>	2'h1: statments1;</span><br><span class=line>	...</span><br><span class=line>	default: statmentsx;</span><br><span class=line>endcase</span><br></pre></table></figure><p>建立一个6-1选择器，否则输出0<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module ( </span><br><span class=line>    input [2:0] sel, </span><br><span class=line>    input [3:0] data0,</span><br><span class=line>    input [3:0] data1,</span><br><span class=line>    input [3:0] data2,</span><br><span class=line>    input [3:0] data3,</span><br><span class=line>    input [3:0] data4,</span><br><span class=line>    input [3:0] data5,</span><br><span class=line>    output reg [3:0] out   );//</span><br><span class=line></span><br><span class=line>    always@(*) begin  // This is a combinational circuit</span><br><span class=line>        case(sel)</span><br><span class=line>            4'h0: out = data0;</span><br><span class=line>            4'h1: out = data1;</span><br><span class=line>            4'h2: out = data2;</span><br><span class=line>            4'h3: out = data3;</span><br><span class=line>            4'h4: out = data4;</span><br><span class=line>            4'h5: out = data5;</span><br><span class=line>            default: out = 0;</span><br><span class=line>        endcase</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><p>构建一个4bits的优先编码器，输出第一个1所在的比特位。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input [3:0] in,</span><br><span class=line>	output reg [1:0] pos</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	always @(*) begin			// Combinational always block</span><br><span class=line>		case (in)</span><br><span class=line>			4'h0: pos = 2'h0;	// I like hexadecimal because it saves typing.</span><br><span class=line>			4'h1: pos = 2'h0;</span><br><span class=line>			4'h2: pos = 2'h1;</span><br><span class=line>			4'h3: pos = 2'h0;</span><br><span class=line>			4'h4: pos = 2'h2;</span><br><span class=line>			4'h5: pos = 2'h0;</span><br><span class=line>			4'h6: pos = 2'h1;</span><br><span class=line>			4'h7: pos = 2'h0;</span><br><span class=line>			4'h8: pos = 2'h3;</span><br><span class=line>			4'h9: pos = 2'h0;</span><br><span class=line>			4'ha: pos = 2'h1;</span><br><span class=line>			4'hb: pos = 2'h0;</span><br><span class=line>			4'hc: pos = 2'h2;</span><br><span class=line>			4'hd: pos = 2'h0;</span><br><span class=line>			4'he: pos = 2'h1;</span><br><span class=line>			4'hf: pos = 2'h0;</span><br><span class=line>			default: pos = 2'b0;	// Default case is not strictly necessary because all 16 combinations are covered.</span><br><span class=line>		endcase</span><br><span class=line>	end</span><br><span class=line>	</span><br><span class=line>	// There is an easier way to code this. See the next problem (always_casez).</span><br><span class=line>	</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=casez>casez</h3><p>当部分比特位不关心时，可以使用<code>casez</code>。符号<code>z</code>和<code>?</code>在一下场景都是等价的。与<code>casez</code>类似的是<code>casex</code>，后者使用符号<code>x</code>。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>always @(*) begin</span><br><span class=line>    casez (in[3:0])</span><br><span class=line>        4'bzzz1: out = 0;   // in[3:1] can be anything</span><br><span class=line>        4'bzz1z: out = 1;</span><br><span class=line>        4'b?1??: out = 2;</span><br><span class=line>        4'b1???: out = 3;</span><br><span class=line>        default: out = 0;</span><br><span class=line>    endcase</span><br><span class=line>end</span><br></pre></table></figure><p>构建8bits优先编码器<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module (</span><br><span class=line>    input [7:0] in,</span><br><span class=line>    output reg [2:0] pos );</span><br><span class=line>	</span><br><span class=line>    always @(*) begin</span><br><span class=line>        casez (in[7:0])</span><br><span class=line>            8'h0: pos = 0;</span><br><span class=line>            8'bzzzz_???1: pos = 0;</span><br><span class=line>            8'bzzzz_zz10: pos = 1;</span><br><span class=line>            8'bzzzz_z100: pos = 2;</span><br><span class=line>            8'bzzzz_1000: pos = 3;</span><br><span class=line>            8'bzzz1_0000: pos = 4;</span><br><span class=line>            8'bzz10_0000: pos = 5;</span><br><span class=line>            8'bz100_0000: pos = 6;</span><br><span class=line>            8'b1000_0000: pos = 7;</span><br><span class=line>            default: pos = 3'bzzz;</span><br><span class=line>        endcase</span><br><span class=line>    end</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=键盘扫描码>键盘扫描码</h3><p>处理如下四个按键<table><thead><tr class=header><th style="text-align: left;">Scancode [15:0]<th style="text-align: left;">Arrow key<tbody><tr class=odd><td style="text-align: left;"><code>16'he06b</code><td style="text-align: left;">left arrow<tr class=even><td style="text-align: left;"><code>16'he072</code><td style="text-align: left;">down arrow<tr class=odd><td style="text-align: left;"><code>16'he074</code><td style="text-align: left;">right arrow<tr class=even><td style="text-align: left;"><code>16'he075</code><td style="text-align: left;">up arrow<tr class=odd><td style="text-align: left;">Anything else<td style="text-align: left;">none</table><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>// synthesis verilog_input_version verilog_2001</span><br><span class=line>module top_module (</span><br><span class=line>    input [15:0] scancode,</span><br><span class=line>    output reg left,</span><br><span class=line>    output reg down,</span><br><span class=line>    output reg right,</span><br><span class=line>    output reg up  ); </span><br><span class=line></span><br><span class=line>    always @(*) begin</span><br><span class=line>        left = 0; down = 0; right = 0; up = 0;</span><br><span class=line>        case (scancode)</span><br><span class=line>            16'he06b: left = 1;</span><br><span class=line>            16'he072: down = 1;</span><br><span class=line>            16'he074: right = 1;</span><br><span class=line>            16'he075: up = 1;</span><br><span class=line>            default: ;</span><br><span class=line>        endcase</span><br><span class=line>    end</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h2 id=更多特性>更多特性</h2><h3 id=条件>条件</h3><p>三元条件操作符<code>?:</code><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>(condition ? if_true : if_false)</span><br></pre></table></figure><h3 id=逻辑操作简化>逻辑操作简化</h3><p>若需要对向量所有位进行门操作时，正常书写比较冗余，可以对与、或和异或操作简化<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>& a[3:0]     // AND: a[3]&a[2]&a[1]&a[0]. Equivalent to (a[3:0] == 4'hf)</span><br><span class=line>| b[3:0]     // OR:  b[3]|b[2]|b[1]|b[0]. Equivalent to (b[3:0] != 4'h0)</span><br><span class=line>^ c[2:0]     // XOR: c[2]^c[1]^c[0]</span><br></pre></table></figure><p>实现奇偶校验位算法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>    input [7:0] in,</span><br><span class=line>    output parity); </span><br><span class=line></span><br><span class=line>    assign parity = ^in[7:0];</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=bits翻转>100bits翻转</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input [99:0] in,</span><br><span class=line>	output reg [99:0] out</span><br><span class=line>);</span><br><span class=line>	</span><br><span class=line>	always @(*) begin</span><br><span class=line>		for (int i=0;i&lt;$bits(out);i++)		// $bits() is a system function that returns the width of a signal.</span><br><span class=line>			out[i] = in[$bits(out)-i-1];	// $bits(out) is 100 because out is 100 bits wide.</span><br><span class=line>	end</span><br><span class=line>	</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=比特1计数>比特1计数</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input [254:0] in,</span><br><span class=line>    output [7:0] out );</span><br><span class=line></span><br><span class=line>    always @(*) begin	// Combinational always block</span><br><span class=line>        out = 0;</span><br><span class=line>        for (int i=0; i&lt;$bits(in); i++)</span><br><span class=line>            out += in[i];</span><br><span class=line>    end</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h3 id=bits全加器>100bits全加器</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input [99:0] a, b,</span><br><span class=line>    input cin,</span><br><span class=line>    output [99:0] cout,</span><br><span class=line>    output [99:0] sum );</span><br><span class=line>    </span><br><span class=line>	genvar i;</span><br><span class=line>	generate</span><br><span class=line>	    for (i=0; i&lt;$bits(a); ++i) begin: adder_gen</span><br><span class=line>	        adder_1bit u_adder (</span><br><span class=line>	            .a(a[i]),</span><br><span class=line>	            .b(b[i]),</span><br><span class=line>	            .cin(i==0?cin:cout[i-1]),</span><br><span class=line>	            .sum(sum[i]),</span><br><span class=line>	            .cout(cout[i])</span><br><span class=line>	        );</span><br><span class=line>	    end</span><br><span class=line>	endgenerate</span><br><span class=line>    </span><br><span class=line>endmodule</span><br><span class=line></span><br><span class=line>module adder_1bit (</span><br><span class=line>    input a,b,</span><br><span class=line>    input cin,</span><br><span class=line>    output cout,</span><br><span class=line>    output sum</span><br><span class=line>);</span><br><span class=line>    assign {cout,sum} = a+b+cin;</span><br><span class=line>    // assign sum = cin ? ~(a^b) : a^b;</span><br><span class=line>    // assign cout = cin ? a|b : a&b;</span><br><span class=line>endmodule</span><br></pre></table></figure><h3 id=位bcd码全加器>100位BCD码全加器</h3><p>已经定义1位BCD码全加器<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>module bcd_fadd (</span><br><span class=line>    input [3:0] a,</span><br><span class=line>    input [3:0] b,</span><br><span class=line>    input     cin,</span><br><span class=line>    output   cout,</span><br><span class=line>    output [3:0] sum );</span><br></pre></table></figure><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input [399:0] a, b,</span><br><span class=line>    input cin,</span><br><span class=line>    output cout,</span><br><span class=line>    output [399:0] sum );</span><br><span class=line></span><br><span class=line>    wire [100:0] c;</span><br><span class=line>    assign cout = c[100];</span><br><span class=line>    assign c[0] = cin;</span><br><span class=line></span><br><span class=line>    genvar i;</span><br><span class=line>    generate</span><br><span class=line>        for(i=0; i&lt;100; ++i) begin: bcd_gen</span><br><span class=line>            bcd_fadd u_bcd (</span><br><span class=line>                .a( a[(4*i+3):(4*i)] ),</span><br><span class=line>                .b( b[(4*i+3):(4*i)] ),</span><br><span class=line>                .cin( c[i] ),</span><br><span class=line>                .cout( c[i+1] ),</span><br><span class=line>                .sum( sum[(4*i+3):(4*i)] )</span><br><span class=line>            );</span><br><span class=line>        end</span><br><span class=line>    endgenerate</span><br><span class=line>    </span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><h2 id=仿真>仿真</h2><h3 id=timescale>timescale</h3><p>定义仿真中时间单位的比例。它的作用是指定时序仿真中时间单位的大小，以便仿真器可以正确地模拟设计中的时序行为。<p>基本语法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>`timescale unit / precision</span><br></pre></table></figure><p>其中，<code>unit</code>是时间单位，可以是<code>1ns</code>、<code>1ps</code>、<code>1us</code>等，表示一个时钟周期的时间长度；<code>precision</code>是时间精度，表示仿真的最小时间单位；<h3 id=num>#num</h3><p>等待num个时间单位后，执行后面的语句。<p>基本语法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>#num statement</span><br></pre></table></figure><h3 id=task>task</h3><p>Verilog语言中具有类似C语言函数的结构有task和function，他们可以增加代码可读性和重复使用性。Function用来描述组合逻辑，只能有一个返回值，function的内部不能包含时序控制。Task类似procedure，执行一段verilog代码，task中可以有任意数量的输入和输出，task也可以包含时序控制。<p>基本语法<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>task TASK_NAME;</span><br><span class=line>endtask</span><br></pre></table></figure><h3 id=ps2键盘设备仿真>PS/2键盘设备仿真</h3><p>当用户按键或松开时，键盘以每帧11位的格式串行传送数据给主机，同时在PS2_CLK时钟信号上传输对应的时钟（一般为10.0–16.7kHz）。第一位是开始位（逻辑0），后面跟8位数据位（低位在前），一个奇偶校验位（奇校验）和一位停止位（逻辑1）。每位都在时钟的 <strong>下降沿</strong> 有效，下图显示了键盘传送一字节数据的时序。在下降沿有效的主要原因是下降沿正好在数据位的中间，因此可以让数据位从开始变化到接收采样时能有一段信号建立时间。<figure><img alt=键盘输出数据时序图 src=https://nju-projectn.github.io/dlco-lecture-note/_images/ps01.png><figcaption aria-hidden=true>键盘输出数据时序图</figcaption></figure><p>键盘通过PS2_DAT引脚发送的信息称为扫描码，每个扫描码可以由单个数据帧或连续多个数据帧构成。当按键被按下时送出的扫描码被称为 <code>通码（Make Code）</code> ，当按键被释放时送出的扫描码称为 <code>断码（Break Code）</code> 。以 <code>W</code> 键为例， <code>W</code> 键的通码是1Dh，如果 <code>W</code> 键被按下，则PS2_DAT引脚将输出一帧数据，其中的8位数据位为1Dh，如果 <code>W</code> 键一直没有释放，则不断输出扫描码1Dh 1Dh … 1Dh，直到有其他键按下或者 <code>W</code> 键被放开。某按键的断码是F0h加此按键的通码，如释放 <code>W</code> 键时输出的断码为F0h 1Dh，分两帧传输。<p>多个键被同时按下时，将逐个输出扫描码，如：先按左 <code>Shift</code> 键（扫描码为12h）、再按 <code>W</code> 键、放开 <code>W</code> 键、再放开左 <code>Shift</code> 键，则此过程送出的全部扫描码为：12h 1Dh F0h 1Dh F0h 12h。<p><strong>键盘扫描码</strong><p>每个键都有唯一的通码和断码。键盘所有键的扫描码组成的集合称为扫描码集。共有三套标准的扫描码集，所有现代的键盘默认使用第二套扫描码。下图显示了键盘各键的扫描码（以十六进制表示），如Caps键的扫描码是58h。 下图可以看出，键盘上各按键的扫描码是随机排列的，如果想迅速的将键盘扫描码转换为ASCII码，一个最简单的方法就是利用查找表 <a href=https://en.wikipedia.org/wiki/Lookup_table rel=noopener target=_blank>LookUp Table, LUT</a> ，扫描码到ASCII码的转换表格请读者自己生成。<figure><img alt=键盘扫描码 src=https://nju-projectn.github.io/dlco-lecture-note/_images/ps02.png><figcaption aria-hidden=true>键盘扫描码</figcaption></figure><figure><img alt=扩展键盘和数字键盘的扫描码 src=https://nju-projectn.github.io/dlco-lecture-note/_images/ps03.png><figcaption aria-hidden=true>扩展键盘和数字键盘的扫描码</figcaption></figure><p>键盘控制器<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line>module ps2_keyboard(clk,clrn,ps2_clk,ps2_data,data,</span><br><span class=line>                    ready,nextdata_n,overflow);</span><br><span class=line>    input clk,clrn,ps2_clk,ps2_data;</span><br><span class=line>    input nextdata_n;</span><br><span class=line>    output [7:0] data;</span><br><span class=line>    output reg ready;</span><br><span class=line>    output reg overflow;     // fifo overflow</span><br><span class=line>    // internal signal, for test</span><br><span class=line>    reg [9:0] buffer;        // ps2_data bits</span><br><span class=line>    reg [7:0] fifo[7:0];     // data fifo</span><br><span class=line>    reg [2:0] w_ptr,r_ptr;   // fifo write and read pointers</span><br><span class=line>    reg [3:0] count;  // count ps2_data bits</span><br><span class=line>    // detect falling edge of ps2_clk</span><br><span class=line>    reg [2:0] ps2_clk_sync;</span><br><span class=line></span><br><span class=line>    always @(posedge clk) begin</span><br><span class=line>        ps2_clk_sync &lt;=  {ps2_clk_sync[1:0],ps2_clk};</span><br><span class=line>    end</span><br><span class=line></span><br><span class=line>    wire sampling = ps2_clk_sync[2] & ~ps2_clk_sync[1];</span><br><span class=line></span><br><span class=line>    always @(posedge clk) begin</span><br><span class=line>        if (clrn == 0) begin // reset</span><br><span class=line>            count &lt;= 0; w_ptr &lt;= 0; r_ptr &lt;= 0; overflow &lt;= 0; ready&lt;= 0;</span><br><span class=line>        end</span><br><span class=line>        else begin</span><br><span class=line>            if ( ready ) begin // read to output next data</span><br><span class=line>                if(nextdata_n == 1'b0) //read next data</span><br><span class=line>                begin</span><br><span class=line>                    r_ptr &lt;= r_ptr + 3'b1;</span><br><span class=line>                    if(w_ptr==(r_ptr+1'b1)) //empty</span><br><span class=line>                        ready &lt;= 1'b0;</span><br><span class=line>                end</span><br><span class=line>            end</span><br><span class=line>            if (sampling) begin</span><br><span class=line>              if (count == 4'd10) begin</span><br><span class=line>                if ((buffer[0] == 0) &&  // start bit</span><br><span class=line>                    (ps2_data)       &&  // stop bit</span><br><span class=line>                    (^buffer[9:1])) begin      // odd  parity</span><br><span class=line>                    fifo[w_ptr] &lt;= buffer[8:1];  // kbd scan code</span><br><span class=line>                    w_ptr &lt;= w_ptr+3'b1;</span><br><span class=line>                    ready &lt;= 1'b1;</span><br><span class=line>                    overflow &lt;= overflow | (r_ptr == (w_ptr + 3'b1));</span><br><span class=line>                end</span><br><span class=line>                count &lt;= 0;     // for next</span><br><span class=line>              end else begin</span><br><span class=line>                buffer[count] &lt;= ps2_data;  // store ps2_data</span><br><span class=line>                count &lt;= count + 3'b1;</span><br><span class=line>              end</span><br><span class=line>            end</span><br><span class=line>        end</span><br><span class=line>    end</span><br><span class=line>    assign data = fifo[r_ptr]; //always set output data</span><br><span class=line></span><br><span class=line>endmodule</span><br></pre></table></figure><p>键盘仿真模型<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line>`timescale 1ns / 1ps</span><br><span class=line>module ps2_keyboard_model(</span><br><span class=line>    output reg ps2_clk,</span><br><span class=line>    output reg ps2_data</span><br><span class=line>    );</span><br><span class=line>parameter [31:0] kbd_clk_period = 60;</span><br><span class=line>initial ps2_clk = 1'b1;</span><br><span class=line></span><br><span class=line>task kbd_sendcode;</span><br><span class=line>    input [7:0] code; // key to be sent</span><br><span class=line>    integer i;</span><br><span class=line></span><br><span class=line>    reg[10:0] send_buffer;</span><br><span class=line>    begin</span><br><span class=line>        send_buffer[0]   = 1'b0;  // start bit</span><br><span class=line>        send_buffer[8:1] = code;  // code</span><br><span class=line>        send_buffer[9]   = ~(^code); // odd parity bit</span><br><span class=line>        send_buffer[10]  = 1'b1;  // stop bit</span><br><span class=line>        i = 0;</span><br><span class=line>        while( i &lt; 11) begin</span><br><span class=line>            // set kbd_data</span><br><span class=line>            ps2_data = send_buffer[i];</span><br><span class=line>            #(kbd_clk_period/2) ps2_clk = 1'b0;</span><br><span class=line>            #(kbd_clk_period/2) ps2_clk = 1'b1;</span><br><span class=line>            i = i + 1;</span><br><span class=line>        end</span><br><span class=line>    end</span><br><span class=line>endtask</span><br><span class=line></span><br><span class=line>endmodule</span><br></pre></table></figure><p>键盘测试代码<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br></pre><td class=code><pre><span class=line>`timescale 1ns / 1ps</span><br><span class=line>module keyboard_sim;</span><br><span class=line></span><br><span class=line>/* parameter */</span><br><span class=line>parameter [31:0] clock_period = 10;</span><br><span class=line></span><br><span class=line>/* ps2_keyboard interface signals */</span><br><span class=line>reg clk,clrn;</span><br><span class=line>wire [7:0] data;</span><br><span class=line>wire ready,overflow;</span><br><span class=line>wire kbd_clk, kbd_data;</span><br><span class=line>reg nextdata_n;</span><br><span class=line></span><br><span class=line>ps2_keyboard_model model(</span><br><span class=line>    .ps2_clk(kbd_clk),</span><br><span class=line>    .ps2_data(kbd_data)</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>ps2_keyboard inst(</span><br><span class=line>    .clk(clk),</span><br><span class=line>    .clrn(clrn),</span><br><span class=line>    .ps2_clk(kbd_clk),</span><br><span class=line>    .ps2_data(kbd_data),</span><br><span class=line>    .data(data),</span><br><span class=line>    .ready(ready),</span><br><span class=line>    .nextdata_n(nextdata_n),</span><br><span class=line>    .overflow(overflow)</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>initial begin /* clock driver */</span><br><span class=line>    clk = 0;</span><br><span class=line>    forever</span><br><span class=line>        #(clock_period/2) clk = ~clk;</span><br><span class=line>end</span><br><span class=line></span><br><span class=line>initial begin</span><br><span class=line>    clrn = 1'b0;  #20;</span><br><span class=line>    clrn = 1'b1;  #20;</span><br><span class=line>    model.kbd_sendcode(8'h1C); // press 'A'</span><br><span class=line>    #20 nextdata_n =1'b0; #20 nextdata_n =1'b1;//read data</span><br><span class=line>    model.kbd_sendcode(8'hF0); // break code</span><br><span class=line>    #20 nextdata_n =1'b0; #20 nextdata_n =1'b1; //read data</span><br><span class=line>    model.kbd_sendcode(8'h1C); // release 'A'</span><br><span class=line>    #20 nextdata_n =1'b0; #20 nextdata_n =1'b1; //read data</span><br><span class=line>    model.kbd_sendcode(8'h1B); // press 'S'</span><br><span class=line>    #20 model.kbd_sendcode(8'h1B); // keep pressing 'S'</span><br><span class=line>    #20 model.kbd_sendcode(8'h1B); // keep pressing 'S'</span><br><span class=line>    model.kbd_sendcode(8'hF0); // break code</span><br><span class=line>    model.kbd_sendcode(8'h1B); // release 'S'</span><br><span class=line>    #20;</span><br><span class=line>    $stop;</span><br><span class=line>end</span><br><span class=line></span><br><span class=line>endmodule</span><br></pre></table></figure><h1 id=电路>电路</h1><h2 id=组合逻辑>组合逻辑</h2><h3 id=基本门>基本门</h3><p>GND<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>assign out = 1'b0;</span><br></pre></table></figure><p>NOR<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>assign out = ~(in1|in2);</span><br></pre></table></figure><h3 id=多路选择器>多路选择器</h3><p>9路选择器<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line>module top_module( </span><br><span class=line>    input [15:0] a, b, c, d, e, f, g, h, i,</span><br><span class=line>    input [3:0] sel,</span><br><span class=line>    output [15:0] out );</span><br><span class=line></span><br><span class=line>	// Case statements can only be used inside procedural blocks (always block)</span><br><span class=line>	// This is a combinational circuit, so use a combinational always @(*) block.</span><br><span class=line>	always @(*) begin</span><br><span class=line>		out = '1;		// '1 is a special literal syntax for a number with all bits set to 1.</span><br><span class=line>						// '0, 'x, and 'z are also valid.</span><br><span class=line>						// I prefer to assign a default value to 'out' instead of using a</span><br><span class=line>						// default case.</span><br><span class=line>		case (sel)</span><br><span class=line>			4'h0: out = a;</span><br><span class=line>			4'h1: out = b;</span><br><span class=line>			4'h2: out = c;</span><br><span class=line>			4'h3: out = d;</span><br><span class=line>			4'h4: out = e;</span><br><span class=line>			4'h5: out = f;</span><br><span class=line>			4'h6: out = g;</span><br><span class=line>			4'h7: out = h;</span><br><span class=line>			4'h8: out = i;</span><br><span class=line>		endcase</span><br><span class=line>	end</span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure><p>4位256路选择器<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>module top_module (</span><br><span class=line>	input [1023:0] in,</span><br><span class=line>	input [7:0] sel,</span><br><span class=line>	output [3:0] out</span><br><span class=line>);</span><br><span class=line></span><br><span class=line>	// We can't part-select multiple bits without an error, but we can select one bit at a time,</span><br><span class=line>	// four times, then concatenate them together.</span><br><span class=line>	assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};</span><br><span class=line></span><br><span class=line>	// Alternatively, "indexed vector part select" works better, but has an unfamiliar syntax:</span><br><span class=line>	// assign out = in[sel*4 +: 4];		// Select starting at index "sel*4", then select a total width of 4 bits with increasing (+:) index number.</span><br><span class=line>	// assign out = in[sel*4+3 -: 4];	// Select starting at index "sel*4+3", then select a total width of 4 bits with decreasing (-:) index number.</span><br><span class=line>	// Note: The width (4 in this case) must be constant.</span><br><span class=line></span><br><span class=line>endmodule</span><br><span class=line></span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/08/Verilator-%E7%94%B5%E8%B7%AFRTL%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/08/Verilator-%E7%94%B5%E8%B7%AFRTL%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%BD%BF%E7%94%A8/ itemprop=url>Verilator-电路RTL仿真器使用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-08 11:07:02" datetime=2024-04-08T11:07:02+08:00>2024-04-08</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E7%A1%AC%E4%BB%B6/ itemprop=url rel=index><span itemprop=name>硬件</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>361</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>1 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=使用示例>使用示例</h1><p>南京大学电路教学项目-<a href=https://github.com/NJU-ProjectN/nvboard.git rel=noopener target=_blank>NVboard</a>，可以图形化显示过程状态和数据，同时也支持verilator。<h2 id=双控开关>双控开关</h2><p>Makefile<figure class="highlight makefile"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line>VERILATOR_FLAGS := --build -j 0 -cc --exe -x-assign fast -Wall</span><br><span class=line></span><br><span class=line>C_SRC   :=      <span class=variable>$(<span class=built_in>shell</span> ls csrc/*.cpp)</span></span><br><span class=line>V_SRC   :=  <span class=variable>$(<span class=built_in>shell</span> ls vsrc/*.v)</span></span><br><span class=line>OBJ_DIR :=      obj_dir</span><br><span class=line>TARGET  :=  obj_dir/Vtop</span><br><span class=line><span class=comment>#TARGET_ARGS    := +trace</span></span><br><span class=line></span><br><span class=line><span class=meta><span class=keyword>.PHONY</span>: run clean</span></span><br><span class=line></span><br><span class=line><span class=keyword>ifdef</span> TRACE</span><br><span class=line>VERILATOR_FLAGS += --trace</span><br><span class=line><span class=keyword>endif</span></span><br><span class=line></span><br><span class=line><span class=section>all: ${TARGET}</span></span><br><span class=line></span><br><span class=line><span class=section>run: ${TARGET}</span></span><br><span class=line>        @rm -rf logs</span><br><span class=line>        @${TARGET} ${TARGET_ARGS}</span><br><span class=line></span><br><span class=line><span class=section>${TARGET}: ${V_SRC} ${C_SRC}</span></span><br><span class=line>        <span class=comment>#@verilator --build -j 0 -cc --exe -x-assign fast -Wall --trace $^</span></span><br><span class=line>        @verilator ${VERILATOR_FLAGS} <span class=variable>$^</span></span><br><span class=line></span><br><span class=line><span class=section>sim:</span></span><br><span class=line>        <span class=variable>$(<span class=built_in>call</span> git_commit, <span class=string>"sim RTL"</span>)</span> <span class=comment># DO NOT REMOVE THIS LINE!!!</span></span><br><span class=line>        @echo <span class=string>"Write this Makefile by your self."</span></span><br><span class=line></span><br><span class=line><span class=keyword>include</span> ../Makefile</span><br><span class=line></span><br><span class=line><span class=section>clean:</span></span><br><span class=line>        @rm -rf logs</span><br><span class=line>        @rm -rf ${OBJ_DIR}</span><br></pre></table></figure><p>verilog代码文件<code>top.v</code><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>module top</span><br><span class=line>  (</span><br><span class=line>  input a,</span><br><span class=line>  input b,</span><br><span class=line>  output f</span><br><span class=line>  );</span><br><span class=line></span><br><span class=line>  assign f = a ^ b;</span><br><span class=line></span><br><span class=line>  initial begin</span><br><span class=line>        $display("[%0t] Model running...\n", $time);</span><br><span class=line>  end</span><br><span class=line></span><br><span class=line>endmodule</span><br></pre></table></figure><p>主体仿真文件<code>sim_main.cpp</code><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdio.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdlib.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;assert.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;stdint.h></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>&lt;memory></span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"Vtop.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"verilated.h"</span></span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>if</span> VM_TRACE_VCD</span></span><br><span class=line><span class=meta>#<span class=keyword>include</span> <span class=string>"verilated_vcd_c.h"</span></span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">main</span><span class=params>(<span class=type>int</span> argc, <span class=type>char</span>** argv)</span></span><br><span class=line>{</span><br><span class=line>        <span class=type>const</span> <span class=built_in>std</span>::<span class=built_in>unique_ptr</span>&lt;VerilatedContext> contextp{new VerilatedContext};</span><br><span class=line>        contextp->debug(<span class=number>0</span>); <span class=comment>// Set debug level, 0 is off, 9 is highest</span></span><br><span class=line>        contextp->randReset(<span class=number>2</span>); <span class=comment>// Randomization reset policy</span></span><br><span class=line>        contextp->commandArgs(argc, argv); <span class=comment>// Pass arguments so Verilated code can see them</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// "TOP" will be hierarchical name of the module.</span></span><br><span class=line>        <span class=type>const</span> <span class=built_in>std</span>::<span class=built_in>unique_ptr</span>&lt;Vtop> top{new Vtop{contextp.get(), <span class=string>"TOP"</span>}};</span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>if</span> VM_TRACE_VCD</span></span><br><span class=line>        Verilated::mkdir(<span class=string>"logs"</span>);</span><br><span class=line>        contextp->traceEverOn(<span class=literal>true</span>); <span class=comment>// Verilator must compute traced signals</span></span><br><span class=line>        <span class=type>const</span> <span class=built_in>std</span>::<span class=built_in>unique_ptr</span>&lt;VerilatedVcdC>tfp{new VerilatedVcdC};</span><br><span class=line>        top->trace(tfp.get(), <span class=number>99</span>); <span class=comment>// Trace 99 levels of hierarchy (or see below)</span></span><br><span class=line>        tfp->open(<span class=string>"logs/simu_top.vcd"</span>);</span><br><span class=line>        <span class=built_in>printf</span>(<span class=string>"Start trace ...\n"</span>);</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line></span><br><span class=line>        <span class=type>uint64_t</span> sim_time = <span class=number>10000</span>;</span><br><span class=line>        <span class=keyword>while</span>(contextp->time()&lt;sim_time && !contextp->gotFinish())</span><br><span class=line>        {</span><br><span class=line>                contextp->timeInc(<span class=number>1</span>);</span><br><span class=line></span><br><span class=line>                <span class=type>int</span> a = rand() & <span class=number>1</span>;</span><br><span class=line>                <span class=type>int</span> b = rand() & <span class=number>1</span>;</span><br><span class=line>                top->a = a;</span><br><span class=line>                top->b = b;</span><br><span class=line>                top->eval();</span><br><span class=line>                <span class=comment>// printf("a = %d, b = %d, f = %d, time = %lu\n", a, b, top->f, contextp->time());</span></span><br><span class=line>                assert(top->f == (a ^ b));</span><br><span class=line></span><br><span class=line><span class=meta>#<span class=keyword>if</span> VM_TRACE_VCD</span></span><br><span class=line>                tfp->dump(contextp->time());</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        top->final();</span><br><span class=line></span><br><span class=line>        <span class=comment>// Coverage analysis</span></span><br><span class=line><span class=meta>#<span class=keyword>if</span> VM_COVERAGE</span></span><br><span class=line>        Verilated::mkdir(<span class=string>"logs"</span>);</span><br><span class=line>        contextp->converagep()->write(<span class=string>"logs/coverage.dat"</span>);</span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line></span><br><span class=line>        <span class=comment>// Final simulation summary</span></span><br><span class=line>        contextp->statsPrintSummary();</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/04/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AE%80%E4%BB%8B/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/04/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AE%80%E4%BB%8B/ itemprop=url>Linux命令使用与脚本编写简介</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-04 20:47:25" datetime=2024-04-04T20:47:25+08:00>2024-04-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>1.8k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>7 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=linux命令>Linux命令</h1><h2 id=常用命令>常用命令</h2><h3 id=cd>cd</h3><h3 id=ls>ls</h3><h3 id=awk>awk</h3><h3 id=sed>sed</h3><h3 id=ps>ps</h3><h3 id=df>df</h3><h3 id=fdisk>fdisk</h3><h3 id=wc>wc</h3><h3 id=find>find</h3><h3 id=grepegrep>grep/egrep</h3><h3 id=top>top</h3><h3 id=vivim>vi/vim</h3><h3 id=diffvimdiff>diff/vimdiff</h3><h3 id=man>man</h3><p>查看内置帮助手册，不仅可以查看命令手册，还有系统调用、库函数、异常码、宏等等信息。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 学习如何RTFM</span></span><br><span class=line>$ man man</span><br><span class=line><span class=comment># 学习如何使用库函数</span></span><br><span class=line>$ man 3 getopt</span><br><span class=line><span class=comment># 检索含有关键词xxx的命令</span></span><br><span class=line>$ man -k xxx</span><br><span class=line>$ man readline</span><br><span class=line>$ man bash</span><br></pre></table></figure><h3 id=xargs>xargs</h3><h3 id=strace>strace</h3><p>system call trace, 记录程序运行过程中的系统调用信息<h3 id=netstat>netstat</h3><h3 id=ip>ip</h3><h3 id=ifconfig>ifconfig</h3><h3 id=ssh>ssh</h3><h3 id=telnet>telnet</h3><h3 id=sort>sort</h3><h3 id=history>history</h3><p><code>!n</code>再次执行编号n命令<p><code>!xxx</code>再次执行以<code>xxx</code>开头的最近一条命令<h3 id=yes>yes</h3><p>不断重复输出<code>y</code><h3 id=watch>watch</h3><p>在前台定时执行命令<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>$ watch -t -n 1 <span class=string>"echo -n '第六期一生一芯 | 周六 15:00~17:00 | '; \</span></span><br><span class=line><span class=string>  date; echo '课程主页 https://ysyx.oscc.cc/docs/'"</span></span><br><span class=line>第六期一生一芯 | 周六 15:00~17:00 | Thu Apr  4 16:58:59 CST 2024</span><br><span class=line>课程主页 https://ysyx.oscc.cc/docs/</span><br><span class=line></span><br><span class=line></span><br></pre></table></figure><h3 id=crontab>crontab</h3><p>在后台定时执行命令，需要编写对应的配置文件<h3 id=timeout>timeout</h3><p>执行特定时间，返回超时或命令自身的返回值<ul><li>0：命令成功执行并完成。<li>124：命令因超时而终止。<li>其他：命令执行失败</ul><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ timeout 6 mkdir -p /mnt/dev0</span><br></pre></table></figure><h1 id=脚本编写>脚本编写</h1><p>细节介绍参考<code>man bash</code><h2 id=基本语法>基本语法</h2><h3 id=简介>简介</h3><p>脚本的本质就是将众多Linux小工具按照一定的逻辑顺序依次执行处理，脚本文件内容就是这些命令的集合。<p>程序运行时都会打开3个文件<ul><li>0号文件，标准输入<li>1号文件，标准输出<li>2号文件，标准错误输出</ul><p>可以通过<code>lsof -p &lt;PID></code>查看进程打开的文件。<p><code>></code>重定向标准输出，<code>>></code>追加方式重定向标准输出，<code>2>&1</code>将标准错误重定向到标准输出。<p>内置变量有<ul><li><code>$0 $1 ... $n</code>：脚本名称（有时会包含相对或绝对路径）、第1个参数……第n个参数<li><code>$?</code>：最后一条命令或函数的返回值<li><code>$@</code>：传递<code>$0</code>之外的所有参数，可以用数组保存其值：<code>ALL_ARGS=("$@")</code><li><code>$#</code>：传递给脚本或函数的参数个数</ul><h3 id=内置命令>内置命令</h3><h4 id=shift>shift</h4><p>基本格式：<code>shift [n]</code><p>将参数左移n位，默认值为1<h3 id=交互界面>交互界面</h3><p>基本操作<ul><li><code>Tab</code>键自动补全<li>上下方向键遍历历史命令</ul><p>任务管理<ul><li><code>Ctrl+Z</code>最小化，或运行时命令末尾添加&（但用户退出后后台任务也会退出，可以使用<code>nohup</code>命令避免）<li><code>jobs</code>任务栏<li><code>bg</code>后台执行任务，将指定任务2切换到后台执行<code>bg %2</code><li><code>fg</code>前台执行任务，将指定任务2切换到前台执行<code>fg %2</code></ul><p>shell可以通过快捷键操作光标快速移动，更多快捷键可以阅读<code>man readline</code>的<code>Commands for Moving</code>部分<ul><li><code>Ctrl+B</code>光标前移一个字符<li><code>Ctrl+F</code>光标后移一个字符<li><code>Ctrl+A</code>光标移到首字符处<li><code>Ctrl+E</code>光标移到首字符处</ul><h3 id=基本单元>基本单元</h3><p>shell都是基于文本进行处理，其中只有数字字符串在特定场景可以进行数学运算。<p>通配符<ul><li><code>*</code>任意长度的字符串<li><code>?</code>任意一个字符<li><code>[xxx]</code>集合中任意一个字符</ul><p>示例<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>echo</span> Hello-{a,bb,ccc}-{1,2}!</span><br><span class=line>Hello-a-1! Hello-a-2! Hello-bb-1! Hello-bb-2! Hello-ccc-1! Hello-ccc-2!</span><br></pre></table></figure><p>数组<p>示例<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line># 创建一个数组</span><br><span class=line>array=()</span><br><span class=line>declare -a array</span><br><span class=line></span><br><span class=line># 添加元素</span><br><span class=line>array+=("item0")</span><br><span class=line>array+=("item1")</span><br><span class=line>array+=("item2")</span><br><span class=line></span><br><span class=line># 遍历一个数组</span><br><span class=line>for item in $array; do echo item is $item; done</span><br><span class=line>for i in {1..${#array[@]}}; do item=${array[$i]}; echo item is $item; done</span><br><span class=line>for item in ${array[@]}; do echo item is $item; done</span><br><span class=line></span><br><span class=line># 删除指定元素</span><br><span class=line>unset 'array[1]' # 删除item0，但是索引依然保留</span><br><span class=line># 重新创建一个新数组，通过过滤方式</span><br><span class=line>new_array=()</span><br><span class=line>for item in ${array[@]}; do</span><br><span class=line>	if [ $item != "item0" ]; then</span><br><span class=line>		new_array+=("$item")</span><br><span class=line>	fi</span><br><span class=line>done</span><br><span class=line></span><br><span class=line># 删除整个数组</span><br><span class=line>unset array</span><br><span class=line>array=() # 清空整个数组</span><br></pre></table></figure><h3 id=判断逻辑>判断逻辑</h3><p>if<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ if mkdir -p /mnt/dev0; then echo ok; else echo error; fi</span><br></pre></table></figure><p>命令执行成功则打印ok，否则打印失败<p>case<h3 id=循环逻辑>循环逻辑</h3><p>while<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>$ <span class=keyword>while</span> [[ `<span class=built_in>seq</span> 1 10 | <span class=built_in>shuf</span> | <span class=built_in>head</span> -n 1` != <span class=string>"1"</span> ]]; <span class=keyword>do</span> <span class=built_in>echo</span> <span class=string>"retry"</span>; <span class=keyword>done</span></span><br><span class=line>retry</span><br><span class=line>retry</span><br></pre></table></figure><p>for<h3 id=捕获信号>捕获信号</h3><p><code>trap</code> 命令用于捕获和处理信号或错误。当特定信号发生时，<code>trap</code> 可以执行指定的命令。<code>trap</code> 可以捕获多种信号，包括系统信号和错误。<p>一些常见的信号量包括：<ul><li><code>SIGINT</code> (2): 中断信号，通常由 Ctrl+C 触发。<li><code>SIGTERM</code> (15): 终止信号，通常由 <code>kill</code> 命令发送，用于请求进程终止。<li><code>SIGKILL</code> (9): 强制终止信号，无法被捕获或忽略，通常用于强制停止进程。<li><code>SIGQUIT</code> (3): 退出信号，通常由 Ctrl+ 触发，用于生成 core dump。<li><code>SIGSTOP</code> (19): 停止信号，无法被捕获或忽略，通常用于挂起进程。<li><code>SIGCONT</code> (18): 恢复信号，用于恢复一个被 <code>SIGSTOP</code> 停止的进程。<li><code>SIGHUP</code> (1): 挂起信号，通常是终端关闭时发送的。<li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>: 用户自定义信号，可以用来传递特定信息。<li><code>SIGSEGV</code> (11): 段错误信号，通常在程序访问非法内存时触发。<li><code>SIGPIPE</code> (13): 管道破裂信号，通常当向一个没有读取者的管道写数据时触发。</ul><p>常见的错误有：<ul><li><code>EXIT</code>：捕获脚本或命令退出时的状态（返回码）。例如，你可以捕获脚本退出时的状态码，或者通过 <code>trap</code> 在脚本退出时执行清理工作。<li><code>ERR</code>：捕获任何命令的非零退出状态（发生错误时触发）。通过 <code>trap 'command' ERR</code>，你可以在发生错误时执行指定的命令。</ul><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>#!/bin/bash</span><br><span class=line></span><br><span class=line>exit_handler() {</span><br><span class=line># 具体处理逻辑</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>trap exit_handler SIGINT SIGTERM EXIT ERR</span><br><span class=line></span><br></pre></table></figure><h3 id=输入输出>输入输出</h3><h2 id=经典示例>经典示例</h2><h3 id=输入参数解析>输入参数解析</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>输入的参数可以包含以下几种情况的任意组合，&lt;xxx>表示参数后必须跟对应的值：</span><br><span class=line>-n &lt;num></span><br><span class=line>--number &lt;num> </span><br><span class=line>-v</span><br><span class=line>--version</span><br><span class=line>-h</span><br></pre></table></figure><h4 id=case手动解析>case手动解析</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>#!/bin/bash</span><br><span class=line></span><br><span class=line># 手动解析参数</span><br><span class=line>while [ $# -gt 0 ]; do</span><br><span class=line>    case "$1" in</span><br><span class=line>        -n|--number)</span><br><span class=line>            # 确保后面有值</span><br><span class=line>            if [ -n "$2" ] && [[ "$2" != -* ]]; then</span><br><span class=line>                number="$2"</span><br><span class=line>                shift 2</span><br><span class=line>            else</span><br><span class=line>                echo "错误: -n 或 --number 需要一个参数"</span><br><span class=line>                exit 1</span><br><span class=line>            fi</span><br><span class=line>            ;;</span><br><span class=line>        -v|--version) show_version=true; shift; ;;</span><br><span class=line>        -h|--help) show_help=true; shift; ;;</span><br><span class=line>        *)</span><br><span class=line>            echo "忽略非选项参数: $1"</span><br><span class=line>            shift</span><br><span class=line>            ;;</span><br><span class=line>    esac</span><br><span class=line>done</span><br></pre></table></figure><h3 id=自制cpu主频监视器>自制CPU主频监视器</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ watch -n 1 <span class=string>"cat /proc/cpuinfo | grep MHz | awk '{print \$1 NR \$3 \$4 \$2}'"</span></span><br></pre></table></figure><h3 id=打包特定文件并上传到远端>打包特定文件并上传到远端</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ find . -name <span class=string>"*.pdf"</span> | xargs tar cj | ssh yzh@192.168.1.1 <span class=string>'cd ysyx; > pdf.tar.bz2'</span></span><br></pre></table></figure><h3 id=统计工具类型分布>统计工具类型分布</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>$ <span class=built_in>echo</span> <span class=variable>$PATH</span> | <span class=built_in>tr</span> -t : <span class=string>'\n'</span> | xargs -I{} find {} -maxdepth 1 -<span class=built_in>type</span> f -executable | \</span><br><span class=line>  xargs file -b -e elf | <span class=built_in>sort</span> | <span class=built_in>uniq</span> -c | <span class=built_in>sort</span> -nr</span><br><span class=line></span><br><span class=line>    835 ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class=line>    129 Perl script text executable</span><br><span class=line>    113 POSIX shell script, ASCII text executable</span><br><span class=line>     34 Python script, ASCII text executable</span><br><span class=line>     24 ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux)</span><br><span class=line>     20 Bourne-Again shell script, ASCII text executable</span><br><span class=line>     15 setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class=line>     12 setgid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class=line>     10 ELF 64-bit LSB executable, x86-64, version 1 (SYSV)</span><br><span class=line>      9 POSIX shell script, Unicode text, UTF-8 text executable</span><br><span class=line>      3 ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux)</span><br><span class=line>      2 Python script, Unicode text, UTF-8 text executable</span><br><span class=line>      2 PHP script, ASCII text executable</span><br><span class=line>      1 setuid, setgid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class=line>      1 Python script, ISO-8859 text executable</span><br><span class=line>      1 POSIX shell script, ASCII text executable, with very long lines (459)</span><br><span class=line>      1 PHP phar archive with SHA1 signature</span><br><span class=line>      1 Paul Falstad<span class=string>'s zsh script, ASCII text executable</span></span><br><span class=line><span class=string>      1 JavaScript source, ASCII text</span></span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://oz1010.github.com/2024/04/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.jpg itemprop=image> <meta content=oz1010 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="oz1010's blog" itemprop=name> <meta content=普通而有趣的技术员 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content=" | oz1010's blog" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/04/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/ itemprop=url>编程语言-C++</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-04-04 15:59:30" datetime=2024-04-04T15:59:30+08:00>2024-04-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-12-01 11:17:09" datetime=2025-12-01T11:17:09+08:00 itemprop=dateModified>2025-12-01</time> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>505</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>2 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h2 id=告警>告警</h2><h3 id=变量初始化顺序>变量初始化顺序</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h: In constructor ‘AADL2C::AIT::CtxComponent::CtxComponent(AADL2C::AIT::NodeArchitecture&, AADL2C::AIT::ASTBasePtr, AADL2C::AIT::NodeComponent&)’:</span><br><span class=line>[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h:137:33: warning: ‘AADL2C::AIT::CtxComponent::mpnewInstance’ will be initialized after [-Wreorder]</span><br><span class=line>[build]      AADL2C::AIT::NodeComponent* mpnewInstance;</span><br><span class=line>[build]                                  ^~~~~~~~~~~~~</span><br><span class=line>[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h:136:33: warning:   ‘AADL2C::AIT::NodeComponent* AADL2C::AIT::CtxComponent::mpexistingInstance’ [-Wreorder]</span><br><span class=line>[build]      AADL2C::AIT::NodeComponent* mpexistingInstance;</span><br><span class=line>[build]                                  ^~~~~~~~~~~~~~~~~~</span><br><span class=line>[build] /root/project/tcl3/aadl2c/src/AIT/CtxUtility.cpp:49:1: warning:   when initialized here [-Wreorder]</span><br><span class=line>[build]  CtxComponent::CtxComponent(AADL2C::AIT::NodeArchitecture& instanceRoot, ASTBasePtr component,</span><br><span class=line>[build]  ^~~~~~~~~~~~</span><br><span class=line>[build] In file included from /root/project/tcl3/aadl2c/src/AIT/CtxUtility.cpp:3:0:</span><br></pre></table></figure><p>这几句告警说的是变量顺序问题，英文大意为：<blockquote><p>成员变量<code>mpnewInstance</code>将会在<code>mpexistingInstance</code>之后初始化，当调用类构造函数<code>CtxComponent::CtxComponent</code>进行初始化时。</blockquote><p><strong>解决方案</strong>：调整相关变量初始化顺序<h2 id=成员变量>成员变量</h2><p>可见性：<ul><li>private<li>protect<li>public</ul><p>静态成员变量 static<p>成员常量 const<p>volitle?<p>register?<p>auto?<h2 id=成员函数>成员函数</h2><p>构造函数 析构函数 拷贝构造函数<p>移动构造函数 移动赋值运算符<p>运算符（= & + - * / ++ – += -= [] () &lt;&lt; >> …）<p>静态成员函数 static<p>只读成员函数 const<p>虚函数 纯虚函数 virtual =0<p>不可调用函数 =delete<p>默认类函数 =default<p>覆写函数 防止覆写函数 override final<p>单参数构造函数显示转换 explict<p>友元函数 friend<h2 id=枚举>枚举</h2><h3 id=字符串化>字符串化</h3><p>C语言宏定义可以有一些特殊用法：<ul><li>#: 预处理阶段，将宏参数转化为字符串<li>##: 预处理阶段，将两个标识符拼接成一个标识符</ul><p>具体步骤：<ol type=1><li>将需要的枚举名放到固定的地方统一管理，使用特别的宏函数<code>ENUM_OR_STRING</code>封装，例如枚举文件<code>signal_list.gen</code></ol><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// signal_list.gen</span></span><br><span class=line>ENUM_OR_STRING(LED_OPEN),                   \</span><br><span class=line>ENUM_OR_STRING(LED_CLOSE),                  \</span><br><span class=line>ENUM_OR_STRING(MSG_TEST),                   \</span><br><span class=line>ENUM_OR_STRING(MSG_BUTT)                    \</span><br></pre></table></figure><ol start=2 type=1><li>定义宏函数<code>ENUM_OR_STRING</code>，使用枚举文件声明枚举</ol><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// signal_id.h</span></span><br><span class=line><span class=comment>/* 消息ID转枚举 */</span></span><br><span class=line><span class=meta>#<span class=keyword>ifdef</span> ENUM_OR_STRING</span></span><br><span class=line><span class=meta>#<span class=keyword>undef</span> ENUM_OR_STRING</span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> ENUM_OR_STRING(x) x</span></span><br><span class=line></span><br><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>enum</span></span></span><br><span class=line><span class=class>{</span></span><br><span class=line>    <span class=meta>#<span class=keyword>include</span> <span class=string>"signal_list.gen"</span></span></span><br><span class=line>} E_MSG_ID;</span><br></pre></table></figure><ol start=3 type=1><li>定义宏函数<code>ENUM_OR_STRING</code>，实现获取枚举字符串方法</ol><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>ifdef</span> ENUM_OR_STRING</span></span><br><span class=line><span class=meta>#<span class=keyword>undef</span> ENUM_OR_STRING</span></span><br><span class=line><span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line><span class=meta>#<span class=keyword>define</span> ENUM_OR_STRING(x) #x</span></span><br><span class=line></span><br><span class=line><span class=type>const</span> <span class=type>int</span> MAX_LENGTH_MSG = <span class=number>50</span>;</span><br><span class=line><span class=type>const</span> <span class=type>char</span> msgIdString[][MAX_LENGTH_MSG] = {</span><br><span class=line>    <span class=meta>#<span class=keyword>include</span> <span class=string>"signal_list.gen"</span></span></span><br><span class=line>};</span><br><span class=line></span><br><span class=line><span class=type>const</span> <span class=type>char</span> *<span class="title function_">GetMsgName</span><span class=params>(<span class=type>int</span> msgID)</span></span><br><span class=line>{</span><br><span class=line>    <span class=keyword>return</span> msgIdString[msgID];</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" aria-label=上一页 href=/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class="page-number current">2</span><a class=page-number href=/page/3/>3</a><span class=space>…</span><a class=page-number href=/page/5/>5</a><a class="extend next" aria-label=下一页 href=/page/3/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>oz1010</span></div><div class=wordcount><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-chart-line"></i> </span> <span title=站点总字数>95k</span> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span> <span title=站点阅读时长>5:47</span> </span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"oz1010/oz1010.github.io-comments","issue_term":"pathname","theme":"github-light"}</script><script defer src=/js/third-party/comments/utterances.js></script>