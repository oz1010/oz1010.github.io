<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oz1010&#39;s blog</title>
  
  <subtitle>记录生活或技能</subtitle>
  <link href="https://oz1010.github.com/atom.xml" rel="self"/>
  
  <link href="https://oz1010.github.com/"/>
  <updated>2026-01-21T06:34:01.232Z</updated>
  <id>https://oz1010.github.com/</id>
  
  <author>
    <name>oz1010</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机基础-ASCII码总表</title>
    <link href="https://oz1010.github.com/2025/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-ASCII%E7%A0%81%E6%80%BB%E8%A1%A8/"/>
    <id>https://oz1010.github.com/2025/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-ASCII%E7%A0%81%E6%80%BB%E8%A1%A8/</id>
    <published>2025-12-01T03:13:33.000Z</published>
    <updated>2026-01-21T06:34:01.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ascii码表">ASCII码表</h1><h2 id="控制字符0x00-0x1f">控制字符（0x00 ~ 0x1F）</h2><table><colgroup><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 43%"><col style="width: 36%"></colgroup><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x00</td><td>0</td><td>NUL</td><td>Null</td><td>空字符 / 字符串结束</td></tr><tr class="even"><td>0x01</td><td>1</td><td>SOH</td><td>Start of Heading</td><td>标题开始</td></tr><tr class="odd"><td>0x02</td><td>2</td><td>STX</td><td>Start of Text</td><td>正文开始</td></tr><tr class="even"><td>0x03</td><td>3</td><td>ETX</td><td>End of Text</td><td>文本结束 / <strong>Ctrl+C</strong></td></tr><tr class="odd"><td>0x04</td><td>4</td><td>EOT</td><td>End of Transmission</td><td>传输结束 / <strong>Ctrl+D</strong></td></tr><tr class="even"><td>0x05</td><td>5</td><td>ENQ</td><td>Enquiry</td><td>查询</td></tr><tr class="odd"><td>0x06</td><td>6</td><td>ACK</td><td>Acknowledge</td><td>确认应答</td></tr><tr class="even"><td>0x07</td><td>7</td><td>BEL</td><td>Bell</td><td>蜂鸣</td></tr><tr class="odd"><td>0x08</td><td>8</td><td>BS</td><td>Backspace</td><td>退格</td></tr><tr class="even"><td>0x09</td><td>9</td><td>HT</td><td>Horizontal Tab</td><td>制表符</td></tr><tr class="odd"><td>0x0A</td><td>10</td><td>LF</td><td>Line Feed</td><td>换行（）</td></tr><tr class="even"><td>0x0B</td><td>11</td><td>VT</td><td>Vertical Tab</td><td>垂直制表</td></tr><tr class="odd"><td>0x0C</td><td>12</td><td>FF</td><td>Form Feed</td><td>换页</td></tr><tr class="even"><td>0x0D</td><td>13</td><td>CR</td><td>Carriage Return</td><td>回车（</td></tr><tr class="odd"><td>0x0E</td><td>14</td><td>SO</td><td>Shift Out</td><td>切换字符集</td></tr><tr class="even"><td>0x0F</td><td>15</td><td>SI</td><td>Shift In</td><td>恢复字符集</td></tr><tr class="odd"><td>0x10</td><td>16</td><td>DLE</td><td>Data Link Escape</td><td>数据链路转义</td></tr><tr class="even"><td>0x11</td><td>17</td><td>DC1</td><td>Device Control 1</td><td>XON</td></tr><tr class="odd"><td>0x12</td><td>18</td><td>DC2</td><td>Device Control 2</td><td>设备控制</td></tr><tr class="even"><td>0x13</td><td>19</td><td>DC3</td><td>Device Control 3</td><td>XOFF</td></tr><tr class="odd"><td>0x14</td><td>20</td><td>DC4</td><td>Device Control 4</td><td>设备控制</td></tr><tr class="even"><td>0x15</td><td>21</td><td>NAK</td><td>Negative Acknowledge</td><td>否认应答</td></tr><tr class="odd"><td>0x16</td><td>22</td><td>SYN</td><td>Synchronous Idle</td><td>同步空闲</td></tr><tr class="even"><td>0x17</td><td>23</td><td>ETB</td><td>End of Transmission Block</td><td>块结束</td></tr><tr class="odd"><td>0x18</td><td>24</td><td>CAN</td><td>Cancel</td><td>取消操作</td></tr><tr class="even"><td>0x19</td><td>25</td><td>EM</td><td>End of Medium</td><td>介质结束</td></tr><tr class="odd"><td>0x1A</td><td>26</td><td>SUB</td><td>Substitute</td><td>EOF / <strong>Ctrl+Z</strong></td></tr><tr class="even"><td>0x1B</td><td>27</td><td>ESC</td><td>Escape</td><td>转义（ANSI）</td></tr><tr class="odd"><td>0x1C</td><td>28</td><td>FS</td><td>File Separator</td><td>文件分隔</td></tr><tr class="even"><td>0x1D</td><td>29</td><td>GS</td><td>Group Separator</td><td>组分隔</td></tr><tr class="odd"><td>0x1E</td><td>30</td><td>RS</td><td>Record Separator</td><td>记录分隔</td></tr><tr class="even"><td>0x1F</td><td>31</td><td>US</td><td>Unit Separator</td><td>单元分隔</td></tr></tbody></table><h2 id="可打印字符0x200x7e">可打印字符（0x20~0x7E）</h2><h3 id="标点表10x200x2f">标点表1（0x20~0x2F）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x20</td><td>32</td><td>SP</td><td>Space</td><td>空格</td></tr><tr class="even"><td>0x21</td><td>33</td><td>!</td><td>Exclamation Mark</td><td>感叹号</td></tr><tr class="odd"><td>0x22</td><td>34</td><td>”</td><td>Quotation Mark</td><td>双引号</td></tr><tr class="even"><td>0x23</td><td>35</td><td>#</td><td>Number Sign</td><td>井号</td></tr><tr class="odd"><td>0x24</td><td>36</td><td>$</td><td>Dollar Sign</td><td>美元符</td></tr><tr class="even"><td>0x25</td><td>37</td><td>%</td><td>Percent Sign</td><td>百分号</td></tr><tr class="odd"><td>0x26</td><td>38</td><td>&amp;</td><td>Ampersand</td><td>与</td></tr><tr class="even"><td>0x27</td><td>39</td><td>’</td><td>Apostrophe</td><td>单引号</td></tr><tr class="odd"><td>0x28</td><td>40</td><td>(</td><td>Left Parenthesis</td><td>左括号</td></tr><tr class="even"><td>0x29</td><td>41</td><td>)</td><td>Right Parenthesis</td><td>右括号</td></tr><tr class="odd"><td>0x2A</td><td>42</td><td>*</td><td>Asterisk</td><td>星号</td></tr><tr class="even"><td>0x2B</td><td>43</td><td>+</td><td>Plus Sign</td><td>加号</td></tr><tr class="odd"><td>0x2C</td><td>44</td><td>,</td><td>Comma</td><td>逗号</td></tr><tr class="even"><td>0x2D</td><td>45</td><td>-</td><td>Hyphen-Minus</td><td>连字符</td></tr><tr class="odd"><td>0x2E</td><td>46</td><td>.</td><td>Full Stop</td><td>句点</td></tr><tr class="even"><td>0x2F</td><td>47</td><td>/</td><td>Solidus</td><td>斜杠</td></tr></tbody></table><h3 id="数字0x30-0x39">数字（0x30 ~ 0x39）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x30</td><td>48</td><td>0</td><td>Digit Zero</td><td>数字 0</td></tr><tr class="even"><td>0x31</td><td>49</td><td>1</td><td>Digit One</td><td>数字 1</td></tr><tr class="odd"><td>0x32</td><td>50</td><td>2</td><td>Digit Two</td><td>数字 2</td></tr><tr class="even"><td>0x33</td><td>51</td><td>3</td><td>Digit Three</td><td>数字 3</td></tr><tr class="odd"><td>0x34</td><td>52</td><td>4</td><td>Digit Four</td><td>数字 4</td></tr><tr class="even"><td>0x35</td><td>53</td><td>5</td><td>Digit Five</td><td>数字 5</td></tr><tr class="odd"><td>0x36</td><td>54</td><td>6</td><td>Digit Six</td><td>数字 6</td></tr><tr class="even"><td>0x37</td><td>55</td><td>7</td><td>Digit Seven</td><td>数字 7</td></tr><tr class="odd"><td>0x38</td><td>56</td><td>8</td><td>Digit Eight</td><td>数字 8</td></tr><tr class="even"><td>0x39</td><td>57</td><td>9</td><td>Digit Nine</td><td>数字 9</td></tr></tbody></table><h3 id="标点表20x3a-0x40">标点表2（0x3A ~ 0x40）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x3A</td><td>58</td><td>:</td><td>Colon</td><td>冒号</td></tr><tr class="even"><td>0x3B</td><td>59</td><td>;</td><td>Semicolon</td><td>分号</td></tr><tr class="odd"><td>0x3C</td><td>60</td><td>&lt;</td><td>Less-Than Sign</td><td>小于</td></tr><tr class="even"><td>0x3D</td><td>61</td><td>=</td><td>Equals Sign</td><td>等号</td></tr><tr class="odd"><td>0x3E</td><td>62</td><td>&gt;</td><td>Greater-Than Sign</td><td>大于</td></tr><tr class="even"><td>0x3F</td><td>63</td><td>?</td><td>Question Mark</td><td>问号</td></tr><tr class="odd"><td>0x40</td><td>64</td><td>@</td><td>Commercial At</td><td>@</td></tr></tbody></table><h3 id="大写字母0x41-0x5a">大写字母（0x41 ~ 0x5A）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x41</td><td>65</td><td>A</td><td>Latin Capital Letter A</td><td>大写 A</td></tr><tr class="even"><td>0x42</td><td>66</td><td>B</td><td>Latin Capital Letter B</td><td>大写 B</td></tr><tr class="odd"><td>0x43</td><td>67</td><td>C</td><td>Latin Capital Letter C</td><td>大写 C</td></tr><tr class="even"><td>0x44</td><td>68</td><td>D</td><td>Latin Capital Letter D</td><td>大写 D</td></tr><tr class="odd"><td>0x45</td><td>69</td><td>E</td><td>Latin Capital Letter E</td><td>大写 E</td></tr><tr class="even"><td>0x46</td><td>70</td><td>F</td><td>Latin Capital Letter F</td><td>大写 F</td></tr><tr class="odd"><td>0x47</td><td>71</td><td>G</td><td>Latin Capital Letter G</td><td>大写 G</td></tr><tr class="even"><td>0x48</td><td>72</td><td>H</td><td>Latin Capital Letter H</td><td>大写 H</td></tr><tr class="odd"><td>0x49</td><td>73</td><td>I</td><td>Latin Capital Letter I</td><td>大写 I</td></tr><tr class="even"><td>0x4A</td><td>74</td><td>J</td><td>Latin Capital Letter J</td><td>大写 J</td></tr><tr class="odd"><td>0x4B</td><td>75</td><td>K</td><td>Latin Capital Letter K</td><td>大写 K</td></tr><tr class="even"><td>0x4C</td><td>76</td><td>L</td><td>Latin Capital Letter L</td><td>大写 L</td></tr><tr class="odd"><td>0x4D</td><td>77</td><td>M</td><td>Latin Capital Letter M</td><td>大写 M</td></tr><tr class="even"><td>0x4E</td><td>78</td><td>N</td><td>Latin Capital Letter N</td><td>大写 N</td></tr><tr class="odd"><td>0x4F</td><td>79</td><td>O</td><td>Latin Capital Letter O</td><td>大写 O</td></tr><tr class="even"><td>0x50</td><td>80</td><td>P</td><td>Latin Capital Letter P</td><td>大写 P</td></tr><tr class="odd"><td>0x51</td><td>81</td><td>Q</td><td>Latin Capital Letter Q</td><td>大写 Q</td></tr><tr class="even"><td>0x52</td><td>82</td><td>R</td><td>Latin Capital Letter R</td><td>大写 R</td></tr><tr class="odd"><td>0x53</td><td>83</td><td>S</td><td>Latin Capital Letter S</td><td>大写 S</td></tr><tr class="even"><td>0x54</td><td>84</td><td>T</td><td>Latin Capital Letter T</td><td>大写 T</td></tr><tr class="odd"><td>0x55</td><td>85</td><td>U</td><td>Latin Capital Letter U</td><td>大写 U</td></tr><tr class="even"><td>0x56</td><td>86</td><td>V</td><td>Latin Capital Letter V</td><td>大写 V</td></tr><tr class="odd"><td>0x57</td><td>87</td><td>W</td><td>Latin Capital Letter W</td><td>大写 W</td></tr><tr class="even"><td>0x58</td><td>88</td><td>X</td><td>Latin Capital Letter X</td><td>大写 X</td></tr><tr class="odd"><td>0x59</td><td>89</td><td>Y</td><td>Latin Capital Letter Y</td><td>大写 Y</td></tr><tr class="even"><td>0x5A</td><td>90</td><td>Z</td><td>Latin Capital Letter Z</td><td>大写 Z</td></tr></tbody></table><h3 id="标点表30x5b-0x60">标点表3（0x5B ~ 0x60）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x5B</td><td>91</td><td>[</td><td>Left Square Bracket</td><td>左中括号</td></tr><tr class="even"><td>0x5C</td><td>92</td><td>\</td><td>Reverse Solidus</td><td>反斜杠</td></tr><tr class="odd"><td>0x5D</td><td>93</td><td>]</td><td>Right Square Bracket</td><td>右中括号</td></tr><tr class="even"><td>0x5E</td><td>94</td><td>^</td><td>Circumflex Accent</td><td>脱字符</td></tr><tr class="odd"><td>0x5F</td><td>95</td><td>_</td><td>Low Line</td><td>下划线</td></tr><tr class="even"><td>0x60</td><td>96</td><td>`</td><td>Grave Accent</td><td>反引号</td></tr></tbody></table><h3 id="小写字母0x61-0x7a">小写字母（0x61 ~ 0x7A）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x61</td><td>97</td><td>a</td><td>Latin Small Letter a</td><td>小写 a</td></tr><tr class="even"><td>0x62</td><td>98</td><td>b</td><td>Latin Small Letter b</td><td>小写 b</td></tr><tr class="odd"><td>0x63</td><td>99</td><td>c</td><td>Latin Small Letter c</td><td>小写 c</td></tr><tr class="even"><td>0x64</td><td>100</td><td>d</td><td>Latin Small Letter d</td><td>小写 d</td></tr><tr class="odd"><td>0x65</td><td>101</td><td>e</td><td>Latin Small Letter e</td><td>小写 e</td></tr><tr class="even"><td>0x66</td><td>102</td><td>f</td><td>Latin Small Letter f</td><td>小写 f</td></tr><tr class="odd"><td>0x67</td><td>103</td><td>g</td><td>Latin Small Letter g</td><td>小写 g</td></tr><tr class="even"><td>0x68</td><td>104</td><td>h</td><td>Latin Small Letter h</td><td>小写 h</td></tr><tr class="odd"><td>0x69</td><td>105</td><td>i</td><td>Latin Small Letter i</td><td>小写 i</td></tr><tr class="even"><td>0x6A</td><td>106</td><td>j</td><td>Latin Small Letter j</td><td>小写 j</td></tr><tr class="odd"><td>0x6B</td><td>107</td><td>k</td><td>Latin Small Letter k</td><td>小写 k</td></tr><tr class="even"><td>0x6C</td><td>108</td><td>l</td><td>Latin Small Letter l</td><td>小写 l</td></tr><tr class="odd"><td>0x6D</td><td>109</td><td>m</td><td>Latin Small Letter m</td><td>小写 m</td></tr><tr class="even"><td>0x6E</td><td>110</td><td>n</td><td>Latin Small Letter n</td><td>小写 n</td></tr><tr class="odd"><td>0x6F</td><td>111</td><td>o</td><td>Latin Small Letter o</td><td>小写 o</td></tr><tr class="even"><td>0x70</td><td>112</td><td>p</td><td>Latin Small Letter p</td><td>小写 p</td></tr><tr class="odd"><td>0x71</td><td>113</td><td>q</td><td>Latin Small Letter q</td><td>小写 q</td></tr><tr class="even"><td>0x72</td><td>114</td><td>r</td><td>Latin Small Letter r</td><td>小写 r</td></tr><tr class="odd"><td>0x73</td><td>115</td><td>s</td><td>Latin Small Letter s</td><td>小写 s</td></tr><tr class="even"><td>0x74</td><td>116</td><td>t</td><td>Latin Small Letter t</td><td>小写 t</td></tr><tr class="odd"><td>0x75</td><td>117</td><td>u</td><td>Latin Small Letter u</td><td>小写 u</td></tr><tr class="even"><td>0x76</td><td>118</td><td>v</td><td>Latin Small Letter v</td><td>小写 v</td></tr><tr class="odd"><td>0x77</td><td>119</td><td>w</td><td>Latin Small Letter w</td><td>小写 w</td></tr><tr class="even"><td>0x78</td><td>120</td><td>x</td><td>Latin Small Letter x</td><td>小写 x</td></tr><tr class="odd"><td>0x79</td><td>121</td><td>y</td><td>Latin Small Letter y</td><td>小写 y</td></tr><tr class="even"><td>0x7A</td><td>122</td><td>z</td><td>Latin Small Letter z</td><td>小写 z</td></tr></tbody></table><h3 id="标点表40x7b-0x7e">标点表4（0x7B ~ 0x7E）</h3><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x7B</td><td>123</td><td>{</td><td>Left Curly Brace</td><td>左大括号</td></tr><tr class="even"><td>0x7C</td><td>124</td><td>|</td><td>Vertical Line</td><td>竖线</td></tr><tr class="odd"><td>0x7D</td><td>125</td><td>}</td><td>Right Curly Brace</td><td>右大括号</td></tr><tr class="even"><td>0x7E</td><td>126</td><td>~</td><td>Tilde</td><td>波浪号</td></tr></tbody></table><h2 id="特殊字符0x7f">特殊字符（0x7F）</h2><table><thead><tr class="header"><th>Hex</th><th>Dec</th><th>缩写</th><th>英文全称</th><th>典型作用 / 说明</th></tr></thead><tbody><tr class="odd"><td>0x7F</td><td>127</td><td>DEL</td><td>Delete</td><td>删除</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ascii码表&quot;&gt;ASCII码表&lt;/h1&gt;
&lt;h2 id=&quot;控制字符0x00-0x1f&quot;&gt;控制字符（0x00 ~ 0x1F）&lt;/h2&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 6%&quot;&gt;
&lt;col style=&quot;width: 6%</summary>
      
    
    
    
    <category term="Computer" scheme="https://oz1010.github.com/categories/Computer/"/>
    
    <category term="ASCII" scheme="https://oz1010.github.com/categories/Computer/ASCII/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-USB设备描述符简介</title>
    <link href="https://oz1010.github.com/2025/10/22/Linux%E9%A9%B1%E5%8A%A8-USB%E8%AE%BE%E5%A4%87%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%AE%80%E4%BB%8B/"/>
    <id>https://oz1010.github.com/2025/10/22/Linux%E9%A9%B1%E5%8A%A8-USB%E8%AE%BE%E5%A4%87%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%AE%80%E4%BB%8B/</id>
    <published>2025-10-22T07:14:31.000Z</published>
    <updated>2026-01-21T06:34:01.230Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-USB协议栈简介</title>
    <link href="https://oz1010.github.com/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/"/>
    <id>https://oz1010.github.com/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/</id>
    <published>2025-09-01T10:42:30.000Z</published>
    <updated>2026-01-21T06:34:01.225Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>英文原文：<a href="https://www.kernel.org/doc/html/v6.1/driver-api/usb/index.html">LinuxUSB API</a></p></blockquote><h1 id="协议层">协议层</h1><h2 id="包格式">包格式</h2><p>USB协议层都是以包为基本单元，采用LSB（先发送低位）字节序。</p><p>Host发出SOP信号后，就会发出SYNC信号：它是一系列的、最大传输频率的脉冲，接收方使用它来同步数据。对于低速/全速设备，SYNC信号是8位数据(从做到右是00000001)；对于高速设备，SYNC信号是32位数据(从左到右是00000000000000000000000000000001)。使用NRZI编码时，前面每个”0”都对应一个跳变。具体包格式见下图（来自百问网）：</p><figure><img src="https://ldd.100ask.net/_images/23_usb_packet.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>USB包各部分介绍：</p><ul><li><code>SOP</code> 用来表示包起始</li><li><code>SYNC</code> 用来同步时钟</li><li><code>Packet</code> 实际有效的包数据</li><li><code>EOP</code> 用来表示包结束</li></ul><p>包（Packet）的具体结构：</p><ul><li><code>PID</code> 包类型</li><li><code>地址</code>USB设备的逻辑地址，Host发出的包中一般都需要包含目标设备的地址</li><li><code>帧号</code>和<code>数据</code>需要由包类型确定，具体需要查看协议文档</li><li><code>CRC</code> 校验码</li></ul><h3 id="包类型pid">包类型（PID）</h3><p>USB中数据方向都是基于Host角度来看的，<code>out</code>表示从Host发送数据到设备，<code>in</code>表示从设备发送数据到Host。由于设备都是被动响应的，因此完整的传输，都是由Host发起第一个包。</p><p>包数据里的PID按照<code>bit1-0</code>可以分为四大类：</p><ul><li>令牌包(Token)：01B</li><li>数据包(Data)：11B</li><li>握手包(Handshake)：10B</li><li>特殊包(Special)：00B</li></ul><p>PID低4位可以确定包类型，如下表所示：</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/26_pid.png" alt="image-20220819095112885"><figcaption aria-hidden="true">image-20220819095112885</figcaption></figure><p>PID决定了后续数据类型，为了降低出错的概率，额外增加4位用于取反校验。实际包中的PID由8位来表示，格式如下：</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/27_pid_field.png" alt="image-20220819100829291"><figcaption aria-hidden="true">image-20220819100829291</figcaption></figure><h3 id="令牌包token">令牌包（Token）</h3><p>令牌类的包作用是通知设备。</p><p>SOF（Start-of-Frame）令牌包是由主机固定频率发送的包。对于FS（full-speed）速率总线是间隔1.00ms ±0.0005 ms，对于HS（high-speed）速率总线是间隔125 µs ±0.0625µs。作用是通知所有设备，SOF令牌包格式如下：</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/28_sof_packet.png" alt="image-20251014095756916"><figcaption aria-hidden="true">image-20251014095756916</figcaption></figure><p>IN/OUT/SETUP令牌包通知特定设备，格式如下：</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/28_token_format.png" alt="image-20251014094921786"><figcaption aria-hidden="true">image-20251014094921786</figcaption></figure><h3 id="数据包data">数据包（Data）</h3><p>数据包包含PID域、0或多字节数据域和一个CRC域，如下图所示。有四种类型的数据包：DATA0、DATA1、DATA2、MDATA。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/29_data_packet_format.png" alt="image-20251014101326036"><figcaption aria-hidden="true">image-20251014101326036</figcaption></figure><h3 id="握手包handshake">握手包（Handshake）</h3><p>握手包只包含PID域。握手包用于汇报数据传输的状态，返回一个值表示数据成功接收、命令接收或拒绝、流控制、halt状态。</p><p>有四种类型的握手包和一种特殊的握手包：</p><ul><li>ACK，表明数据包成功接收或数据域没有CRC错误且PID域正确。</li><li>NAK，表明设备不能从host接收数据（OUT）或向host发送数据（IN）。</li><li>STALL，设备返回的响应，可以是对IN令牌包的响应、OUT的数据阶段的响应、PING传输的响应。</li><li>NYET，仅适用于HS设备。可以用于响应PING协议，或用于响应split传输时FS/HS设备未完成。</li><li>ERR，仅适用于HS设备。允许HS HUB报告总线上的错误。</li></ul><h2 id="数据翻转同步和重试">数据翻转同步和重试</h2><p>USB提供一种确保在数据收发者间数据序列同步的机制，通过使用DATA0和DATA1包和数据收发者的序列位翻转来实现。</p><p>初始化</p><p>控制传输使用SETUP令牌包初始化host和设备序列位，如下图所示：</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014191445444.png" alt="image-20251014191445444"><figcaption aria-hidden="true">image-20251014191445444</figcaption></figure><h3 id="成功的数据传输">成功的数据传输</h3><p>在每次传输中，接收者需要比较发送者的序列位（数据包PID域编码是DATA0或DATA1）是否与接收者序列位一致。若数据可接收并且收发序列位一致，序列位需要翻转。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014191858456.png" alt="image-20251014191858456"><figcaption aria-hidden="true">image-20251014191858456</figcaption></figure><h3 id="数据损坏或不可接收">数据损坏或不可接收</h3><p>若不能接收数据或数据已经损坏，接受者会发送NAK或STALL握手包，并且不会翻转它的序列位。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014192428739.png" alt="image-20251014192428739"><figcaption aria-hidden="true">image-20251014192428739</figcaption></figure><h3 id="损坏的ack握手包">损坏的ACK握手包</h3><p>当发送者没有收到正确的ACK，不会翻转序列位。当超时后会重试发送相同数据，直到接收到正确的ACK。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014192458575.png" alt="image-20251014192458575"><figcaption aria-hidden="true">image-20251014192458575</figcaption></figure><h2 id="事务transaction与传输transfer">事务（Transaction）与传输（Transfer）</h2><p>USB传输最基本的单元是包（Packet），包类型是PID域表示。单一的包无法完成完整数据的传输。一个完整数据传输往往需要包含到多个包：令牌包、数据包、握手包，而这个过程被称为事务（Transaction）。单个或多个事务组合起来就是一个传输（Transfer）。</p><p>不同事务类型包含包的数量不完全相同，它取决于端点（endpoint）类型。这里有四种端点类型：批量（bulk）、控制（control）、中断（interrupt）和实时（isochronous）。</p><p>如下就是一个完整的<code>BOT SCSI CMD</code>传输，总共包含三个批量事务：<code>CBW</code>事务、<code>SCSI DATA</code>事务和<code>CSW</code>事务。而每个事务都是一个批量事务类型，都是一个三阶段的事务。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251017111355123.png" alt="image-20251017111355123"><figcaption aria-hidden="true">image-20251017111355123</figcaption></figure><h3 id="批量事务bulk">批量事务（Bulk）</h3><p>批量事务类型的特点是能够通过错误检测和重试，在主机与功能之间保证数据无错误的传输。它使用三阶段的事务包括：令牌包、数据包、握手包。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014195341690.png" alt="image-20251014195341690"><figcaption aria-hidden="true">image-20251014195341690</figcaption></figure><p>常见支持批量事务的设备有：USB存储设备。</p><h3 id="控制传输control">控制传输（Control）</h3><p>控制传输至少有两个事务阶段：设置（Setup）和状态（Status）。控制传输可选择在设置阶段和状态阶段之间包含一个数据（Data）阶段。在设置阶段，使用SETUP 事务将信息传送到功能的控制端点。SETUP 事务的格式类似于OUT，但使用的是 SETUP PID 而不是 OUT PID。</p><p>下图是一个SETUP事务包含三个包：SETUP包、DATA0包、ACK包。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014195855230.png" alt="image-20251014195855230"><figcaption aria-hidden="true">image-20251014195855230</figcaption></figure><p>若存在，控制传输会包含数据阶段，由一个或多个IN或OUT事务组成，遵循与批量事务相同的协议规则。所有在数据阶段的传输事务保持相同的方向（例如全IN事务或全OUT事务）。一个SETUP总是使用DATA0的PID作为SETUP事务的数据域。</p><p>控制传输的状态阶段是序列上的最后一个事务。状态阶段事物遵循与批量事务相同的协议序列。例如，当数据阶段包含全OUT事务，状态就是一个IN事务。若控制序列没有数据阶段，则状态就是一个IN事务。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251014195928566.png" alt="image-20251014195928566"><figcaption aria-hidden="true">image-20251014195928566</figcaption></figure><p>所有的USB设备必须支持的传输类型。</p><h3 id="中断事务interrupt">中断事务（Interrupt）</h3><p>中断事务使用三阶段的事务包括：令牌包、数据包、握手包。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251017113514694.png" alt="image-20251017113514694"><figcaption aria-hidden="true">image-20251017113514694</figcaption></figure><p>中断事务跟批量事务非常类似，不同的是Host会周期性地发送事务进行数据读写。常见支持中断事务的设备有：USB鼠标、USB键盘等。</p><h3 id="实时事务isochronous">实时事务（Isochronous）</h3><p>实时事务包含一个令牌和一个数据阶段，但没有握手阶段。实时事务不支持握手阶段或重试能力。</p><figure><img src="/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-USB%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/image-20251022144041260.png" alt="image-20251022144041260"><figcaption aria-hidden="true">image-20251022144041260</figcaption></figure><p>实时事务需要Host周期性的发起，相比中断事务，不要求准确性，传输的数据量比较大。常见支持实时事务的设备有USB摄像头。</p><h1 id="附录">附录</h1><h2 id="参考文档">参考文档</h2><ul><li>百问网文档：<a href="https://ldd.100ask.net/zh/12_USB/04_1.html">04_USB协议层数据格式 —Linux设备驱动开发教程中心</a></li><li>《Universal Serial Bus Specification V2.0》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;英文原文：&lt;a href=&quot;https://www.kernel.org/doc/html/v6.1/driver-api/usb/index.html&quot;&gt;Linux
USB API&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;协议</summary>
      
    
    
    
    <category term="Linux" scheme="https://oz1010.github.com/categories/Linux/"/>
    
    <category term="Driver" scheme="https://oz1010.github.com/categories/Linux/Driver/"/>
    
    <category term="USB" scheme="https://oz1010.github.com/categories/Linux/Driver/USB/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux驱动-存储协议栈简介</title>
    <link href="https://oz1010.github.com/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-%E5%AD%98%E5%82%A8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/"/>
    <id>https://oz1010.github.com/2025/09/01/Linux%E9%A9%B1%E5%8A%A8-%E5%AD%98%E5%82%A8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B/</id>
    <published>2025-09-01T10:27:52.000Z</published>
    <updated>2026-01-21T06:34:01.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.thomas-krenn.com/en/wiki/Category:Linux">wiki -Server Software</a></p><figure><img src="https://www.thomas-krenn.com/en/wikiEN/images/8/88/Linux-storage-stack-diagram_v6.16.png" alt="Linux Storage Stack Diagram (Linux Kernel 6.16)"><figcaption aria-hidden="true">Linux Storage Stack Diagram (Linux Kernel6.16)</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.thomas-krenn.com/en/wiki/Category:Linux&quot;&gt;wiki -
Server Software&lt;/a&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://www.thomas-krenn.</summary>
      
    
    
    
    <category term="Linux" scheme="https://oz1010.github.com/categories/Linux/"/>
    
    <category term="Driver" scheme="https://oz1010.github.com/categories/Linux/Driver/"/>
    
    
  </entry>
  
  <entry>
    <title>V2Ray新脚本安装服务器-适合新手小白</title>
    <link href="https://oz1010.github.com/2025/08/28/V2Ray%E6%96%B0%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD/"/>
    <id>https://oz1010.github.com/2025/08/28/V2Ray%E6%96%B0%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD/</id>
    <published>2025-08-28T09:54:57.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先插播广告</strong></p><p>使用<a href="https://www.vultr.com/?ref=9798034">Vultr</a>，充值就送美金，便宜还可免费换ip</p><ol type="1"><li>最低3.5美金（2.5美金的仅支持ipv6访问），性能足够使用！</li><li>可以保存快照，随时迁移新的IP地址，而且免费！</li><li>可以使用支付宝和微信，相当方便！</li></ol><h1 id="服务器端的工作">服务器端的工作</h1><h2 id="安装脚本">安装脚本</h2><p>运行以下脚本即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Ls https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh | <span class="built_in">sudo</span> bash</span><br></pre></td></tr></table></figure><p>里面可能会有些报错信息，暂时不管，完成之后就是配置了</p><h2 id="获取用户id">获取用户ID</h2><p>之前的脚本，不用手动配置脚本即可使用，现在使用以上脚本，需要自己配置config.json文件，首先获取用户ID：</p><p>运用指令：cat /proc/sys/kernel/random/uuid 创建一个用户 id，并记住这个id号；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr ~]# <span class="built_in">cat</span> /proc/sys/kernel/random/uuid </span><br><span class="line">08ef6234-dcc0-45d1-9954-f9490cb2beb2</span><br></pre></td></tr></table></figure><h2 id="配置">配置</h2><p>配置文件路径为/usr/local/etc/v2ray/config.json</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;inbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: 12345,</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;vmess&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;clients&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: <span class="string">&quot;08ef6234-dcc0-45d1-9954-f9490cb2beb2&quot;</span>,</span><br><span class="line">          <span class="string">&quot;level&quot;</span>: 1,</span><br><span class="line">          <span class="string">&quot;alterId&quot;</span>: 0</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">&quot;outbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;blackhole&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;blocked&quot;</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">&quot;routing&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;field&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: [<span class="string">&quot;geoip:private&quot;</span>],</span><br><span class="line">        <span class="string">&quot;outboundTag&quot;</span>: <span class="string">&quot;blocked&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red; font-weight:bold">直接复制我上面的配置即可使用，id就是上面第二步获取的用户id</span></p><h2 id="启动v2ray">启动V2Ray</h2><p>在首次安装完成之后，V2Ray不会自动启动，需要手动运行上述启动命令。而在已经运行V2Ray的VPS上再次执行安装脚本，安装脚本会自动停止V2Ray进程，升级V2Ray程序，然后自动运行V2Ray。在升级过程中，配置文件不会被修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start v2ray</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop v2ray</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart v2ray</span><br><span class="line"><span class="comment"># 使能</span></span><br><span class="line">systemctl <span class="built_in">enable</span> v2ray</span><br></pre></td></tr></table></figure><p>关于软件更新：更新 V2Ray的方法是再次执行安装脚本！再次执行安装脚本！再次执行安装脚本！</p><h2 id="打开防火墙">打开防火墙</h2><p>centos系统防火墙默认是开启的，上面第三步你用了一个端口，因此你需要打开这个端口，指令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加开放端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=12345/tcp --permanent</span><br><span class="line"><span class="comment"># 重载防火墙配置，不然查看开放端口都查不到，也不能用，重载配置后即可</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 删除端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=123456/tcp --permanent</span><br><span class="line"><span class="comment"># 查看已开放端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="comment"># 查看防火墙firewalld状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="comment"># 开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>如果哪一天发现怎么无法使用了，有可能是IP被屏蔽，也有肯能是端口被封，这个时候就需要换个端口，别忘记防火墙开启新端口，那旧端口就可以删除了</p><h1 id="客户端下载和使用">客户端下载和使用</h1><h2 id="windows客户端下载">Windows客户端下载</h2><h3 id="工具下载">工具下载</h3><p><a href="https://github.com/v2ray/v2ray-core/releases">v2ray-core发布地址</a></p><p><a href="https://github.com/2dust/v2rayN/releases">v2rayN发布地址</a></p><h2 id="android客户端下载">Android客户端下载</h2><h3 id="工具下载-1">工具下载</h3><p><a href="https://github.com/2dust/v2rayNG/releases">v2rayNG发布地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;先插播广告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;a href=&quot;https://www.vultr.com/?ref=9798034&quot;&gt;Vultr&lt;/a&gt;，充值就送美金，便宜还可免费换ip&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;最低3.5美金（2.5</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VStream项目设计</title>
    <link href="https://oz1010.github.com/2025/08/23/VStream%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/"/>
    <id>https://oz1010.github.com/2025/08/23/VStream%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-08-23T02:21:08.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频<a href="https://www.bilibili.com/video/BV1Fk4y1i7o9?p=7&amp;vd_source=59da135eea9f4cd9bc69b8a8f0962837">Go语言实战流媒体视频网站</a></p><figure><img src="https://p0.oz1010.site:39890/images/2023/09/10/image-20230910170948393.png" alt="image-20230910170948393"><figcaption aria-hidden="true">image-20230910170948393</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/09/10/image-20230910171329127.png" alt="image-20230910171329127"><figcaption aria-hidden="true">image-20230910171329127</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/09/10/image-20230910174915494.png" alt="image-20230910174915494"><figcaption aria-hidden="true">image-20230910174915494</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/09/10/image-20230910175816228.png" alt="image-20230910175816228"><figcaption aria-hidden="true">image-20230910175816228</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频&lt;a href=&quot;https://www.bilibili.com/video/BV1Fk4y1i7o9?p=7&amp;amp;vd_source=59da135eea9f4cd9bc69b8a8f0962837&quot;&gt;Go语言实战流媒体视频网站&lt;/a&gt;&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FreeRTOS学习笔记</title>
    <link href="https://oz1010.github.com/2025/01/23/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://oz1010.github.com/2025/01/23/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-01-23T07:54:49.000Z</published>
    <updated>2026-01-21T06:34:01.225Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.amazonaws.cn/freertos/latest/userguide/dev-guide-freertos-kernel.html">官方机器翻译版本</a></p><p>官方参考手册：</p><p>开发板整体布局<a href="https://developer.arm.com/documentation/dai0385/d/?lang=en">AN385- ARM Cortex-M3 SMM on V2M-MPS2</a></p><p>子系统相关<a href="https://developer.arm.com/documentation/ddi0479/c">Cortex-M SystemDesign Kit Technical Reference Manual r1p0</a></p><p>代码为官方示例程序：FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC</p><h2 id="系统结构">系统结构</h2><h3 id="配置文件">配置文件</h3><p><code>FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/FreeRTOSConfig.h</code>工程下的系统配置文件</p><ul><li>configSUPPORT_DYNAMIC_ALLOCATION 栈内存管理</li></ul><h3 id="关键组件">关键组件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FreeRTOS</span><br><span class="line">|-Source</span><br><span class="line">  |-tasks.c<span class="comment"># 必备；提供任务管理</span></span><br><span class="line">    list.c <span class="comment"># 必备；提供列表管理</span></span><br><span class="line">    queue.c <span class="comment"># 基本必备；提供队列管理</span></span><br><span class="line">    timers.c<span class="comment"># 可选；提供定时器管理</span></span><br><span class="line">    event_groups.c<span class="comment"># 可选；提供事件组管理</span></span><br><span class="line">    croutine.c<span class="comment"># 可选；提供协程管理</span></span><br></pre></td></tr></table></figure><p><code>FreeRTOS/Source/portable/MemMang</code>提供heap_1~5堆申请实现</p><p>头文件路径：</p><ul><li><code>FreeRTOS/Source/include</code>系统内核头文件</li><li><code>FreeRTOS/Source/portable/[compiler]/[architecture]</code>BSP头文件</li><li><code>FreeRTOSConfig.h</code>配置文件</li></ul><h3 id="bsp">BSP</h3><p><code>FreeRTOS/Source/portable/[compiler]/[architecture]</code>特定编译器和架构的文件</p><h2 id="m3内核寄存器">M3内核寄存器</h2><p>r0~r12</p><p>sp</p><p>lr</p><p>pc</p><p>xpsr</p><h2 id="初始化">初始化</h2><h3 id="重置入口reset_handler">重置入口Reset_Handler</h3><p>初始化<code>pc</code>寄存器指向<code>0x80</code>（应该有默认引导指向这里）</p><p><code>mps2_m3.ld</code>定义了内存分布和关键变量分布，<code>ld</code>是ARM的链接配置文件，在编译时有<code>-T ./scripts/mps2_m3.ld</code>选项指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 文件FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/scripts/mps2_m3.ld</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    FLASH (xr) : ORIGIN = 0x00000000, LENGTH = 4M /* to 0x00003FFF = 0x007FFFFF*/</span><br><span class="line">    RAM (xrw)  : ORIGIN = 0x20000000, LENGTH = 4M /* to 0x21FFFFFF = 0xFFFFFF */</span><br><span class="line">&#125;</span><br><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);</span><br><span class="line"></span><br><span class="line">    _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">    .data : /* AT ( _sidata ) */</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _sdata = .;</span><br><span class="line">        *(.data*)</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _edata = .;</span><br><span class="line">    &#125; &gt; RAM AT &gt; FLASH</span><br><span class="line">    </span><br><span class="line">    .bss :</span><br><span class="line">    &#123;</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _sbss = .;</span><br><span class="line">        __bss_start__ = _sbss;</span><br><span class="line">        *(.bss*)</span><br><span class="line">        *(COMMON)</span><br><span class="line">        . = ALIGN(4);</span><br><span class="line">        _ebss = .;</span><br><span class="line">        __bss_end__ = _ebss;</span><br><span class="line">    &#125; &gt;RAM</span><br></pre></td></tr></table></figure><p><code>ENTRY(Reset_Handler)</code>指定汇编入口</p><p>这里<code>_sidata</code>变量为代码的<code>.data</code>起始处数据（地址为<code>0x56e8</code>）。<code>_sdata</code>和<code>_edata</code>分别是4字节对齐（ARM处理器没对齐会出现异常）用于存放<code>.data</code>数据的内存起止数据处（地址为<code>0x20000100</code>和<code>0x20000178</code>）。</p><p><code>_sbss</code>和<code>_ebss</code>分别是内存<code>.bss</code>区域起止数据（地址为<code>0x20000180</code>和<code>0x200064a0</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/init/startup.c</span></span><br><span class="line"><span class="comment">/* Prevent optimization so gcc does not replace code with memcpy */</span></span><br><span class="line">__attribute__((optimize(<span class="string">&quot;O0&quot;</span>)))</span><br><span class="line">__attribute__((naked)) <span class="type">void</span></span><br><span class="line"><span class="title function_">Reset_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* set stack pointer */</span></span><br><span class="line">    __asm <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ldr r0, =_estack&quot;</span>)</span>;</span><br><span class="line">    __asm <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov sp, r0&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy .data section from flash to RAM */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> *src = &amp;_sidata, *dest = &amp;_sdata; dest &lt; &amp;_edata;)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zero out .bss section */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> *dest = &amp;_sbss; dest &lt; &amp;_ebss;)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest++ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* jump to board initialisation */</span></span><br><span class="line">    <span class="type">void</span> _start(<span class="type">void</span>);</span><br><span class="line">    _start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置栈指针</strong></p><p>入口函数<code>__attribute__((optimize("O0"))) __attribute__((naked))</code>定义避免优化，这两个是属于<code>GNU C</code>的编译属性控制编译过程。</p><p><code>__asm volatile("ldr r0, =_estack");</code>中<code>__asm</code>封装为<code>asm</code>，标注C内联汇编，<code>volatile</code>直接从Flash上读取<code>_estack</code>的值，这个值在就是<code>0x20400000</code>，即将栈指针指向内存最高处。</p><p><strong>拷贝<code>.data</code>区域</strong></p><p>将Flash的<code>.data</code>区域拷贝到内存中，内存中数据起止地址4字节对齐。</p><p><strong>清空<code>.bss</code>区域</strong></p><p>将内存<code>.bss</code>区域数据清零。</p><p><strong>跳转启动函数</strong></p><p>跳转到C语言入口处函数<code>_start</code></p><h3 id="启动函数_start">启动函数_start</h3><p>首先初始化串口，再进入主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/init/startup.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _start(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    uart_init();</span><br><span class="line">    main(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串口初始化uart_init">串口初始化uart_init</h3><p>配置波特率并开启发送</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UART0_ADDR-&gt;BAUDDIV = <span class="number">16</span>;</span><br><span class="line">    UART0_ADDR-&gt;CTRL = UART_CTRL_TX_EN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主函数main">主函数main</h3><p>这里也只负责调用不同实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Demo/CORTEX_M3_MPS2_QEMU_GCC/main_blinky.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    main_blinky();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例函数main_blinky">示例函数main_blinky</h3><p>首先创建队列用于两任务进行通信。再创建收发队列任务，启动任务调度器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main_blinky</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create the queue. */</span></span><br><span class="line">    xQueue = xQueueCreate( mainQUEUE_LENGTH, <span class="keyword">sizeof</span>( <span class="type">uint32_t</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xQueue != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Start the two tasks as described in the comments at the top of this</span></span><br><span class="line"><span class="comment">         * file. */</span></span><br><span class="line">        xTaskCreate( prvQueueReceiveTask,             <span class="comment">/* The function that implements the task. */</span></span><br><span class="line">                     <span class="string">&quot;Rx&quot;</span>,                            <span class="comment">/* The text name assigned to the task - for debug only as it is not used by the kernel. */</span></span><br><span class="line">                     configMINIMAL_STACK_SIZE,        <span class="comment">/* The size of the stack to allocate to the task. */</span></span><br><span class="line">                     <span class="literal">NULL</span>,                            <span class="comment">/* The parameter passed to the task - not used in this case. */</span></span><br><span class="line">                     mainQUEUE_RECEIVE_TASK_PRIORITY, <span class="comment">/* The priority assigned to the task. */</span></span><br><span class="line">                     <span class="literal">NULL</span> );                          <span class="comment">/* The task handle is not required, so NULL is passed. */</span></span><br><span class="line"></span><br><span class="line">        xTaskCreate( prvQueueSendTask,</span><br><span class="line">                     <span class="string">&quot;TX&quot;</span>,</span><br><span class="line">                     configMINIMAL_STACK_SIZE,</span><br><span class="line">                     <span class="literal">NULL</span>,</span><br><span class="line">                     mainQUEUE_SEND_TASK_PRIORITY,</span><br><span class="line">                     <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Start the tasks and timer running. */</span></span><br><span class="line">        vTaskStartScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If all is well, the scheduler will now be running, and the following</span></span><br><span class="line"><span class="comment">     * line will never be reached.  If the following line does execute, then</span></span><br><span class="line"><span class="comment">     * there was insufficient FreeRTOS heap memory available for the Idle and/or</span></span><br><span class="line"><span class="comment">     * timer tasks to be created.  See the memory management section on the</span></span><br><span class="line"><span class="comment">     * FreeRTOS web site for more details on the FreeRTOS heap</span></span><br><span class="line"><span class="comment">     * http://www.freertos.org/a00111.html. */</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统函数">系统函数</h2><h3 id="队列-创建">队列-创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Source/queue.c</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueGenericCreate</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType )</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS-Plus/Source/AWS/ota/test/cbmc/FreeRTOS-Kernel/include/queue.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_BASE                  ( ( uint8_t ) 0U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_SET                   ( ( uint8_t ) 0U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_MUTEX                 ( ( uint8_t ) 1U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_COUNTING_SEMAPHORE    ( ( uint8_t ) 2U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_BINARY_SEMAPHORE      ( ( uint8_t ) 3U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queueQUEUE_TYPE_RECURSIVE_MUTEX       ( ( uint8_t ) 4U )</span></span><br></pre></td></tr></table></figure><p><strong>输入参数</strong></p><ul><li><code>uxQueueLength</code>队列长度</li><li><code>uxItemSize</code>队列元素大小</li><li><code>ucQueueType</code>队列类型，参考头文件可以填写<code>queueQUEUE_TYPE_xxx</code></li></ul><p><strong>输出参数</strong></p><ul><li><code>QueueHandle_t</code>队列指针</li></ul><p><strong>内部调用逻辑</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xQueueGenericCreate</span><br><span class="line">|-pvPortMalloc // 申请足够的内存</span><br><span class="line">  |-vTaskSuspendAll // 进入关键区域，将调度器挂起uxSchedulerSuspended加1，</span><br><span class="line">    |-portSOFTWARE_BARRIER // 等待内部中断xInsideInterrupt处理完</span><br><span class="line">      portMEMORY_BARRIER // 内存屏障，M3不需要？？</span><br><span class="line">    xTaskResumeAll</span><br><span class="line">    malloc // C库函数，申请内存</span><br><span class="line">  prvInitialiseNewQueue // 初始化队列结构</span><br><span class="line">  |-xQueueGenericReset // 队列通用初始化，为结构体赋值</span><br></pre></td></tr></table></figure><p><strong>其他</strong></p><p>队列内存结构为：<code>Queue_t</code>头部信息数据+元素数据列表</p><h3 id="队列-发送数据">队列-发送数据</h3><h3 id="队列-接收数据">队列-接收数据</h3><h3 id="任务-全部恢复">任务-全部恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure><p>注意</p><p>函数<code>xTaskResumeAll</code>与函数<code>vTaskSuspendAll</code>需要成对出现</p><p>内部调用逻辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xTaskResumeAll</span><br><span class="line">|-vPortEnterCritical <span class="comment"># 宏包装taskENTER_CRITICAL</span></span><br></pre></td></tr></table></figure><h3 id="列表">列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSv202112.00/FreeRTOS/Source/list.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vListInitialise</span><span class="params">( List_t * <span class="type">const</span> pxList )</span></span><br></pre></td></tr></table></figure><h2 id="关键结构">关键结构</h2><h3 id="时钟滴答">时钟滴答</h3><p><code>TickType_t</code></p><p><code>configUSE_16_BIT_TICKS</code>时钟滴答计数值类型。1–16位<code>uint16_t</code>；0–32位<code>uint32_t</code></p><h3 id="基本数据">基本数据</h3><p><code>BaseType_t</code></p><p>定义为架构中执行效率最高的数据类型。它的典型的是，32位架构上为32位，16位架构上为16位，8位架构上为8位。</p><p>布尔型<code>pdTRUE/pdFALSE</code>也被定义为<code>BaseType_t</code></p><h3 id="队列">队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> xQUEUE Queue_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int8_t</span> *pcHead;    <span class="comment">/*&lt; 指向存储数据区开始处，即跳过头部区域 */</span></span><br><span class="line">    <span class="type">int8_t</span> *pcWriteTo; <span class="comment">/*&lt; 指向存储数据区可使用处，跳过已经入队的元素 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        QueuePointers_t xQueue;     <span class="comment">/*&lt; 队列数据，pcTail指向存储数据区结束处；pcReadFrom指向存储数据区最后一元素区域 */</span></span><br><span class="line">        SemaphoreData_t xSemaphore; <span class="comment">/*&lt; 信号量使用 */</span></span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    List_t xTasksWaitingToSend;    <span class="comment">/*&lt; 阻塞等待写入数据的任务列表，按优先级排序 */</span></span><br><span class="line">    List_t xTasksWaitingToReceive; <span class="comment">/*&lt; 阻塞等待读取数据的任务列表，按优先级排序. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxMessagesWaiting; <span class="comment">/*&lt; 当前队列中元素个数 */</span></span><br><span class="line">    UBaseType_t uxLength;                   <span class="comment">/*&lt; 队列元素个数. */</span></span><br><span class="line">    UBaseType_t uxItemSize;                 <span class="comment">/*&lt; 队列元素大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cRxLock; <span class="comment">/*&lt; 上锁时，存储从队列移除元素数；无锁时，值为queueUNLOCKED */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int8_t</span> cTxLock; <span class="comment">/*&lt; 上锁时，存储向队列添加元素数；无锁时，值为queueUNLOCKED */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ((configSUPPORT_STATIC_ALLOCATION == 1) &amp;&amp; (configSUPPORT_DYNAMIC_ALLOCATION == 1))</span></span><br><span class="line">    <span class="type">uint8_t</span> ucStaticallyAllocated; <span class="comment">/*&lt; Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (configUSE_QUEUE_SETS == 1)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueDefinition</span> *<span class="title">pxQueueSetContainer</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (configUSE_TRACE_FACILITY == 1)</span></span><br><span class="line">    UBaseType_t uxQueueNumber;</span><br><span class="line">    <span class="type">uint8_t</span> ucQueueType;<span class="comment">/*&lt; 队列类型 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; xQUEUE;</span><br></pre></td></tr></table></figure><h3 id="任务控制块">任务控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span>       /* <span class="title">The</span> <span class="title">old</span> <span class="title">naming</span> <span class="title">convention</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">prevent</span> <span class="title">breaking</span> <span class="title">kernel</span> <span class="title">aware</span> <span class="title">debuggers</span>. */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> StackType_t * pxTopOfStack; <span class="comment">/*&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">        xMPU_SETTINGS xMPUSettings; <span class="comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ListItem_t xStateListItem;                  <span class="comment">/*&lt; The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */</span></span><br><span class="line">    ListItem_t xEventListItem;                  <span class="comment">/*&lt; Used to reference a task from an event list. */</span></span><br><span class="line">    UBaseType_t uxPriority;                     <span class="comment">/*&lt; The priority of the task.  0 is the lowest priority. */</span></span><br><span class="line">    StackType_t * pxStack;                      <span class="comment">/*&lt; Points to the start of the stack. */</span></span><br><span class="line">    <span class="type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="comment">/*&lt; Descriptive name given to the task when created.  Facilitates debugging only. */</span> <span class="comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span></span><br><span class="line">        StackType_t * pxEndOfStack; <span class="comment">/*&lt; Points to the highest valid address for the stack. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">        UBaseType_t uxCriticalNesting; <span class="comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">        UBaseType_t uxTCBNumber;  <span class="comment">/*&lt; Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */</span></span><br><span class="line">        UBaseType_t uxTaskNumber; <span class="comment">/*&lt; Stores a number specifically for use by third party trace code. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">        UBaseType_t uxBasePriority; <span class="comment">/*&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */</span></span><br><span class="line">        UBaseType_t uxMutexesHeld;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">        TaskHookFunction_t pxTaskTag;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">        <span class="type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; <span class="comment">/*&lt; Stores the amount of time the task has spent in the Running state. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate a Newlib reent structure that is specific to this task.</span></span><br><span class="line"><span class="comment">         * Note Newlib support has been included by popular demand, but is not</span></span><br><span class="line"><span class="comment">         * used by the FreeRTOS maintainers themselves.  FreeRTOS is not</span></span><br><span class="line"><span class="comment">         * responsible for resulting newlib operation.  User must be familiar with</span></span><br><span class="line"><span class="comment">         * newlib and must provide system-wide implementations of the necessary</span></span><br><span class="line"><span class="comment">         * stubs. Be warned that (at the time of writing) the current newlib design</span></span><br><span class="line"><span class="comment">         * implements a system-wide malloc() that must be provided with locks.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html</span></span><br><span class="line"><span class="comment">         * for additional information. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  _<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See the comments in FreeRTOS.h with the definition of</span></span><br><span class="line"><span class="comment">     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) <span class="comment">/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */</span></span></span><br><span class="line">        <span class="type">uint8_t</span> ucStaticallyAllocated;                     <span class="comment">/*&lt; Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">        <span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span></span><br><span class="line">        <span class="type">int</span> iTaskErrno;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure><h2 id="目标">目标</h2><p>移植CORTEX_LM3S811_GCC为QEMU中运行</p><h2 id="问题">问题</h2><h3 id="内联汇编指令寄存器重排">内联汇编指令寄存器重排</h3><p><code>__asm volatile("push &#123;r1,r0,lr&#125;");</code>实际产生的汇编是<code>push &#123;r0,r1,lr&#125;</code>，容易造成<code>pop &#123;r3,r4,lr&#125;</code>理解偏差。</p><h2 id="官方手册简介">官方手册简介</h2><p>所有变量类型都显示声明为<code>signed</code>或<code>unsigned</code>；</p><p>变量命名规则：<code>c</code>代表<code>char</code>，<code>s</code>代表<code>int16_t</code>，<code>l</code>代表<code>int32_t(long)</code>，<code>x</code>代表<code>BaseType_t</code>；前缀<code>u</code>代表<code>unsigned</code>，<code>p</code>代表指针；</p><p>函数命名规则：使用前缀标识返回值类型；在变量命名规则上，增加<code>v</code>代表<code>void</code>；</p><p>宏名称命名规则：使用小写单词开头标明宏定义位置；</p><h2 id="堆管理">堆管理</h2><h3 id="基本情况">基本情况</h3><p>C标准库的内存管理不适合嵌入式的原因：</p><ul><li>在小型嵌入式系统中并不是都是可用的；</li><li>实现体积比较大，会消耗可贵的代码空间；</li><li>很少是线程安全的；</li><li>运行不确定性；执行函数所花费的时间在不同调用会有差异；</li><li>会遭受内存碎片侵蚀；</li><li>会使链接器配置变复杂；</li><li>若允许栈空间增长到正在使用的内存中，它们可能称为难以调试错误的来源；</li></ul><p>pvPortMalloc</p><p>vPortFree</p><p><code>FreeRTOS/Source/portable/MemMang</code>中定义了5中栈管理方式：heap_1~heap_5</p><p><code>configTOTAL_HEAP_SIZE</code>配置栈空间大小</p><p>创建每个任务都需要从内存分配任务控制块（Task Control Block,TCB）和栈空间。</p><h3 id="申请内存">申请内存</h3><h4 id="heap_1">Heap_1</h4><p>适合仅仅创建任务和其他内核对象的场景。只实现内存申请，而没有实现内存释放接口。</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/19/image-20230219214120657.png" alt="image-20230219214120657"><figcaption aria-hidden="true">image-20230219214120657</figcaption></figure><h4 id="heap_2">Heap_2</h4><p>提前分配内存块，大小由参数决定</p><p>configTOTAL_HEAP_SIZE</p><p>适合重复创建任务，但任务大小一致的场景</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/22/image-20230222092456582.png" alt="image-20230222092456582"><figcaption aria-hidden="true">image-20230222092456582</figcaption></figure><p>非确定性，当运行速度比标准库块</p><p>推荐使用Heap_4代替Heap_2</p><h4 id="heap_3">Heap_3</h4><p>使用标准库函数管理内存，通过暂停调度来保障线程安全</p><h4 id="heap_4">Heap_4</h4><p>与Heap_1和Heap_4一样，将内存划分为小块。</p><p>拥有合并相邻空闲内存的功能，减少内存碎片的风险。</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/22/image-20230222093624554.png" alt="image-20230222093624554"><figcaption aria-hidden="true">image-20230222093624554</figcaption></figure><p>有时需要确保使用的是内部内存，可以配置configAPPLICATION_ALLOCATED_HEAP为1，内存数据将由应用程序声明的数据替换。数据类型为<code>uint8_t</code>的<code>ucHeap</code>数组，大小为configTOTAL_HEAP_SIZE。</p><p>不同编译器的语法不一样。</p><p>使用GCC语法声明heap_4使用的数组，数组将会在<code>.my_heap</code>区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ucHeap[configTOTAL_HEAP_SIZE] __attribute__((section(<span class="string">&quot;.my_heap&quot;</span>)));</span><br></pre></td></tr></table></figure><p>使用IAR语法声明heap_4使用的数组，数组将会在绝对地址<code>0x20000000</code>处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ucHeap[configTOTAL_HEAP_SIZE] @ <span class="number">0x20000000</span>;</span><br></pre></td></tr></table></figure><h4 id="heap_5">Heap_5</h4><p>分配算法与Heap_4一样，不同的是，Heap_5可以使用非连续的内存区域。</p><p>在使用前，必须显示调用<code>vPortDefineHeapRegions()</code>完成内存初始化。函数参数是区域结构体数组，每块区域结构体类型为<code>HeapRegion_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapRegion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> *pucStartAddress;</span><br><span class="line">    <span class="type">size_t</span> xSizeInBytes;</span><br><span class="line">&#125; HeapRegion_t;</span><br></pre></td></tr></table></figure><p>显示声明时，内存地址<code>pucStartAddress</code>必须从低到高的顺序声明，并且有结束的区域<code>pucStartAddress=NULL</code>。</p><p>例如有三块内存区域：</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/22/image-20230222102857053.png" alt="image-20230222102857053"><figcaption aria-hidden="true">image-20230222102857053</figcaption></figure><p>使用Heap_5需要显示初始化这几块内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> HeapRegion_t xHeapRegion[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="number">0x00010000</span>, <span class="number">65</span>*<span class="number">1024</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="number">0x00020000</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="number">0x00030000</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,                  <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vPortDefineHeapRegions(xHeapRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若真按上面代码初始化，就没有内存给其他变量使用。在项目中，链接阶段将会分配每个变量内存地址。可以将RAM1划分为两个区域，<code>0x0001nnn</code>以上区域由系统内存管理。优化后的GCC版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAM1_HEAP_SIZE (30*1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ucHeap[RAM1_HEAP_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> HeapRegion_t xHeapRegion[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;ucHeap,                RAM1_HEAP_SIZE&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="number">0x00020000</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="number">0x00030000</span>, <span class="number">32</span>*<span class="number">1024</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,                  <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vPortDefineHeapRegions(xHeapRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆相关函数">堆相关函数</h3><h4 id="xportgetfreeheapsize">xPortGetFreeHeapSize</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p>返回堆中可用字节数。</p><p>使用heap_3时，函数不可用。</p><h4 id="xportgetminimumeverfreeheapsize">xPortGetMinimumEverFreeHeapSize</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p>返回应用开始执行后，历史最小可用字节数。</p><p>只有heap_4和heap_5可使用此函数。</p><h4 id="内存申请失败钩子函数">内存申请失败钩子函数</h4><p>当调用<code>pvPortMalloc</code>没有足够内存时，将会返回NULL，即内存申请失败。若应用需要处理这种场景，需要配置configUSE_MALLOC_FAILED_HOOK，然后应用需要实现内存申请失败钩子函数，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h2 id="任务管理">任务管理</h2><h3 id="章节介绍和范围">3.1 章节介绍和范围</h3><h4 id="范围">范围</h4><p>本章旨在让读者很好地理解：</p><ul><li><p>FreeRTOS如何为应用程序中的每个任务分配处理时间。</p></li><li><p>FreeRTOS如何在任何给定时间内选择任务执行。</p></li><li><p>每个任务的相对优先级如何影响系统行为。</p></li><li><p>任务可以存在的状态。</p></li></ul><p>读者还可以容易理解：</p><ul><li>如何实现任务。</li><li>如何创建一个或多个任务的实例。</li><li>如何使用任务参数。</li><li>如何更改已经创建的任务的优先级。</li><li>如何删除一个任务。</li><li>如何使用任务实现周期性处理（软件计时器将在后面的一章中讨论）。</li><li>空闲任务的执行时间以及如何使用它。</li></ul><p>本章中介绍的概念是理解FreeRTOS的基础：如何使用系统和系统应用程序的行为。所以，这也是本书中最详细章节。</p><h3 id="任务函数">3.2 任务函数</h3><p>任务都是由C语言函数实现。它们唯一特殊之处在于函数原型，它必须返回<code>void</code>类型并接受一个<code>void</code>类型指针。Listing11展示了函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 11</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure><p>每个任务本身都是一个小程序。它有一个入口，通常会在无限循环中永久运行，并且不会退出。Listing12展示了典型的任务结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 12</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 变量可以像普通函数一样进行声明。使用此示例函数创建的每个任务实例，都有其lVariableExample变量的副本。如果变量声明为静态，这就是错误的。在这种情况下，变量只有一个副本，并且副本将被创建的任务实例共享。（变量名称中的前缀参考章节1.5 数据类型和编码风格指南。） */</span></span><br><span class="line">    <span class="type">int32_t</span> lVariableExample = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 任务通常被实现为无限循环。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 实现任务功能的代码写到这里。 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 即使任务跳出循环，那么必须在其实现函数结束之前将任务删除。传递给vTaskDelete() API函数的NULL参数，它表示要删除的是调用（此）任务。API函数命名规范在0章节中已描述。 */</span></span><br><span class="line">    vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务不需要，应该调用删除任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> lVariableExample = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 一般就是无限循环 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 任务功能代码逻辑. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 一定要返回，需要显示调用删除 */</span></span><br><span class="line">    vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶层任务状态">顶层任务状态</h3><p>简化模型，假定系统中只有一个核，有许多任务需要运行。当任务为运行状态时，处理器会执行任务代码。当任务为非运行状态时，任务被休眠，运行上下文将会被保存。当任务恢复运行状态时，运行上下文也需要恢复。</p><p>由非运行态转为运行态的任务称为被切入或换入，反之，称为被切出或换出。系统中调度器是唯一能切换任务的实体。</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/22/image-20230222111533707.png" alt="image-20230222111533707"><figcaption aria-hidden="true">image-20230222111533707</figcaption></figure><h3 id="创建任务">创建任务</h3><h4 id="xtaskcreate">xTaskCreate</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pvTaskCode, </span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">                       <span class="type">uint16_t</span> usStackDepth, </span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *pvParameters, </span></span><br><span class="line"><span class="params">                       UBaseType_t uxPriority, </span></span><br><span class="line"><span class="params">                       TaskHandle_t *pxCreatedTask )</span>;</span><br></pre></td></tr></table></figure><p>这可能是所有API中最复杂的，但任务也是多任务系统的最基本组件。</p><p>参数表</p><table><colgroup><col style="width: 17%"><col style="width: 82%"></colgroup><thead><tr class="header"><th>参数名</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>pvTaskCode</td><td>任务函数入口</td></tr><tr class="even"><td>pcName</td><td>任务的描述名称。configMAX_TASK_NAME_LEN配置名称最大长度。超过会被截断</td></tr><tr class="odd"><td>usStackDepth</td><td>任务使用的栈大小，单位是字（words）。configMINIMAL_STACK_SIZE配置空闲任务和任务最小栈大小。</td></tr><tr class="even"><td>pvParameters</td><td>任务使用的<code>void*</code>类型参数指针。</td></tr><tr class="odd"><td>uxPriority</td><td>指定任务运行优先级，范围0-(configMAX_PRIORITIES –1)，最低优先级为0。</td></tr><tr class="even"><td>pxCreatedTask</td><td>创建的任务句柄，可以会被其他接口引用。没有需要可以设置为NULL。</td></tr></tbody></table><p>返回值</p><p>pdPASS创建成功；pdFAIL创建失败；</p><h4 id="example-1-创建任务">Example 1 创建任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">&quot;Task 1 is running\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment"> nothing to do in here. Later examples will replace this crude</span></span><br><span class="line"><span class="comment"> loop with a proper delay/sleep function. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">&quot;Task 2 is running\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment"> nothing to do in here. Later examples will replace this crude</span></span><br><span class="line"><span class="comment"> loop with a proper delay/sleep function. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create one of the two tasks. Note that a real application should check</span></span><br><span class="line"><span class="comment"> the return value of the xTaskCreate() call to ensure the task was created</span></span><br><span class="line"><span class="comment"> successfully. */</span></span><br><span class="line">    xTaskCreate( vTask1, <span class="comment">/* Pointer to the function that implements the task. */</span></span><br><span class="line">                <span class="string">&quot;Task 1&quot;</span>,<span class="comment">/* Text name for the task. This is to facilitate </span></span><br><span class="line"><span class="comment"> debugging only. */</span></span><br><span class="line">                <span class="number">1000</span>, <span class="comment">/* Stack depth - small microcontrollers will use much</span></span><br><span class="line"><span class="comment"> less stack than this. */</span></span><br><span class="line">                <span class="literal">NULL</span>, <span class="comment">/* This example does not use the task parameter. */</span></span><br><span class="line">                <span class="number">1</span>, <span class="comment">/* This task will run at priority 1. */</span></span><br><span class="line">                <span class="literal">NULL</span> ); <span class="comment">/* This example does not use the task handle. */</span></span><br><span class="line">    <span class="comment">/* Create the other task in exactly the same way and at the same priority. */</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* Start the scheduler so the tasks start executing. */</span></span><br><span class="line">    vTaskStartScheduler(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If all is well then main() will never reach here as the scheduler will </span></span><br><span class="line"><span class="comment"> now be running the tasks. If main() does reach here then it is likely that </span></span><br><span class="line"><span class="comment"> there was insufficient heap memory available for the idle task to be created. </span></span><br><span class="line"><span class="comment"> Chapter 2 provides more information on heap memory management. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/22/image-20230222175228346.png" alt="image-20230222175228346"><figcaption aria-hidden="true">image-20230222175228346</figcaption></figure><p>Task2可以被Task1创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">&quot;Task 1 is running\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/* If this task code is executing then the scheduler must already have</span></span><br><span class="line"><span class="comment"> been started. Create the other task before entering the infinite loop. */</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment"> nothing to do in here. Later examples will replace this crude</span></span><br><span class="line"><span class="comment"> loop with a proper delay/sleep function. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="example-2-使用任务参数">Example 2 使用任务参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *pcTaskName;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/* The string to print out is passed in via the parameter. Cast this to a</span></span><br><span class="line"><span class="comment"> character pointer. */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment"> nothing to do in here. Later exercises will replace this crude</span></span><br><span class="line"><span class="comment"> loop with a proper delay/sleep function. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define the strings that will be passed in as the task parameters. These are</span></span><br><span class="line"><span class="comment">defined const and not on the stack to ensure they remain valid when the tasks are</span></span><br><span class="line"><span class="comment">executing. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask1 = <span class="string">&quot;Task 1 is running\r\n&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask2 = <span class="string">&quot;Task 2 is running\r\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create one of the two tasks. */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="comment">/* Pointer to the function that </span></span><br><span class="line"><span class="comment"> implements the task. */</span></span><br><span class="line">                <span class="string">&quot;Task 1&quot;</span>, <span class="comment">/* Text name for the task. This is to </span></span><br><span class="line"><span class="comment"> facilitate debugging only. */</span></span><br><span class="line">                <span class="number">1000</span>, <span class="comment">/* Stack depth - small microcontrollers</span></span><br><span class="line"><span class="comment"> will use much less stack than this. */</span></span><br><span class="line">                (<span class="type">void</span>*)pcTextForTask1, <span class="comment">/* Pass the text to be printed into the </span></span><br><span class="line"><span class="comment"> task using the task parameter. */</span></span><br><span class="line">                <span class="number">1</span>, <span class="comment">/* This task will run at priority 1. */</span></span><br><span class="line">                <span class="literal">NULL</span> ); <span class="comment">/* The task handle is not used in this </span></span><br><span class="line"><span class="comment"> example. */</span></span><br><span class="line">    <span class="comment">/* Create the other task in exactly the same way. Note this time that multiple</span></span><br><span class="line"><span class="comment"> tasks are being created from the SAME task implementation (vTaskFunction). Only </span></span><br><span class="line"><span class="comment"> the value passed in the parameter is different. Two instances of the same </span></span><br><span class="line"><span class="comment"> task are being created. */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, (<span class="type">void</span>*)pcTextForTask2, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* Start the scheduler so the tasks start executing. */</span></span><br><span class="line">    vTaskStartScheduler(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If all is well then main() will never reach here as the scheduler will </span></span><br><span class="line"><span class="comment"> now be running the tasks. If main() does reach here then it is likely that </span></span><br><span class="line"><span class="comment"> there was insufficient heap memory available for the idle task to be created. </span></span><br><span class="line"><span class="comment"> Chapter 2 provides more information on heap memory management. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务优先级">任务优先级</h3><p>configMAX_PRIORITIES</p><p>configUSE_PORT_OPTIMISED_TASK_SELECTION</p><h3 id="时间尺度和滴答中断">时间尺度和滴答中断</h3><p>configTICK_RATE_HZ</p><p>100</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/23/image-20230223094018410.png" alt="image-20230223094018410"><figcaption aria-hidden="true">image-20230223094018410</figcaption></figure><p>pdMS_TO_TICKS()</p><h4 id="example-3.-experimenting-with-priorities">Example 3.Experimenting with priorities</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/23/image-20230223094342546.png" alt="image-20230223094342546"><figcaption aria-hidden="true">image-20230223094342546</figcaption></figure><h3 id="扩展非运行状态">扩展非运行状态</h3><h4 id="阻塞状态blocked">阻塞状态（Blocked）</h4><h4 id="暂停状态suspended">暂停状态（Suspended）</h4><h4 id="就绪状态ready">就绪状态（Ready）</h4><h4 id="完整的状态切换图">完整的状态切换图</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/23/image-20230223094909681.png" alt="image-20230223094909681"><figcaption aria-hidden="true">image-20230223094909681</figcaption></figure><h4 id="example-4.-using-the-blocked-state-to-create-a-delay">Example 4.Using the Blocked state to create a delay</h4><p>INCLUDE_vTaskDelay</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( TickType_t xTicksToDelay )</span>;</span><br></pre></td></tr></table></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/23/image-20230223095233646.png" alt="image-20230223095233646"><figcaption aria-hidden="true">image-20230223095233646</figcaption></figure><h4 id="vtaskdelayuntil函数">vTaskDelayUntil()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-5.-converting-the-example-tasks-to-use-vtaskdelayuntil">Example5. Converting the example tasks to use vTaskDelayUntil()</h4><h4 id="example-6.-combining-blocking-and-non-blocking-tasks">Example 6.Combining blocking and non-blocking tasks</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/23/image-20230223100440966.png" alt="image-20230223100440966"><figcaption aria-hidden="true">image-20230223100440966</figcaption></figure><h3 id="空闲任务和钩子函数">空闲任务和钩子函数</h3><p>configIDLE_SHOULD_YIELD</p><p>清理内核资源</p><h4 id="空闲任务钩子函数">空闲任务钩子函数</h4><p>使用场景</p><h4 id="空闲任务钩子函数的限制">空闲任务钩子函数的限制</h4><p>使用事项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p>configUSE_IDLE_HOOK</p><h3 id="改变任务优先级">改变任务优先级</h3><h4 id="vtaskpriorityset">vTaskPrioritySet()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t pxTask, UBaseType_t uxNewPriority )</span>;</span><br></pre></td></tr></table></figure><h4 id="uxtaskpriorityget">uxTaskPriorityGet()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( TaskHandle_t pxTask )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-8.-changing-task-priorities">Example 8. Changing taskpriorities</h4><h3 id="删除任务">删除任务</h3><h4 id="vtaskdelete">vTaskDelete()</h4><p>INCLUDE_vTaskDelete</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t pxTaskToDelete )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-9.-deleting-tasks">Example 9. Deleting tasks</h4><h3 id="线程本地存储">线程本地存储</h3><h3 id="调度算法">调度算法</h3><h4 id="任务状态和事件回顾">任务状态和事件回顾</h4><p>Running</p><p>Ready</p><p>Blocked</p><p>Suspended</p><h4 id="配置调度算法">配置调度算法</h4><p>configUSE_PREEMPTION</p><p>configUSE_TIME_SLICING</p><p>configUSE_TICKLESS_IDLE</p><p>Round Robin Scheduling</p><p>Fixed Priority Pre-emptive Scheduling with Time Slicing</p><p><strong>基于时间片优先级抢占调度</strong></p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224092259473.png" alt="image-20230224092259473"><figcaption aria-hidden="true">image-20230224092259473</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224092550083.png" alt="image-20230224092550083"><figcaption aria-hidden="true">image-20230224092550083</figcaption></figure><p>configIDLE_SHOULD_YIELD=1</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224093117397.png" alt="image-20230224093117397"><figcaption aria-hidden="true">image-20230224093117397</figcaption></figure><p><strong>优先级抢占调度（无时间片）</strong></p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224094055809.png" alt="image-20230224094055809"><figcaption aria-hidden="true">image-20230224094055809</figcaption></figure><p><strong>合作调度</strong></p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224095111125.png" alt="image-20230224095111125"><figcaption aria-hidden="true">image-20230224095111125</figcaption></figure><h2 id="队列管理">队列管理</h2><h3 id="队列特性">队列特性</h3><h4 id="数据存储">数据存储</h4><p>First In First Out FIFO</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224095944873.png" alt="image-20230224095944873"><figcaption aria-hidden="true">image-20230224095944873</figcaption></figure><h4 id="多任务访问">多任务访问</h4><h4 id="队列读取阻塞">队列读取阻塞</h4><h4 id="队列写入阻塞">队列写入阻塞</h4><h4 id="多队列阻塞">多队列阻塞</h4><h3 id="使用队列">使用队列</h3><h4 id="xqueuecreate">xQueueCreate</h4><p>QueueHandle_t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure><h4 id="xqueuesendtobackxqueuesendtofront">xQueueSendToBack/xQueueSendToFront</h4><p>xQueueSend</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait )</span>;</span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>portMAX_DELAY</p><p>INCLUDE_vTaskSuspend</p><p>pdPASS</p><p>errQUEUE_FULL</p><h4 id="xqueuereceive">xQueueReceive</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                         TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>pdPASS</p><p>errQUEUE_EMPTY</p><h4 id="uxqueuemessageswaiting">uxQueueMessagesWaiting</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-10.-blocking-when-receiving-from-a-queue">Example 10.Blocking when receiving from a queue</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224140047388.png" alt="image-20230224140047388"><figcaption aria-hidden="true">image-20230224140047388</figcaption></figure><h3 id="从多个源接收数据">从多个源接收数据</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224140141858.png" alt="image-20230224140141858"><figcaption aria-hidden="true">image-20230224140141858</figcaption></figure><h4 id="example-11.-blocking-when-sending-to-a-queue-and-sending-structures-on-a-queue">Example11. Blocking when sending to a queue, and sending structures on aqueue</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/24/image-20230224140630606.png" alt="image-20230224140630606"><figcaption aria-hidden="true">image-20230224140630606</figcaption></figure><h3 id="传输大量或可变大小的数据">传输大量或可变大小的数据</h3><h4 id="队列指针">队列指针</h4><h4 id="使用队列传输不同类型和长度数据">使用队列传输不同类型和长度数据</h4><p>IPStackEvent_t</p><h3 id="从多个队列接收">从多个队列接收</h3><h4 id="队列集">队列集</h4><h4 id="xqueuecreateset">xQueueCreateSet</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueSetHandle_t <span class="title function_">xQueueCreateSet</span><span class="params">( <span class="type">const</span> UBaseType_t uxEventQueueLength )</span>;</span><br></pre></td></tr></table></figure><p>uxEventQueueLength 每个队列最大长度和</p><h4 id="xqueueaddtoset">xQueueAddToSet</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueAddToSet</span><span class="params">( QueueSetMemberHandle_t xQueueOrSemaphore, </span></span><br><span class="line"><span class="params">                          QueueSetHandle_t xQueueSet )</span>;</span><br></pre></td></tr></table></figure><h4 id="xqueueselectfromset">xQueueSelectFromSet</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueueSetMemberHandle_t <span class="title function_">xQueueSelectFromSet</span><span class="params">( QueueSetHandle_t xQueueSet,</span></span><br><span class="line"><span class="params">                                           <span class="type">const</span> TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-12.-using-a-queue-set">Example 12. Using a QueueSet</h4><h4 id="more-realistic-queue-set-use-cases">More Realistic Queue Set UseCases</h4><h3 id="使用队列构建邮箱">使用队列构建邮箱</h3><h4 id="xqueueoverwrite">xQueueOverwrite</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">( QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> * pvItemToQueue )</span>;</span><br></pre></td></tr></table></figure><h4 id="xqueuepeek">xQueuePeek</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                      TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h2 id="软件计时器管理">软件计时器管理</h2><p><code>FreeRTOS/Source/timers.c</code></p><p><code>configUSE_TIMERS</code></p><h3 id="软件计时器回调函数">软件计时器回调函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure><p>不能调用可能进入阻塞状态的API</p><h3 id="软件计时器的属性和状态">软件计时器的属性和状态</h3><h4 id="软件计时器的周期">软件计时器的周期</h4><h4 id="单次和自动重载计时器">单次和自动重载计时器</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227140145505.png" alt="image-20230227140145505"><figcaption aria-hidden="true">image-20230227140145505</figcaption></figure><h4 id="软件计时器状态">软件计时器状态</h4><p>休眠</p><p>运行</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227140355152.png" alt="image-20230227140355152"><figcaption aria-hidden="true">image-20230227140355152</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227140419033.png" alt="image-20230227140419033"><figcaption aria-hidden="true">image-20230227140419033</figcaption></figure><h3 id="软件计时器上下文">软件计时器上下文</h3><h4 id="rtos守护任务">RTOS守护任务</h4><p>configTIMER_TASK_PRIORITY</p><p>configTIMER_TASK_STACK_DEPTH</p><p>不能调用可能进入阻塞状态的API</p><h4 id="计时器命令队列">计时器命令队列</h4><p>configTIMER_QUEUE_LENGTH</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227140850116.png" alt="image-20230227140850116"><figcaption aria-hidden="true">image-20230227140850116</figcaption></figure><h4 id="守护任务调度">守护任务调度</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227141013158.png" alt="image-20230227141013158"><figcaption aria-hidden="true">image-20230227141013158</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/27/image-20230227141229467.png" alt="image-20230227141229467"><figcaption aria-hidden="true">image-20230227141229467</figcaption></figure><h3 id="创建并启动一个软件计时器">创建并启动一个软件计时器</h3><h4 id="xtimercreate">xTimerCreate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                           TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                           UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> * pvTimerID,</span></span><br><span class="line"><span class="params">                           TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br></pre></td></tr></table></figure><h4 id="xtimerstart">xTimerStart</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>INCLUDE_vTaskSuspend</p><p>portMAX_DELAY</p><h4 id="example-13.-creating-one-shot-and-auto-reload-timers">Example13. Creating one-shot and auto-reload timers</h4><h3 id="计时器编号">计时器编号</h3><h4 id="vtimersettimerid">vTimerSetTimerID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( <span class="type">const</span> TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure><h4 id="pvtimergettimerid">pvTimerGetTimerID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-14.-using-the-callback-function-parameter-and-the-software-timer-id">Example14. Using the callback function parameter and the software timer ID</h4><h3 id="改变计时器周期">改变计时器周期</h3><h4 id="xtimerchangeperiod">xTimerChangePeriod</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">( TimerHandle_t xTimer, </span></span><br><span class="line"><span class="params">                              TickType_t xNewTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                              TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h3 id="重置软件计时器">重置软件计时器</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228092540839.png" alt="image-20230228092540839"><figcaption aria-hidden="true">image-20230228092540839</figcaption></figure><h4 id="xtimerreset">xTimerReset</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-15.-resetting-a-software-timer">Example 15. Resetting asoftware timer</h4><h2 id="中断管理">中断管理</h2><h3 id="isr中使用系统api">ISR中使用系统API</h3><h4 id="中断安全api">中断安全API</h4><p>FromISR</p><h4 id="使用独立的中断安全api的优势">使用独立的中断安全API的优势</h4><h4 id="使用独立的中断安全api的劣势">使用独立的中断安全API的劣势</h4><h4 id="xhigherprioritytaskwoken参数">xHigherPriorityTaskWoken参数</h4><p>一般用pbFALSE</p><h4 id="portyield_from_isr和portend_switching_isr宏">portYIELD_FROM_ISR和portEND_SWITCHING_ISR宏</h4><p>taskYIELD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br></pre></td></tr></table></figure><h3 id="延时中断处理">延时中断处理</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228134407138.png" alt="image-20230228134407138"><figcaption aria-hidden="true">image-20230228134407138</figcaption></figure><h3 id="用于同步的二进制信号量">用于同步的二进制信号量</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228135032388.png" alt="image-20230228135032388"><figcaption aria-hidden="true">image-20230228135032388</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228135534394.png" alt="image-20230228135534394"><figcaption aria-hidden="true">image-20230228135534394</figcaption></figure><h4 id="xsemaphorecreatebinary">xSemaphoreCreateBinary</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h4 id="xsemaphoretake">xSemaphoreTake</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="xsemaphoregivefromisr">xSemaphoreGiveFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">( SemaphoreHandle_t xSemaphore, </span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-16.-using-a-binary-semaphore-to-synchronize-a-task-with-an-interrupt">Example16. Using a binary semaphore to synchronize a task with aninterrupt</h4><p>vPortGenerateSimulatedInterrupt</p><p>vPortSetInterruptHandler</p><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228140557184.png" alt="image-20230228140557184"><figcaption aria-hidden="true">image-20230228140557184</figcaption></figure><h4 id="improving-the-implementation-of-the-task-used-in-example-16">Improvingthe Implementation of the Task Used in Example 16</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228140947975.png" alt="image-20230228140947975"><figcaption aria-hidden="true">image-20230228140947975</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/02/28/image-20230228141049239.png" alt="image-20230228141049239"><figcaption aria-hidden="true">image-20230228141049239</figcaption></figure><h3 id="计数信号量">计数信号量</h3><p>configUSE_COUNTING_SEMAPHORES</p><figure><img src="https://p0.oz1010.site:39890/images/2023/03/01/image-20230301092559990.png" alt="image-20230301092559990"><figcaption aria-hidden="true">image-20230301092559990</figcaption></figure><h4 id="xsemaphorecreatecounting">xSemaphoreCreateCounting</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">( UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                           UBaseType_t uxInitialCount )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-17.-using-a-counting-semaphore-to-synchronize-a-task-with-an-interrupt">Example17. Using a counting semaphore to synchronize a task with aninterrupt</h4><h3 id="延时工作到系统守护任务">延时工作到系统守护任务</h3><h4 id="xtimerpendfunctioncallfromisr">xTimerPendFunctionCallFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerPendFunctionCallFromISR</span><span class="params">( PendedFunction_t xFunctionToPend,</span></span><br><span class="line"><span class="params">                                         <span class="type">void</span> *pvParameter1,</span></span><br><span class="line"><span class="params">                                         <span class="type">uint32_t</span> ulParameter2,</span></span><br><span class="line"><span class="params">                                         BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPendableFunction</span><span class="params">( <span class="type">void</span> *pvParameter1, <span class="type">uint32_t</span> ulParameter2 )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-18.-centralized-deferred-interrupt-processing">Example18. Centralized deferred interrupt processing</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/01/image-20230301093446475.png" alt="image-20230301093446475"><figcaption aria-hidden="true">image-20230301093446475</figcaption></figure><h3 id="在中断服务函数isr中使用队列">在中断服务函数(ISR)中使用队列</h3><h4 id="xqueuesendtofrontfromisr和xqueuesendtobackfromisr">xQueueSendToFrontFromISR和xQueueSendToBackFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">( QueueHandle_t xQueue, </span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> *pvItemToQueue</span></span><br><span class="line"><span class="params">                                    BaseType_t *pxHigherPriorityTaskWoken </span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">( QueueHandle_t xQueue, </span></span><br><span class="line"><span class="params">                                   <span class="type">void</span> *pvItemToQueue</span></span><br><span class="line"><span class="params">                                   BaseType_t *pxHigherPriorityTaskWoken </span></span><br><span class="line"><span class="params">                                  )</span>;</span><br></pre></td></tr></table></figure><h4 id="考虑合适使用isr队列">考虑合适使用ISR队列</h4><p>DMA</p><h4 id="example-19.-sending-and-receiving-on-a-queue-from-within-an-interrupt">Example19. Sending and receiving on a queue from within an interrupt</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/01/image-20230301094553407.png" alt="image-20230301094553407"><figcaption aria-hidden="true">image-20230301094553407</figcaption></figure><h3 id="中断嵌套">中断嵌套</h3><p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p><p>configMAX_API_CALL_INTERRUPT_PRIORITY</p><p>configKERNEL_INTERRUPT_PRIORITY</p><p>数字优先级</p><p>逻辑优先级</p><figure><img src="https://p0.oz1010.site:39890/images/2023/03/01/image-20230301100213478.png" alt="image-20230301100213478"><figcaption aria-hidden="true">image-20230301100213478</figcaption></figure><h4 id="arm-cortex-m1和gic的用户说明">ARM Cortex-M1和GIC的用户说明</h4><p>configASSERT</p><figure><img src="https://p0.oz1010.site:39890/images/2023/03/01/image-20230301101125569.png" alt="image-20230301101125569"><figcaption aria-hidden="true">image-20230301101125569</figcaption></figure><h2 id="资源管理">资源管理</h2><h4 id="互斥现象">互斥现象</h4><h3 id="临界段和暂停调度器">临界段和暂停调度器</h3><h4 id="临界段基础">临界段基础</h4><p>taskENTER_CRITICAL</p><p>taskEXIT_CRITICAL</p><p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p><p>taskENTER_CRITICAL_FROM_ISR</p><p>taskEXIT_CRITICAL_FROM_ISR</p><h4 id="暂停调度器">暂停调度器</h4><h4 id="vtasksuspendall">vTaskSuspendAll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h4 id="xtaskresumeall">xTaskResumeAll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h3 id="互斥体二进制信号量">互斥体（二进制信号量）</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/03/02/image-20230302134248107.png" alt="image-20230302134248107"><figcaption aria-hidden="true">image-20230302134248107</figcaption></figure><h4 id="xsemaphorecreatemutex">xSemaphoreCreateMutex</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-20.-rewriting-vprintstring-to-use-a-semaphore">Example20. Rewriting vPrintString() to use a semaphore</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/02/image-20230302134426159.png" alt="image-20230302134426159"><figcaption aria-hidden="true">image-20230302134426159</figcaption></figure><h4 id="优先级反转">优先级反转</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/02/image-20230302134556524.png" alt="image-20230302134556524"><figcaption aria-hidden="true">image-20230302134556524</figcaption></figure><h4 id="优先级继承">优先级继承</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/02/image-20230302134936848.png" alt="image-20230302134936848"><figcaption aria-hidden="true">image-20230302134936848</figcaption></figure><h4 id="死锁">死锁</h4><h4 id="递归互斥锁">递归互斥锁</h4><p>xSemaphoreCreateRecursiveMutex</p><p>xSemaphoreTakeRecursive</p><p>xSemaphoreGiveRecursive</p><h4 id="互斥锁和任务调度">互斥锁和任务调度</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/03/image-20230303091409614.png" alt="image-20230303091409614"><figcaption aria-hidden="true">image-20230303091409614</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/03/03/image-20230303092336449.png" alt="image-20230303092336449"><figcaption aria-hidden="true">image-20230303092336449</figcaption></figure><h3 id="守护任务">守护任务</h3><p>只有守护任务才能直接访问资源</p><h4 id="example-21.-re-writing-vprintstring-to-use-a-gatekeeper-task">Example21. Re-writing vPrintString() to use a gatekeeper task</h4><p>configUSE_TICK_HOOK</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationTickHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h2 id="事件组">事件组</h2><h3 id="事件组特性">事件组特性</h3><p>EventBits_t</p><figure><img src="https://p0.oz1010.site:39890/images/2023/03/06/image-20230306093213414.png" alt="image-20230306093213414"><figcaption aria-hidden="true">image-20230306093213414</figcaption></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/03/06/image-20230306093348768.png" alt="image-20230306093348768"><figcaption aria-hidden="true">image-20230306093348768</figcaption></figure><h4 id="eventbits_t数据类型细节">EventBits_t数据类型细节</h4><p>configUSE_16_BIT_TICKS</p><h4 id="多任务访问-1">多任务访问</h4><h4 id="使用事件组的一个实际实例">使用事件组的一个实际实例</h4><p>FreeRTOS+TCP TCP/IP</p><p>FreeRTOS_Socket_t</p><h3 id="使用事件组的事件管理">使用事件组的事件管理</h3><h4 id="xeventgroupcreate">xEventGroupCreate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><h4 id="xeventgroupsetbits">xEventGroupSetBits</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br></pre></td></tr></table></figure><h4 id="xeventgroupsetbitsfromisr">xEventGroupSetBitsFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">                                     BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="xeventgroupwaitbits">xEventGroupWaitBits</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( <span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-22.-experimenting-with-event-groups">Example 22.Experimenting with event groups</h4><h3 id="使用事件组的任务同步">使用事件组的任务同步</h3><h4 id="xeventgroupsync">xEventGroupSync</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSync</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-23.-synchronizing-tasks">Example 23. Synchronizingtasks</h4><h2 id="任务通知">任务通知</h2><p><strong>通过中间对象通信</strong></p><figure><img src="https://p0.oz1010.site:39890/images/2023/03/07/image-20230307094905368.png" alt="image-20230307094905368"><figcaption aria-hidden="true">image-20230307094905368</figcaption></figure><p><strong>任务通知——直接通信方式</strong></p><figure><img src="/2025/01/23/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230307101348461.png" alt="image-20230307101348461"><figcaption aria-hidden="true">image-20230307101348461</figcaption></figure><p>configUSE_TASK_NOTIFICATIONS</p><h3 id="任务通知优势和限制">任务通知：优势和限制</h3><h4 id="性能优势">性能优势</h4><h4 id="内存消耗优势">内存消耗优势</h4><h4 id="限制">限制</h4><h3 id="使用任务通知">使用任务通知</h3><h4 id="任务通知api选项">任务通知API选项</h4><h4 id="xtasknotifygive">xTaskNotifyGive</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br></pre></td></tr></table></figure><h4 id="vtasknotifygivefromisr">vTaskNotifyGiveFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                            BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="ultasknotifytake">ulTaskNotifyTake</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="example-24.-using-a-task-notification-in-place-of-a-semaphore-method-1">Example24. Using a task notification in place of a semaphore, method 1</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/07/image-20230307134340180.png" alt="image-20230307134340180"><figcaption aria-hidden="true">image-20230307134340180</figcaption></figure><h4 id="example-25.-using-a-task-notification-in-place-of-a-semaphore-method-2">Example25. Using a task notification in place of a semaphore, method 2</h4><h4 id="xtasknotify和xtasknotifyfromisr">xTaskNotify和xTaskNotifyFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                       <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                       eNotifyAction eAction )</span>;</span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                              eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                              BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="xtasknotifywait">xTaskNotifyWait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><h4 id="task-notifications-used-in-peripheral-device-drivers-uart-example">TaskNotifications Used in Peripheral Device Drivers: UART Example</h4><h4 id="task-notifications-used-in-peripheral-device-drivers-adc-example">TaskNotifications Used in Peripheral Device Drivers: ADC Example</h4><h4 id="task-notifications-used-directly-within-an-application">TaskNotifications Used Directly Within an Application</h4><figure><img src="https://p0.oz1010.site:39890/images/2023/03/07/image-20230307135357762.png" alt="image-20230307135357762"><figcaption aria-hidden="true">image-20230307135357762</figcaption></figure><h2 id="低功耗支持">低功耗支持</h2><h2 id="开发者支持">开发者支持</h2><h3 id="configassert">configASSERT</h3><p>默认无效：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert( pxMyPointer != <span class="literal">NULL</span> );</span><br></pre></td></tr></table></figure><p>需要改为</p><p>configASSERT()</p><h4 id="configassert定义示例">configASSERT定义示例</h4><h3 id="freertos跟踪">FreeRTOS+跟踪</h3><figure><img src="https://p0.oz1010.site:39890/images/2023/03/08/image-20230308092623605.png" alt="image-20230308092623605"><figcaption aria-hidden="true">image-20230308092623605</figcaption></figure><h3 id="调试相关钩子回调函数">调试相关钩子（回调）函数</h3><h4 id="内存申请失败">内存申请失败</h4><h4 id="栈溢出">栈溢出</h4><h3 id="查看运行时和任务状态信息">查看运行时和任务状态信息</h3><h4 id="任务运行时统计">任务运行时统计</h4><h4 id="运行时统计时钟">运行时统计时钟</h4><p>10~100倍频率</p><h4 id="配置应用以收集运行时统计">配置应用以收集运行时统计</h4><p>configGENERATE_RUN_TIME_STATS</p><p>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()</p><p>portGET_RUN_TIME_COUNTER_VALUE()</p><p>portALT_GET_RUN_TIME_COUNTER_VALUE(Time)</p><h4 id="uxtaskgetsystemstate">uxTaskGetSystemState</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetSystemState</span><span class="params">( TaskStatus_t * <span class="type">const</span> pxTaskStatusArray,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> UBaseType_t uxArraySize,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xTASK_STATUS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskHandle_t xHandle;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcTaskName;</span><br><span class="line">    UBaseType_t xTaskNumber;</span><br><span class="line">    eTaskState eCurrentState;</span><br><span class="line">    UBaseType_t uxCurrentPriority; </span><br><span class="line">    UBaseType_t uxBasePriority;</span><br><span class="line">    <span class="type">uint32_t</span> ulRunTimeCounter; </span><br><span class="line">    <span class="type">uint16_t</span> usStackHighWaterMark;</span><br><span class="line">&#125; TaskStatus_t;</span><br></pre></td></tr></table></figure><h4 id="vtasklist辅助函数">vTaskList辅助函数</h4><p>configUSE_TRACE_FACILITY</p><p>configUSE_STATS_FORMATTING_FUNCTIONS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskList</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/03/08/image-20230308094211231.png" alt="image-20230308094211231"><figcaption aria-hidden="true">image-20230308094211231</figcaption></figure><h4 id="vtaskgetruntimestats辅助函数">vTaskGetRunTimeStats辅助函数</h4><p>configGENERATE_RUN_TIME_STATS</p><p>configUSE_STATS_FORMATTING_FUNCTIONS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetRunTimeStats</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure><figure><img src="https://p0.oz1010.site:39890/images/2023/03/08/image-20230308095815972.png" alt="image-20230308095815972"><figcaption aria-hidden="true">image-20230308095815972</figcaption></figure><h4 id="产生和显示运行时统计示例">产生和显示运行时统计示例</h4><h3 id="跟踪钩子宏">跟踪钩子宏</h3><p>traceTASK_INCREMENT_TICK(xTickCount)</p><p>traceTASK_SWITCHED_OUT()</p><p>traceTASK_SWITCHED_IN()</p><p>traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue)</p><p>traceBLOCKING_ON_QUEUE_SEND(pxQueue)</p><p>traceQUEUE_SEND(pxQueue)</p><p>traceQUEUE_SEND_FAILED(pxQueue)</p><p>traceQUEUE_RECEIVE(pxQueue)</p><p>traceQUEUE_RECEIVE_FAILED(pxQueue)</p><p>traceQUEUE_SEND_FROM_ISR(pxQueue)</p><p>traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue)</p><p>traceQUEUE_RECEIVE_FROM_ISR(pxQueue)</p><p>traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue)</p><p>traceTASK_DELAY_UNTIL()</p><p>traceTASK_DELAY()</p><h4 id="定义跟踪钩子宏">定义跟踪钩子宏</h4><p>FreeRTOSConfig.h</p><h4 id="freertos感知调试插件">FreeRTOS感知调试插件</h4><p>Eclipse (StateViewer)</p><p>Eclipse (ThreadSpy)</p><p>IAR</p><p>ARM DS-5</p><p>Atollic TrueStudio</p><p>Microchip MPLAB</p><p>iSYSTEM WinIDEA</p><h2 id="问题解答">问题解答</h2><h3 id="中断优先级">中断优先级</h3><p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p><h3 id="栈溢出-1">栈溢出</h3><h4 id="uxtaskgetstackhighwatermark">uxTaskGetStackHighWaterMark</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetStackHighWaterMark</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure><h4 id="运行时栈检查概述">运行时栈检查——概述</h4><p>configCHECK_FOR_STACK_OVERFLOW</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t *pxTask, <span class="type">signed</span> <span class="type">char</span> *pcTaskName )</span>;</span><br></pre></td></tr></table></figure><h4 id="运行时栈检查方法1">运行时栈检查——方法1</h4><p>configCHECK_FOR_STACK_OVERFLOW 1</p><h4 id="运行时栈检查方法2">运行时栈检查——方法2</h4><p>configCHECK_FOR_STACK_OVERFLOW 2</p><h3 id="不适当地使用printf和sprintf">不适当地使用printf()和sprintf()</h3><h4 id="printf-stdarg.c">Printf-stdarg.c</h4><h3 id="其他常见的错误来源">其他常见的错误来源</h3><h4 id="症状向演示中添加一个简单的任务会导致演示崩溃">症状：向演示中添加一个简单的任务会导致演示崩溃</h4><h4 id="症状在中断中使用api函数会导致应用程序崩溃">症状：在中断中使用API函数会导致应用程序崩溃</h4><h4 id="症状有时应用程序会在中断服务例程中崩溃">症状：有时应用程序会在中断服务例程中崩溃</h4><h4 id="症状尝试启动第一个任务时崩溃">症状：尝试启动第一个任务时崩溃</h4><h4 id="症状意外禁用中断或者临界段未正确嵌套">症状：意外禁用中断，或者临界段未正确嵌套</h4><h4 id="症状应用程序甚至在调度程序启动之前就崩溃了">症状：应用程序甚至在调度程序启动之前就崩溃了</h4><h4 id="症状当调度程序挂起时或从关键部分内部调用api函数会导致应用程序崩溃">症状：当调度程序挂起时，或从关键部分内部调用API函数，会导致应用程序崩溃</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.amazonaws.cn/freertos/latest/userguide/dev-guide-freertos-kernel.html&quot;&gt;官方机器翻译版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方参考手册：&lt;/p&gt;
&lt;p&gt;开发板整体布局&lt;a</summary>
      
    
    
    
    <category term="FreeRTOS" scheme="https://oz1010.github.com/categories/FreeRTOS/"/>
    
    
  </entry>
  
  <entry>
    <title>RISC-V外部调试说明</title>
    <link href="https://oz1010.github.com/2024/09/14/RISC-V%E5%A4%96%E9%83%A8%E8%B0%83%E8%AF%95%E8%AF%B4%E6%98%8E/"/>
    <id>https://oz1010.github.com/2024/09/14/RISC-V%E5%A4%96%E9%83%A8%E8%B0%83%E8%AF%95%E8%AF%B4%E6%98%8E/</id>
    <published>2024-09-14T09:36:31.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统概览">系统概览</h1><p>平台是由一个或多个元件组成的单个集成电路。有些组件可能是RISC-V内核，而其他组件可能具有不同的功能。通常，它们都将连接到单个系统总线。单个RISC-V核心包含一个或多个硬件线程，称为hart。</p><p>用户与运行调试器(如gdb)的调试主机(如笔记本电脑)交互。调试器与调试转换器(例如OpenOCD，它可能包括一个硬件驱动程序)通信，以与调试传输硬件(例如OlimexUSB-JTAG适配器)通信。调试传输硬件将调试主机连接到平台的调试传输模块(DebugTransport Module,DTM)。DTM使用调试模块接口(DMI)提供对一个或多个调试模块(dm)的访问。</p><p>平台中每个hart都由一个DM控制。对hart-DM映射没有进一步的限制，但通常单个核心中的所有hart都由同一个DM控制。在大多数平台中，只有一个DM控制平台中的所有hart。</p><figure><img src="https://blog.oz1010.site/usr/uploads/2024/09/2124088104.png" alt="2024-09-14T09:34:55.png"><figcaption aria-hidden="true">2024-09-14T09:34:55.png</figcaption></figure><h1 id="调试模块dm">调试模块DM</h1><h2 id="调试模块接口dmi">调试模块接口DMI</h2><p>调试模块从属于称为调试模块接口(DMI)的总线。总线的主人是调试传输模块(DebugTransportModule)。调试模块接口可以是一个普通的总线，有一个主总线和一个从总线，也可以使用功能更全面的总线，如TileLink或AMBA高级外围总线。</p><p>DMI使用7到32位地址位。如果在这个DMI上有额外的DM，DMI地址空间中下一个DM的基址在nextdm中给出。调试模块自己的状态和寄存器应该只在上电时重置，而dmcontrol中的dmactive为0。如果dmactive为1，即使会引起CSRs被清零，所有hart在系统重置期间也要保持halt状态。</p><h2 id="重置控制">重置控制</h2><p>调试模块控制一个全局复位信号ndmreset(非调试模块复位)，它可以复位或保持复位平台中的每个组件，除了调试模块和调试传输模块。</p><h2 id="选择hart">选择hart</h2><p>一个单一的DM可以管理高达2^20个hart。</p><p>要枚举所有hart，调试器必须首先通过将所有hart写入hartsel(假设最大大小)并回读值来确定HARTSELLEN，以查看实际设置了哪些位。然后，它从0开始选择每个hart，直到在dmstatus中anynonexistent为1，或者达到最高索引(取决于HARTSELLEN)。</p><h2 id="抽象命令">抽象命令</h2><p>DM支持一组抽象命令，其中大部分是可选的。根据实现的不同，调试器可能能够执行一些抽象命令，即使所选的hart没有停止。调试器只能通过尝试特定状态下的特定hart支持哪些抽象命令，然后查看abstractcs中cmderr以确定它们是否成功。</p><p>如果命令接受参数，调试器必须在写入命令之前将它们写入数据寄存器。</p><p>每个抽象命令都是32位值。前8位包含cmdtype，它决定了命令的类型。</p><table><thead><tr class="header"><th>cmdtype</th><th>Command</th></tr></thead><tbody><tr class="odd"><td>0</td><td>Access Register</td></tr><tr class="even"><td>1</td><td>Quick Access</td></tr><tr class="odd"><td>2</td><td>Access Memory</td></tr></tbody></table><h3 id="access-register">Access Register</h3><blockquote><p>3.6.1.1 Access Register</p></blockquote><p>遵循以下操作顺序：</p><ol type="1"><li>若write为0且transfer为1，则将regno指定的寄存器的数据拷贝到数据区arg0中，并执行从m模式读取该寄存器时发生的任何副作用。</li><li>若write为1且transfer为1，则将数据区arg0的数据拷贝到regno指定的寄存器中，并执行从m模式写入该寄存器时发生的任何副作用。</li><li>若aarpostincrement为1，则将增加regno。</li><li>若postexec为1，执行Program Buffer.</li></ol><p>抽象寄存器号表</p><table><thead><tr class="header"><th>地址范围</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0x0000 - 0x0fff</td><td>CSRs，可以通过dpc访问PC</td></tr><tr class="even"><td>0x1000 - 0x101f</td><td>GPRs</td></tr><tr class="odd"><td>0x1020 - 0x103f</td><td>浮点寄存器</td></tr><tr class="even"><td>0xc000 - 0xffff</td><td>保留给非标扩展和内部使用的</td></tr></tbody></table><h3 id="quick-access">Quick Access</h3><blockquote><p>3.6.1.2 Quick Access</p></blockquote><p>遵循以下操作顺序：</p><ol type="1"><li>若hart已经暂停，命令将会设置cmderr为”halt/resume”并不会继续执行。</li><li>暂停hart。若hart因某些其他原因（如breakpoint）暂停，命令将会设置cmderr为”halt/resume”并不会继续执行。</li><li>执行ProgramBuffer。若发生异常，cmderr会被设置为”exception”并且programbuffer结束执行，但快速访问命令会继续。</li><li>恢复hart。</li></ol><h3 id="access-memory">Access Memory</h3><blockquote><p>3.6.1.3 Access Memory</p></blockquote><p>遵循以下操作顺序：</p><ol type="1"><li>若write为0，从arg1指定的内存位置拷贝数据到数据区arg0中。</li><li>若write为1，从数据区arg0拷贝数据到arg1指定的内存位置中。</li><li>若aampostincrement为1，则将增加arg1.</li></ol><p>若任何操作失败，设置cmderr并不会执行任何剩余步骤。</p><h2 id="程序缓冲区">程序缓冲区</h2><blockquote><p>3.7 Program Buffer</p></blockquote><p>为支持在已停止的hart上执行任意指令，调试模块可以包括程序缓冲区，调试器可以将小程序写入其中。</p><p>调试器可以将一个小程序写入程序缓冲区，然后使用AccessRegister抽象命令执行它一次，命令中postexec位为1。调试器可以编写任何它喜欢的程序(包括跳出程序缓冲区)，但是程序必须以ebreak或c.ebreak结束。</p><p>若progbufsize为1，则impebreak必须为1.程序缓冲区可容纳一条32位或16位指令，所以在这种情况下，调试器必须只写一条指令，而不管它的大小。</p><p>执行程序缓冲区可能会破坏dpc。如果是这种情况，必须可以使用抽象命令读取/写入dpc，而不设置postexec。调试器必须尝试在停止和执行程序缓冲区之间保存dpc，然后在离开调试模式之前恢复dpc。</p><h2 id="状态概览">状态概览</h2><p>下图显示了运行/停止调试期间hart经过的状态的概念视图，这些状态受到dmcontrol、abstractcs、abstractauto和command的不同字段的影响。</p><figure><img src="https://blog.oz1010.site/usr/uploads/2024/09/3532501864.png" alt="image-20240914114316238.png"><figcaption aria-hidden="true">image-20240914114316238.png</figcaption></figure><h2 id="系统总线访问">系统总线访问</h2><blockquote><p>3.9 System Bus Access</p></blockquote><p>调试器可以使用Program Buffer或AccessMemory抽象命令从hart的角度访问内存。一个调试模块也可以包括一个System BusAccess块来提供内存访问而不涉及hart，而不管是否实现了Program Buffer。</p><p>System Bus Access块支持8, 16, 32,64和128位访问。下表显示在sbdata中每个访问大小可以访问的位。</p><table><thead><tr class="header"><th>访问大小</th><th>数据位</th></tr></thead><tbody><tr class="odd"><td>8</td><td>sbdata0位7:0</td></tr><tr class="even"><td>16</td><td>sbdata0位15:0</td></tr><tr class="odd"><td>32</td><td>sbdata0</td></tr><tr class="even"><td>64</td><td>sbdata1, sbdata0</td></tr><tr class="odd"><td>128</td><td>sbdata3, sbdata2, sbdata1, sbdata0</td></tr></tbody></table><h2 id="dm寄存器">DM寄存器</h2><blockquote><p>3.12 Debug Module Registers</p></blockquote><p>本节中描述的寄存器是通过DMI总线访问的。每个DM都有一个基址(第一个DM为0)。下面的寄存器地址是这个基址的偏移量。</p><p>调试模块调试总线寄存器表</p><table><thead><tr class="header"><th>地址</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>0x04</td><td>Abstract Data 0 (data0)</td></tr><tr class="even"><td>0x0f</td><td>Abstract Data 11 (data11)</td></tr><tr class="odd"><td>0x10</td><td>Debug Module Control (dmcontrol)</td></tr><tr class="even"><td>0x11</td><td>Debug Module Status (dmstatus)</td></tr><tr class="odd"><td>0x12</td><td>Hart Info (hartinfo)</td></tr><tr class="even"><td>0x13</td><td>Halt Summary 1 (haltsum1)</td></tr><tr class="odd"><td>0x14</td><td>Hart Array Window Select (hawindowsel)</td></tr><tr class="even"><td>0x15</td><td>Hart Array Window (hawindow)</td></tr><tr class="odd"><td>0x16</td><td>Abstract Control and Status (abstractcs)</td></tr><tr class="even"><td>0x17</td><td>Abstract Command (command)</td></tr><tr class="odd"><td>0x18</td><td>Abstract Command Autoexec (abstractauto)</td></tr><tr class="even"><td>0x19</td><td>Configuration String Pointer 0 (confstrptr0)</td></tr><tr class="odd"><td>0x1a</td><td>Configuration String Pointer 1 (confstrptr1)</td></tr><tr class="even"><td>0x1b</td><td>Configuration String Pointer 2 (confstrptr2)</td></tr><tr class="odd"><td>0x1c</td><td>Configuration String Pointer 3 (confstrptr3)</td></tr><tr class="even"><td>0x1d</td><td>Next Debug Module (nextdm)</td></tr><tr class="odd"><td>0x20</td><td>Program Buffer 0 (progbuf0)</td></tr><tr class="even"><td>0x2f</td><td>Program Buffer 15 (progbuf15)</td></tr><tr class="odd"><td>0x30</td><td>Authentication Data (authdata)</td></tr><tr class="even"><td>0x34</td><td>Halt Summary 2 (haltsum2)</td></tr><tr class="odd"><td>0x35</td><td>Halt Summary 3 (haltsum3)</td></tr><tr class="even"><td>0x37</td><td>System Bus Address 127:96 (sbaddress3)</td></tr><tr class="odd"><td>0x38</td><td>System Bus Access Control and Status (sbcs)</td></tr><tr class="even"><td>0x39</td><td>System Bus Address 31:0 (sbaddress0)</td></tr><tr class="odd"><td>0x3a</td><td>System Bus Address 63:32 (sbaddress1)</td></tr><tr class="even"><td>0x3b</td><td>System Bus Address 95:64 (sbaddress2)</td></tr><tr class="odd"><td>0x3c</td><td>System Bus Data 31:0 (sbdata0)</td></tr><tr class="even"><td>0x3d</td><td>System Bus Data 63:32 (sbdata1)</td></tr><tr class="odd"><td>0x3e</td><td>System Bus Data 95:64 (sbdata2)</td></tr><tr class="even"><td>0x3f</td><td>System Bus Data 127:96 (sbdata3)</td></tr><tr class="odd"><td>0x40</td><td>Halt Summary 0 (haltsum0)</td></tr></tbody></table><h3 id="dmstatus-0x11">dmstatus, 0x11</h3><blockquote><p>3.12.1 Debug Module Status (dmstatus, at 0x11)</p></blockquote><p>这个寄存器报告整个调试模块以及由hasel所选hart的状态。它的地址在将来不会改变，因为它包含了version。</p><p>整个寄存器是只读的。</p><h3 id="dmcontrol-0x10">dmcontrol, 0x10</h3><blockquote><p>3.12.2 Debug Module Control (dmcontrol, at 0x10)</p></blockquote><p>这个寄存器控制整个调试模块以及由hasel所选的hart。</p><p>在本文档中，我们提到hartsel，它是hartselhi和hartsello的组合。虽然规范允许20个hartsel位，但实现可能会选择实现少于这个数。hartsel的实际宽度被称为HARTSELLEN。它最少为0，最多为20。调试器应该通过将所有的1写入HARTSELLEN(假设最大大小)并回读值以查看实际设置了哪些位来发现HARTSELLEN。</p><p>在任何给定的写操作中，调试器最多只能将1写入以下位中的一个：resumereq、hartreset、ackhavereset、setresethaltreq和clrresethaltreq。其他的必须写成0。</p><p>resethaltreq是每个hart可选内部状态位，不能读取，但可以使用setresethaltreq和clrresethaltreq写入。</p><h3 id="hartinfo-0x12">hartinfo, 0x12</h3><blockquote><p>3.12.3 Hart Info (hartinfo, at 0x12)</p></blockquote><p>这个寄存器能获取hartsel选择的hart的信息。</p><p>这个寄存器是可选的。若它不可用它会读到全0。</p><p>如果包含这个寄存器，调试器可以通过编写显式访问data或dscratch寄存器的程序来对程序缓冲区做更多的工作。</p><h3 id="hawindowsel-0x14">hawindowsel, 0x14</h3><blockquote><p>3.12.4 Hart Array Window Select (hawindowsel, at 0x14)</p></blockquote><p>hawindowsel有效可写位取决于具体实现，最多为15位。比如单个DM支持48个hart，则此寄存器只有bit0可以写入，其余位均为0.</p><h3 id="hawindow-0x15">hawindow, 0x15</h3><blockquote><p>3.12.5 Hart Array Window (hawindow, at 0x15)</p></blockquote><p>hart数组掩码寄存器，与hawindowsel一起选择hart数组。比如bit0代表<code>hawindowsel * 32</code>索引的hart，bit31代表<code>hawindowsel * 32 + 31</code>索引的hart。</p><h3 id="abstractcs-0x16">abstractcs, 0x16</h3><blockquote><p>3.12.6 Abstract Control and Status (abstractcs, at 0x16)</p></blockquote><p>当一个抽象命令正在执行时，写这个寄存器会造成cderr被设置为1（忙），如果它是0.</p><p>支持RV32，datacount至少为1；支持RV64，至少为2；支持RV128，至少为4.</p><h3 id="command-0x17">command, 0x17</h3><blockquote><p>3.12.7 Abstract Command (command, at 0x17)</p></blockquote><p>写这个寄存器会造成相关抽象命令被执行。</p><p>当一个抽象命令正在执行时，写这个寄存器会造成cderr被设置为1（忙），如果它是0.</p><p>如果cmderr为非0，写这个寄存器会被忽略。</p><h3 id="abstractauto-0x18">abstractauto, 0x18</h3><blockquote><p>3.12.8 Abstract Command Autoexec (abstractauto, at 0x18)</p></blockquote><p>这个寄存器是可选的。包含它允许更有效的突发访问。调试器可以通过设置位并读取它们来检测它是否被支持。</p><p>当一个抽象命令正在执行时，写这个寄存器会造成cderr被设置为1（忙），如果它是0.</p><h3 id="confstrptr0-0x19">confstrptr0, 0x19</h3><blockquote><p>3.12.9 Configuration String Pointer 0 (confstrptr0, at 0x19)</p></blockquote><p>当设置confstrptrvalid时，读取该寄存器将返回配置字符串指针的第31:0位。读取其他的confstrptr寄存器返回地址的上位。</p><p>当实现系统总线主控时，这必须是一个可以与系统总线访问模块一起使用的地址。否则，这必须是一个可以用来访问ID0的hart的配置字符串的地址。</p><p>如果confstrptrvalid为0，则confstrptr寄存器保存标识符信息，该信息在本文档中没有进一步指定。</p><h3 id="nextdm-0x1d">nextdm, 0x1d</h3><blockquote><p>3.12.10 Next Debug Module (nextdm, at 0x1d)</p></blockquote><p>如果在DMI上有超过一个DM，这个寄存器包含链中下一个DM的基地址，如果是链中最后一个则为0.</p><h3 id="data0-0x04">data0, 0x04</h3><blockquote><p>3.12.11 Abstract Data 0 (data0, at 0x04)</p></blockquote><p>data0到data11是基本的读/写寄存器，可以通过抽象命令读取或更改。dataccount表示实现了多少个，从data0开始，依次递增。</p><h3 id="progbuf0-0x20">progbuf0, 0x20</h3><blockquote><p>3.12.12 Program Buffer 0 (progbuf0, at 0x20)</p></blockquote><p>progbuf0到progbuf15提供对可选程序缓冲区的读/写访问。progbufsize表示从progbuf0开始实现的数目，依次递增。</p><h3 id="authdata-0x30">authdata, 0x30</h3><blockquote><p>3.12.13 Authentication Data (authdata, at 0x30)</p></blockquote><p>这个寄存器作为一个32位的串行端口进出认证模块。</p><p>当authbusy为0时，调试器可以通过读取或写入该寄存器与身份验证模块通信。没有单独的机制来指示溢出/下溢。</p><h3 id="haltsum0-0x40">haltsum0, 0x40</h3><blockquote><p>3.12.14 Halt Summary 0 (haltsum0, at 0x40)</p></blockquote><p>这个只读寄存器中的每个位表示一个特定的hart是否停止。不可用/不存在的hart不被认为是停止的。</p><p>LSB代表hart<code>hartsel[19:5],5'h0</code>的暂停状态，MSB代表hart<code>hartsel[19:5],5'h1f</code>的暂停状态。</p><h3 id="haltsum1-0x13">haltsum1, 0x13</h3><blockquote><p>3.12.15 Halt Summary 1 (haltsum1, at 0x13)</p></blockquote><p>这个只读寄存器中的每个位表示一组（32个）hart是否停止。不可用/不存在的hart不被认为是停止的。</p><p>这个寄存器不能出现在少于33个hart的系统中。</p><p>LSB代表一组hart<code>hartsel[19:10],10'h0</code>到hart<code>hartsel[19:10],10'h1f</code>的暂停状态。MSB代表一组hart<code>hartsel[19:10],10'h3e0</code>到hart<code>hartsel[19:10],10'h3ff</code>的暂停状态。</p><h3 id="haltsum2-0x34">haltsum2, 0x34</h3><blockquote><p>3.12.16 Halt Summary 2 (haltsum2, at 0x34)</p></blockquote><p>这个只读寄存器中的每个位表示一组（1024个）hart是否停止。不可用/不存在的hart不被认为是停止的。</p><p>这个寄存器不能出现在少于1025个hart的系统中。</p><p>LSB代表一组hart<code>hartsel[19:15],15'h0</code>到hart<code>hartsel[19:15],15'h3ff</code>的暂停状态。MSB代表一组hart<code>hartsel[19:15],15'h7c00</code>到hart<code>hartsel[19:15],15'h7fff</code>的暂停状态。</p><h3 id="haltsum3-0x35">haltsum3, 0x35</h3><blockquote><p>3.12.17 Halt Summary 3 (haltsum3, at 0x35)</p></blockquote><p>这个只读寄存器中的每个位表示一组（32768个）hart是否停止。不可用/不存在的hart不被认为是停止的。</p><p>这个寄存器不能出现在少于32769个hart的系统中。</p><p>LSB代表一组hart<code>20'h0</code>到hart<code>20'h7fff</code>的暂停状态。MSB代表一组hart<code>20'hf8000</code>到hart<code>20'hfffff</code>的暂停状态。</p><h3 id="sbcs-0x38">sbcs, 0x38</h3><blockquote><p>3.12.18 System Bus Access Control and Status (sbcs, at 0x38)</p></blockquote><h3 id="sbaddress0-0x39">sbaddress0, 0x39</h3><blockquote><p>3.12.19 System Bus Address 31:0 (sbaddress0, at 0x39)</p></blockquote><p>如果sbasize为0，则这个寄存器不存在。</p><p>如果sberror为0，sbbusyerror为0，sbreadonaddr为1，然后开始向该寄存器写入以下内容:</p><ol type="1"><li>sbbusy置位。</li><li>从sbaddress的新值执行一次总线读取。</li><li>如果读成功且sbautoincrement为1，增加sbaddress。</li><li>sbbusy清零。</li></ol><h3 id="sbaddress1-0x3a">sbaddress1, 0x3a</h3><blockquote><p>3.12.20 System Bus Address 63:32 (sbaddress1, at 0x3a)</p></blockquote><p>如果sbasize少于33，则这个寄存器不存在。</p><h3 id="sbaddress2-0x3b">sbaddress2, 0x3b</h3><blockquote><p>3.12.21 System Bus Address 95:64 (sbaddress2, at 0x3b)</p></blockquote><p>如果sbasize少于65，则这个寄存器不存在。</p><h3 id="sbaddress3-0x37">sbaddress3, 0x37</h3><blockquote><p>3.12.22 System Bus Address 127:96 (sbaddress3, at 0x37)</p></blockquote><p>如果sbasize少于97，则这个寄存器不存在。</p><h3 id="sbdata0-0x3c">sbdata0, 0x3c</h3><blockquote><p>3.12.23 System Bus Data 31:0 (sbdata0, at 0x3c)</p></blockquote><p>如果sbc中的所有saccess位都是0，那么这个寄存器不存在。</p><p>对这个寄存器写入开始如下:</p><ol type="1"><li>sbbusy置位。</li><li>对sbdata的新值执行总线写入到sbaddress。</li><li>如果写成功且设置了sbautoincrement，增加sbaddress。</li><li>sbbusy清零。</li></ol><p>从这个寄存器读取开始如下:</p><ol type="1"><li>返回数据。</li><li>sbbusy置位。</li><li>如果设置了sbreadondata，则从saddress中包含的地址执行一次系统总线读取，将结果放入sbdata中。</li><li>如果设置了sbautoincrement，增加sbaddress。</li><li>sbbusy清零。</li></ol><h3 id="sbdata1-0x3d">sbdata1, 0x3d</h3><blockquote><p>3.12.24 System Bus Data 63:32 (sbdata1, at 0x3d)</p></blockquote><p>如果sbaccess64和sbaccess128为0，那么这个寄存器不存在。</p><h3 id="sbdata2-0x3e">sbdata2, 0x3e</h3><blockquote><p>3.12.25 System Bus Data 95:64 (sbdata2, at 0x3e)</p></blockquote><p>只有当sbaccess128为1时，这个寄存器才存在。</p><h3 id="sbdata3-0x3f">sbdata3, 0x3f</h3><blockquote><p>3.12.26 System Bus Data 127:96 (sbdata3, at 0x3f)</p></blockquote><p>只有当sbaccess128为1时，这个寄存器才存在。</p><h1 id="risc-v调试">RISC-V调试</h1><h2 id="调试模式">调试模式</h2><p>调试模式是一种特殊的处理器模式，仅在hart暂停用于外部调试时使用。</p><p>当从可选的程序缓冲区执行代码时，hart保持在调试模式，并适用以下内容：</p><ol type="1"><li>所有操作都在机器模式特权级别执行，除了根据mprven可以忽略处于状态的MPRV。</li><li>所有中断(包括NMI)被屏蔽。</li><li>异常不更新任何寄存器。包括cause, epc, tval,dpc和mstatus。它们终止程序缓冲区的执行。</li><li>如果一个触发器匹配上，则不采取任何操作。</li><li>计数器可能会停止，这取决于dcsr中的stopcount。</li><li>计时器可能会停止，这取决于dcsr中的stoptime。</li><li>wfi指令起着nop的作用。</li><li>几乎所有改变特权级别的指令都有未定义的行为。这包括ecall、mret、sret和uret。(要更改特权级别，调试器可以在dcsr中写入prv)。唯一的例外是ebreak。当在调试模式下执行该命令时，它会再次停止hart，但不会更新dpc或dcsr。</li><li>完成Program Buffer的执行被认为是fence指令的输出。</li><li>如果所有的控制转移指令的目的地在程序缓冲区中，它们都可能被视为非法指令。如果其中一条指令是非法指令，那么所有这些指令都必须是非法指令。</li><li>如果控制转移指令的目的地在程序缓冲区之外，则所有控制转移指令都可能被视为非法指令。如果其中一条指令是非法指令，那么所有这些指令都必须是非法指令。</li><li>依赖于PC值的指令(例如auipc)可能作为非法指令。</li><li>有效的XLEN是DXLEN。</li></ol><h2 id="等待中断指令">等待中断指令</h2><p>如果在wfi执行时请求暂停，则hart必须离开已停止状态，完成该指令的执行，然后进入调试模式。</p><h2 id="单步调试">单步调试</h2><p>调试器可以使暂停的hart执行一条指令，然后在设置resumereq之前通过设置step重新进入调试模式。</p><p>如果执行或获取该指令导致异常，则在PC更改为异常处理程序并更新相应的tval和cause寄存器后立即重新进入调试模式。</p><p>如果执行或获取指令导致触发器触发，则在触发器触发后立即重新进入调试模式。在这种情况下，cause被设置为2(trigger)而不是4(singlestep)。指令是否执行取决于触发器的具体配置。</p><p>如果被执行的指令导致PC改变到一个地址，在这个地址中指令获取会导致异常，那么这个异常直到下一次hart被恢复时才会发生。</p><p>类似地，新地址的触发器在hart实际尝试执行该指令之前不会触发。</p><p>如果正在跳过的指令是wfi并且通常会使hart停止，那么该指令将被视为nop。</p><h2 id="重置">重置</h2><p>如果在hart从复位状态出来时断言了暂停信号(由hart的调试模块中的暂停请求位驱动)或resethaltreq,hart必须在执行任何指令之前进入调试模式，但在执行任何初始化之后，通常会在执行第一个指令之前发生</p><h2 id="dret指令">dret指令</h2><p>为了从调试模式返回，定义了一条新指令:dret。编码为0x7b200073。在支持此指令的硬件上，在调试模式下执行dret会将pc更改为存储在dpc中的值。将当前权限级别更改为dcsr中prv指定的权限级别。hart不再处于调试模式。</p><h2 id="核调试寄存器">核调试寄存器</h2><table><thead><tr class="header"><th>地址</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>0x7b0</td><td>Debug Control and Status (dcsr)</td></tr><tr class="even"><td>0x7b1</td><td>Debug PC (dpc)</td></tr><tr class="odd"><td>0x7b2</td><td>Debug Scratch Register 0 (dscratch0)</td></tr><tr class="even"><td>0x7b3</td><td>Debug Scratch Register 1 (dscratch1)</td></tr></tbody></table><h3 id="dcsr-0x7b0">dcsr, 0x7b0</h3><blockquote><p>4.8.1 Debug Control and Status (dcsr, at 0x7b0)</p></blockquote><h3 id="dpc-0x7b1">dpc, 0x7b1</h3><blockquote><p>4.8.2 Debug PC (dpc, at 0x7b1)</p></blockquote><h3 id="dscratch0-0x7b2">dscratch0, 0x7b2</h3><blockquote><p>4.8.3 Debug Scratch Register 0 (dscratch0, at 0x7b2)</p></blockquote><h3 id="dscratch1-0x7b3">dscratch1, 0x7b3</h3><blockquote><p>4.8.4 Debug Scratch Register 1 (dscratch1, at 0x7b3)</p></blockquote><h2 id="虚拟调试寄存器">虚拟调试寄存器</h2><p>虚拟寄存器是一种不直接存在于硬件中的寄存器，但调试器将其显示为存在的寄存器。调试软件应该实现它们，但是硬件可以跳过这一节。虚拟寄存器的存在是为了让用户访问不属于标准调试器的功能，而不需要他们在调试器访问这些寄存器时仔细修改调试寄存器。</p><h3 id="priv">priv</h3><blockquote><p>4.9.1 Privilege Level (priv, at virtual)</p></blockquote><p>用户可以读取此寄存器以检查hart停止时运行的特权级别。用户可以写这个寄存器来更改hart恢复时运行的特权级别。</p><table><thead><tr class="header"><th>编码</th><th>特权等级</th></tr></thead><tbody><tr class="odd"><td>0</td><td>User/Application</td></tr><tr class="even"><td>1</td><td>Supervisor</td></tr><tr class="odd"><td>3</td><td>Machine</td></tr></tbody></table><h1 id="触发器模块">触发器模块</h1><p>触发器可以导致断点异常、进入调试模式或跟踪操作，而无需执行特殊指令。这使得它们在从ROM中调试代码时非常宝贵。</p><p>触发器在调试模式下不会触发。</p><p>调试器可以构建所有触发器及其特性的列表，如下所示：</p><ol type="1"><li>将0写入tselect。</li><li>回读tselect并检查它是否包含写入的值。如果不是，则退出循环。</li><li>读tinfo。</li><li>如果导致异常，调试器必须读取tdata1以发现类型。(如果type为0，则此触发器不存在。退出循环。)</li><li>如果info为1，则此触发器不存在。退出循环。</li><li>否则，所选触发器支持info中发现的类型。</li><li>重复，增加tselect中的值。</li></ol><h2 id="本地m-mode触发器">本地M-Mode触发器</h2><p>触发器可用于本机调试。在一个功能齐全的系统上，触发器将使用u或s来设置，当触发它们时，可能会导致一个断点异常被捕获到一个更特权的模式。也可以将触发器本地设置为在M模式下触发。在这种情况下，没有更高的特权模式可以捕获。当这样的触发器在陷阱处理程序中导致断点异常时，这将使系统无法恢复正常执行。</p><p>简单的解决方案是在“M模式”和MIE在mstatus为0的状态下，让硬件防止触发器触发<code>action=0</code>。它的限制是，当用户想要触发触发器时，可能会在其他时间禁用中断。</p><h2 id="触发器寄存器">触发器寄存器</h2><p>这些寄存器是CSR，可以使用RISC-Vcsr操作码访问，也可以选择使用抽象调试命令。</p><p>action编码表</p><table><colgroup><col style="width: 7%"><col style="width: 92%"></colgroup><thead><tr class="header"><th>值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>0</td><td>引发断点异常。(当软件想要在没有外部调试器的情况下使用触发模块时使用。)</td></tr><tr class="even"><td>1</td><td>进入调试模式。(仅当触发器的dmode为1时支持。)</td></tr><tr class="odd"><td>2 - 5</td><td>保留供trace规范使用。</td></tr><tr class="even"><td>other</td><td>保留以备将来使用。</td></tr></tbody></table><p>触发器寄存器表</p><table><thead><tr class="header"><th>地址</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>0x7a0</td><td>Trigger Select (tselect)</td></tr><tr class="even"><td>0x7a1</td><td>Trigger Data 1 (tdata1)</td></tr><tr class="odd"><td>0x7a1</td><td>Match Control (mcontrol)</td></tr><tr class="even"><td>0x7a1</td><td>Instruction Count (icount)</td></tr><tr class="odd"><td>0x7a1</td><td>Interrupt Trigger (itrigger)</td></tr><tr class="even"><td>0x7a1</td><td>Exception Trigger (etrigger)</td></tr><tr class="odd"><td>0x7a2</td><td>Trigger Data 2 (tdata2)</td></tr><tr class="even"><td>0x7a3</td><td>Trigger Data 3 (tdata3)</td></tr><tr class="odd"><td>0x7a3</td><td>Trigger Extra (RV32) (textra32)</td></tr><tr class="even"><td>0x7a3</td><td>Trigger Extra (RV64) (textra64)</td></tr><tr class="odd"><td>0x7a4</td><td>Trigger Info (tinfo)</td></tr><tr class="even"><td>0x7a5</td><td>Trigger Control (tcontrol)</td></tr><tr class="odd"><td>0x7a8</td><td>Machine Context (mcontext)</td></tr><tr class="even"><td>0x7aa</td><td>Supervisor Context (scontext)</td></tr></tbody></table><h3 id="tselect-0x7a0">tselect, 0x7a0</h3><blockquote><p>5.2.1 Trigger Select (tselect, at 0x7a0)</p></blockquote><p>这个寄存器确定哪个触发器可以通过其他触发器寄存器访问。可访问触发器集必须从0开始，并且是连续的。</p><h3 id="tdata1-0x7a1">tdata1, 0x7a1</h3><blockquote><p>5.2.2 Trigger Data 1 (tdata1, at 0x7a1)</p></blockquote><h3 id="tdata2-0x7a2">tdata2, 0x7a2</h3><blockquote><p>5.2.3 Trigger Data 2 (tdata2, at 0x7a2)</p></blockquote><h3 id="tdata3-0x7a3">tdata3, 0x7a3</h3><blockquote><p>5.2.4 Trigger Data 3 (tdata3, at 0x7a3)</p></blockquote><h3 id="tinfo-0x7a4">tinfo, 0x7a4</h3><blockquote><p>5.2.5 Trigger Info (tinfo, at 0x7a4)</p></blockquote><h3 id="tcontrol-0x7a5">tcontrol, 0x7a5</h3><blockquote><p>5.2.6 Trigger Control (tcontrol, at 0x7a5)</p></blockquote><h3 id="mcontext-0x7a8">mcontext, 0x7a8</h3><blockquote><p>5.2.7 Machine Context (mcontext, at 0x7a8)</p></blockquote><h3 id="scontext-0x7aa">scontext, 0x7aa</h3><blockquote><p>5.2.8 Supervisor Context (scontext, at 0x7aa)</p></blockquote><h3 id="mcontrol-0x7a1">mcontrol, 0x7a1</h3><blockquote><p>5.2.9 Match Control (mcontrol, at 0x7a1)</p></blockquote><p>当type为2时，这个寄存器可以作为tdata1访问。</p><h3 id="icount-0x7a1">icount, 0x7a1</h3><blockquote><p>5.2.10 Instruction Count (icount, at 0x7a1)</p></blockquote><p>当type为3时，这个寄存器可以作为tdata1访问。</p><h3 id="itrigger-0x7a1">itrigger, 0x7a1</h3><blockquote><p>5.2.11 Interrupt Trigger (itrigger, at 0x7a1)</p></blockquote><p>当type为4时，这个寄存器可以作为tdata1访问。</p><h3 id="etrigger-0x7a1">etrigger, 0x7a1</h3><blockquote><p>5.2.12 Exception Trigger (etrigger, at 0x7a1)</p></blockquote><p>当type为5时，这个寄存器可以作为tdata1访问。</p><h3 id="textra32-0x7a3">textra32, 0x7a3</h3><blockquote><p>5.2.13 Trigger Extra (RV32) (textra32, at 0x7a3)</p></blockquote><h3 id="textra64-0x7a3">textra64, 0x7a3</h3><blockquote><p>5.2.14 Trigger Extra (RV64) (textra64, at 0x7a3)</p></blockquote><h1 id="调试传输模块dtm">调试传输模块DTM</h1><p>调试传输模块通过一个或多个传输(例如JTAG或USB)提供对DM的访问。</p><p>单个平台中可能有多个dtm。理想情况下，与外部世界通信的每个组件都包含DTM，允许通过平台支持的每种传输对平台进行调试。例如，USB组件可以包含DTM。这样就可以轻松地通过USB调试任何平台。所需要的就是已经在使用的USB模块也可以访问调试模块接口。</p><h2 id="jtag调试传输模块">JTAG调试传输模块</h2><p>这个调试传输模块是基于一个正常的JTAG测试访问端口(TAP)。通过首先使用JTAG指令寄存器(IR)选择一个JTAG寄存器，然后通过JTAG数据寄存器(DR)访问它，JTAGTAP允许访问任意JTAG寄存器。</p><h3 id="jtag-dtm寄存器">JTAG DTM寄存器</h3><p>用作DTM的JTAG抽头必须具有至少5位的IR。当TAP复位时，IR必须默认为00001，选择IDCODE指令。调试器可能使用的唯一常规JTAG寄存器是BYPASS和IDCODE，但是该规范为许多其他标准JTAG指令留下了IR空间。未实现指令必须选择BYPASS寄存器。</p><p>JTAG DTM TAP寄存器表</p><table><colgroup><col style="width: 5%"><col style="width: 46%"><col style="width: 48%"></colgroup><thead><tr class="header"><th>地址</th><th>名称</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>0x00</td><td>BYPASS</td><td>JTAG recommends this encoding</td></tr><tr class="even"><td>0x01</td><td>IDCODE</td><td>JTAG recommends this encoding</td></tr><tr class="odd"><td>0x10</td><td>DTM Control and Status (dtmcs)</td><td>For Debugging</td></tr><tr class="even"><td>0x11</td><td>Debug Module Interface Access (dmi)</td><td>For Debugging</td></tr><tr class="odd"><td>0x12</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V debugging</td></tr><tr class="even"><td>0x13</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V debugging</td></tr><tr class="odd"><td>0x14</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V debugging</td></tr><tr class="even"><td>0x15</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V standards</td></tr><tr class="odd"><td>0x16</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V standards</td></tr><tr class="even"><td>0x17</td><td>Reserved (BYPASS)</td><td>Reserved for future RISC-V standards</td></tr><tr class="odd"><td>0x1f</td><td>BYPASS</td><td>JTAG requires this encoding</td></tr></tbody></table><h3 id="idcode-0x01">IDCODE, 0x01</h3><blockquote><p>6.1.3 IDCODE (at 0x01)</p></blockquote><p>当TAP状态机复位时，选择这个寄存器(在IR中)。其定义与IEEE标准1149.1-2013中的定义完全一致。</p><h3 id="dtmcs-0x10">dtmcs, 0x10</h3><blockquote><p>6.1.4 DTM Control and Status (dtmcs, at 0x10)</p></blockquote><p>在以后的版本中，这个寄存器的大小将保持不变，以便调试器始终可以确定DTM的版本。</p><h3 id="dmi-0x11">dmi, 0x11</h3><blockquote><p>6.1.5 Debug Module Interface Access (dmi, at 0x11)</p></blockquote><p>这个寄存器允许访问调试模块接口(DMI)。</p><p>在Update-DR中，DTM将启动op中指定的操作，除非op中报告的当前状态为sticky。在Capture-DR中，DTM使用该操作的结果更新数据，如果当前操作不是sticky，则更新op。</p><h3 id="bypass-0x1f">BYPASS 0x1f</h3><blockquote><p>6.1.6 BYPASS (at 0x1f)</p></blockquote><p>无效的1位寄存器。当调试器不想与此TAP通信时使用它。</p><h3 id="section"></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统概览&quot;&gt;系统概览&lt;/h1&gt;
&lt;p&gt;平台是由一个或多个元件组成的单个集成电路。有些组件可能是RISC-V内核，而其他组件可能具有不同的功能。通常，它们都将连接到单个系统总线。单个RISC-V核心包含一个或多个硬件线程，称为hart。&lt;/p&gt;
&lt;p&gt;用户与运行调试</summary>
      
    
    
    
    <category term="risc-v" scheme="https://oz1010.github.com/categories/risc-v/"/>
    
    
  </entry>
  
  <entry>
    <title>FreeRTOS解析</title>
    <link href="https://oz1010.github.com/2024/07/09/FreeRTOS%E8%A7%A3%E6%9E%90/"/>
    <id>https://oz1010.github.com/2024/07/09/FreeRTOS%E8%A7%A3%E6%9E%90/</id>
    <published>2024-07-09T14:44:16.000Z</published>
    <updated>2026-01-21T06:34:01.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="freertos源码解析">FreeRTOS源码解析</h1><h2 id="基本配置">基本配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define portSTACK_GROWTH( -1 )</span><br></pre></td></tr></table></figure><h2 id="任务管理">任务管理</h2><h3 id="任务控制块tcb">任务控制块TCB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Task control block.  A task control block (TCB) is allocated for each task,</span><br><span class="line"> * and stores task state information, including a pointer to the task&#x27;s context</span><br><span class="line"> * (the task&#x27;s run time environment, including register values)</span><br><span class="line"> */</span><br><span class="line">typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */</span><br><span class="line">&#123;</span><br><span class="line">    volatile StackType_t * pxTopOfStack; /**&lt; Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */</span><br><span class="line"></span><br><span class="line">    ListItem_t xStateListItem;                  /**&lt; The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */</span><br><span class="line">    ListItem_t xEventListItem;                  /**&lt; Used to reference a task from an event list. */</span><br><span class="line">    UBaseType_t uxPriority;                     /**&lt; The priority of the task.  0 is the lowest priority. */</span><br><span class="line">    StackType_t * pxStack;                      /**&lt; Points to the start of the stack. */</span><br><span class="line">    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /**&lt; Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span><br><span class="line"></span><br><span class="line">    UBaseType_t uxBasePriority; /**&lt; The priority last assigned to the task - used by the priority inheritance mechanism. */</span><br><span class="line">    UBaseType_t uxMutexesHeld;</span><br><span class="line"></span><br><span class="line">    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line"></span><br><span class="line">    uint8_t ucDelayAborted;</span><br><span class="line">&#125; tskTCB;</span><br><span class="line"></span><br><span class="line">/* The old tskTCB name is maintained above then typedefed to the new TCB_t name</span><br><span class="line"> * below to enable the use of older kernel aware debuggers. */</span><br><span class="line">typedef tskTCB TCB_t;</span><br></pre></td></tr></table></figure><h3 id="动态创建任务">动态创建任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tasks.c</span><br><span class="line">BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,</span><br><span class="line">                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span><br><span class="line">                            const configSTACK_DEPTH_TYPE usStackDepth,</span><br><span class="line">                            void * const pvParameters,</span><br><span class="line">                            UBaseType_t uxPriority,</span><br><span class="line">                            TaskHandle_t * const pxCreatedTask )</span><br></pre></td></tr></table></figure><p>portSTACK_GROWTH &lt;0，栈向下增长；为避免栈增长到TCB中，需要先申请栈再申请TCB结构。</p><p><code>pxNewTCB-&gt;pxStack = pxStack;</code>将栈赋值到TCB中。</p><p><code>prvInitialiseNewTask</code>初始化TCB结构。</p><p><code>prvAddNewTaskToReadyList</code>将任务添加到就绪列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )</span><br></pre></td></tr></table></figure><p><code>taskENTER_CRITICAL</code>进入临界区，关闭中断。</p><p><code>prvAddTaskToReadyList</code>将任务按优先级加入就绪队列中。</p><p><code>taskEXIT_CRITICAL</code>退出临界区，开中断。</p><h3 id="开始任务调度">开始任务调度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// tasks.c</span><br><span class="line">void vTaskStartScheduler( void )</span><br></pre></td></tr></table></figure><p><code>xTaskCreate</code>创建idle任务。</p><p><code>xTimerCreateTimerTask</code>创建计时器任务。</p><p><code>portDISABLE_INTERRUPTS</code>禁用中断。</p><p><code>xPortStartScheduler</code>调用开启硬件调度接口，一般是启动tick计时器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// port.c</span><br><span class="line">BaseType_t xPortStartScheduler( void )</span><br></pre></td></tr></table></figure><p><code>portDISABLE_INTERRUPTS</code>禁用中断。</p><p><code>configSETUP_TICK_INTERRUPT</code>配置tick计时器。</p><p><code>vPortRestoreTaskContext</code>开始执行第一个任务。</p><p>汇编程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// portASM.S</span><br><span class="line">/******************************************************************************</span><br><span class="line"> * vPortRestoreTaskContext is used to start the scheduler.</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">.align 8</span><br><span class="line">.type vPortRestoreTaskContext, %function</span><br><span class="line">vPortRestoreTaskContext:</span><br><span class="line">.set freertos_vector_base,_freertos_vector_table</span><br><span class="line"></span><br><span class="line">/* Install the FreeRTOS interrupt handlers. */</span><br><span class="line">LDRX1, =freertos_vector_base</span><br><span class="line">#if defined( GUEST )</span><br><span class="line">MSRVBAR_EL1, X1</span><br><span class="line">#else</span><br><span class="line">MSRVBAR_EL3, X1</span><br><span class="line">#endif</span><br><span class="line">DSBSY</span><br><span class="line">ISBSY</span><br><span class="line"></span><br><span class="line">/* Start the first task. */</span><br><span class="line">portRESTORE_CONTEXT</span><br></pre></td></tr></table></figure><h3 id="任务切换">任务切换</h3><p><code>MPS2_QEMU</code>会调用汇编处理程序<code>xPortPendSVHandler</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void xPortPendSVHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* This is a naked function. */</span><br><span class="line"></span><br><span class="line">    __asm volatile</span><br><span class="line">    (</span><br><span class="line">        &quot;mrs r0, psp\n&quot;</span><br><span class="line">        &quot;isb\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;ldrr3, pxCurrentTCBConst\n&quot;/* Get the location of the current TCB. */</span><br><span class="line">        &quot;ldrr2, [r3]\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;stmdb r0!, &#123;r4-r11&#125;\n&quot;/* Save the remaining registers. */</span><br><span class="line">        &quot;str r0, [r2]\n&quot;/* Save the new top of stack into the first member of the TCB. */</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;stmdb sp!, &#123;r3, r14&#125;\n&quot;</span><br><span class="line">        &quot;mov r0, %0\n&quot;</span><br><span class="line">        &quot;msr basepri, r0\n&quot;</span><br><span class="line">        &quot;bl vTaskSwitchContext\n&quot;</span><br><span class="line">        &quot;mov r0, #0\n&quot;</span><br><span class="line">        &quot;msr basepri, r0\n&quot;</span><br><span class="line">        &quot;ldmia sp!, &#123;r3, r14&#125;\n&quot;</span><br><span class="line">        &quot;\n&quot;/* Restore the context, including the critical nesting count. */</span><br><span class="line">        &quot;ldr r1, [r3]\n&quot;</span><br><span class="line">        &quot;ldr r0, [r1]\n&quot;/* The first item in pxCurrentTCB is the task top of stack. */</span><br><span class="line">        &quot;ldmia r0!, &#123;r4-r11&#125;\n&quot;/* Pop the registers. */</span><br><span class="line">        &quot;msr psp, r0\n&quot;</span><br><span class="line">        &quot;isb\n&quot;</span><br><span class="line">        &quot;bx r14\n&quot;</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;.align 4\n&quot;</span><br><span class="line">        &quot;pxCurrentTCBConst: .word pxCurrentTCB\n&quot;</span><br><span class="line">        ::&quot;i&quot; ( configMAX_SYSCALL_INTERRUPT_PRIORITY )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenAI辅助理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void PendSV_Handler(void) &#123;</span><br><span class="line">    /* 保存当前任务的上下文 */</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;MRS     R0, PSP              \n&quot; /* 获取进程堆栈指针 */</span><br><span class="line">        &quot;STMDB   R0!, &#123;R4-R11&#125;        \n&quot; /* 保存R4-R11寄存器到堆栈 */</span><br><span class="line">        &quot;LDR     R1, =pxCurrentTCB    \n&quot; /* 加载当前TCB指针地址 */</span><br><span class="line">        &quot;LDR     R2, [R1]             \n&quot; /* 加载当前TCB指针 */</span><br><span class="line">        &quot;STR     R0, [R2]             \n&quot; /* 保存堆栈指针到当前TCB */</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /* 切换到下一个任务 */</span><br><span class="line">    vTaskSwitchContext();</span><br><span class="line"></span><br><span class="line">    /* 恢复下一个任务的上下文 */</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;LDR     R1, =pxCurrentTCB    \n&quot; /* 加载当前TCB指针地址 */</span><br><span class="line">        &quot;LDR     R2, [R1]             \n&quot; /* 加载当前TCB指针 */</span><br><span class="line">        &quot;LDR     R0, [R2]             \n&quot; /* 加载堆栈指针 */</span><br><span class="line">        &quot;LDMIA   R0!, &#123;R4-R11&#125;        \n&quot; /* 恢复R4-R11寄存器 */</span><br><span class="line">        &quot;MSR     PSP, R0              \n&quot; /* 恢复进程堆栈指针 */</span><br><span class="line">        &quot;BX      LR                   \n&quot; /* 返回任务 */</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用切换上下文函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// task.c</span><br><span class="line">void vTaskSwitchContext( void )</span><br></pre></td></tr></table></figure><p><code>taskSELECT_HIGHEST_PRIORITY_TASK</code>选择最高优先级任务</p><h2 id="时钟管理">时钟管理</h2><h3 id="时钟节拍">时钟节拍</h3><p><code>MPS2_QEMU</code>会调用处理程序<code>xPortSysTickHandler</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// port.c</span><br><span class="line">void xPortSysTickHandler( void )</span><br></pre></td></tr></table></figure><p><code>portDISABLE_INTERRUPTS</code>关闭中断。</p><p><code>xTaskIncrementTick</code>尝试增加tick值，成功后触发PendSV中断，强行进行一次调度。</p><p><code>portENABLE_INTERRUPTS</code>打开中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// tasks.c</span><br><span class="line">BaseType_t xTaskIncrementTick( void )</span><br></pre></td></tr></table></figure><p><code>taskSWITCH_DELAYED_LISTS</code>系统tick值反转时，将延时任务队列与反转反转队列互换。</p><p>判断是否有超时的任务，并将其移入就绪队列中。</p><h3 id="任务延时">任务延时</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void vTaskDelay( const TickType_t xTicksToDelay )</span><br></pre></td></tr></table></figure><p><code>vTaskSuspendAll</code>关闭调度器。</p><p><code>prvAddCurrentTaskToDelayedList</code>将当前任务加到延时列表中。</p><p><code>xTaskResumeAll</code>恢复调度器。</p><p><code>portYIELD_WITHIN_API</code>当恢复调度时未进行再次调度，则强制进行调度并让任务进入睡眠状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,</span><br><span class="line">                                            const BaseType_t xCanBlockIndefinitely )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uxListRemove</code>将当前任务移除队列中。</p><p><code>xTimeToWake = xConstTickCount + xTicksToWait</code>计算下次唤醒的时刻。需要考虑时间反转的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;freertos源码解析&quot;&gt;FreeRTOS源码解析&lt;/h1&gt;
&lt;h2 id=&quot;基本配置&quot;&gt;基本配置&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="FreeRTOS" scheme="https://oz1010.github.com/categories/FreeRTOS/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenOCD使用简介</title>
    <link href="https://oz1010.github.com/2024/07/01/OpenOCD%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://oz1010.github.com/2024/07/01/OpenOCD%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2024-07-01T10:21:11.000Z</published>
    <updated>2026-01-21T06:34:01.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息">基本信息</h1><p><a href="https://github.com/openocd-org/openocd">OpenOCD</a>（OpenOn-Chip Debugger）</p><p>提供依赖JTAG接口的分层架构的片上编程和调试支持和TAP支持，包括：</p><ul><li>(X)SVF回放，便于自动边界扫描和FPGA/CPLD编程；</li><li>调试目标支持（如ARM、MIPS）：单步调试、断点/监控点、gprof性能分析等；</li><li>Flash芯片驱动（如CFI、NAND、内部闪存）；</li><li>内嵌TCL解释器，方便脚本编写；</li></ul><p>OpenOCD支持众多网络接口与之交互：包括：telnet、TCL和GDB。GDBserver可以使得OpenOCD作为“远程目标”，使用标准的GNUGDB程序（和其他使用GDB协议的工具，如IDA Pro）源码级调试嵌入式系统。</p><h2 id="官方手册">官方手册</h2><p><a href="https://openocd.org/doc/html/index.html">OpenOCD用户手册</a></p><p><a href="https://openocd.org/doc/doxygen/html/index.html">OpenOCD开发手册</a></p><h1 id="工程编译">工程编译</h1><h1 id="源码解析">源码解析</h1><h2 id="自动生成配置">自动生成配置</h2><h3 id="配置命令">配置命令</h3><p>Linux环境中，执行<code>./configure xxx</code>配置后会返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/local/OpenOCD --datarootdir=/usr/local/OpenOCD --enable-ftdi=no --enable-remote-bitbang=no --enable-ep93xx=no --enable-amtjtagaccel=no --enable-jtag_dpi=no --enable-vdebug=no --enable-jtag_vpi=no --enable-buspirate=no --enable-openjtag=no --enable-presto=no --enable-stlink=no --enable-ti-icdi=no --enable-ulink=no --enable-usb-blaster-2=no --enable-ft232r=no --enable-vsllink=no --enable-xds110=no --enable-osbdm=no --enable-opendous=no --enable-armjtagew=no --enable-rlink=no --enable-usbprog=no --enable-esp-usb-jtag=no --enable-nulink=no --enable-kitprog=no --enable-usb-blaster=no --enable-parport-giveio=no --disable-werror --enable-dummy=yes</span><br><span class="line"></span><br><span class="line">OpenOCD configuration summary</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Linux GPIO bitbang through libgpiod     no</span><br><span class="line">SEGGER J-Link Programmer                yes (auto)</span><br><span class="line">Dummy Adapter                           yes</span><br><span class="line">RISC-V Link Adapter                     yes</span><br><span class="line">Use Capstone disassembly framework      no</span><br></pre></td></tr></table></figure><h3 id="新增rvlink适配器">新增rvlink适配器</h3><p><code>configure.ac</code>中新增<code>RVLINK_ADAPTER</code>配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">m4_define([DUMMY_ADAPTER],</span><br><span class="line">[[[dummy], [Dummy Adapter], [DUMMY]]])</span><br><span class="line"></span><br><span class="line">m4_define([RVLINK_ADAPTER],</span><br><span class="line">  [[[rvlink], [RISC-V Link Adapter], [RVLINK]]])</span><br><span class="line">...</span><br><span class="line">AC_ARG_ADAPTERS([DUMMY_ADAPTER],[no])</span><br><span class="line"></span><br><span class="line">AC_ARG_ADAPTERS([RVLINK_ADAPTER],[yes])</span><br><span class="line">...</span><br><span class="line">PROCESS_ADAPTERS([DUMMY_ADAPTER], [true], [unused])</span><br><span class="line">PROCESS_ADAPTERS([RVLINK_ADAPTER], [true], [unused])</span><br><span class="line">...</span><br><span class="line">m4_foreach([adapter], [USB1_ADAPTERS,</span><br><span class="line">HIDAPI_ADAPTERS, HIDAPI_USB1_ADAPTERS, LIBFTDI_ADAPTERS,</span><br><span class="line">LIBFTDI_USB1_ADAPTERS,</span><br><span class="line">LIBGPIOD_ADAPTERS,</span><br><span class="line">LIBJAYLINK_ADAPTERS, PCIE_ADAPTERS, SERIAL_PORT_ADAPTERS,</span><br><span class="line">DUMMY_ADAPTER,</span><br><span class="line">    RVLINK_ADAPTER,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>例如，对于<code>rvlink</code>适配器，其名称是<code>RISC-V Link Adapter</code>，编译宏为<code>BUILD_RVLINK</code>。</p><p>JTAG驱动编控制文件<code>src/jtag/drivers/Makefile.am</code>中可以使用编译宏<code>RVLINK</code>控制编译的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if DUMMY</span><br><span class="line">DRIVERFILES += %D%/dummy.c</span><br><span class="line">endif</span><br><span class="line">if RVLINK</span><br><span class="line">DRIVERFILES += %D%/rvlink.c</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>Linux环境中编译会包含<code>rvlink.c</code>文件。</p><p><code>src/jtag/interfaces.c</code>文件适配器驱动列表新增适配器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct adapter_driver *adapter_drivers[] = &#123;</span><br><span class="line">#if BUILD_DUMMY == 1</span><br><span class="line">&amp;dummy_adapter_driver,</span><br><span class="line">#endif</span><br><span class="line">#if BUILD_RVLINK == 1</span><br><span class="line">&amp;rvlink_adapter_driver,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据结构">数据结构</h2><h3 id="调试目标target">调试目标target</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/target/target.h</span><br><span class="line">struct target &#123;</span><br><span class="line">struct target_type *type; // 包含目标名称和访问函数</span><br><span class="line">struct jtag_tap *tap; // jtag扫描链</span><br><span class="line">bool examined; // 检查目标标记</span><br><span class="line">enum target_debug_reason debug_reason; // 目标进入调试状态原因枚举</span><br><span class="line">enum target_state state; // 当前目标状态</span><br><span class="line">struct reg_cache *reg_cache; // 寄存器缓存</span><br><span class="line">struct breakpoint *breakpoints; // bp断点列表</span><br><span class="line">struct watchpoint *watchpoints; // wp断点列表</span><br><span class="line">struct trace *trace_info; // 跟踪信息</span><br><span class="line">void *arch_info; // 架构信息，常用于target与架构互转</span><br><span class="line">void *private_config; // 配置信息</span><br><span class="line">struct rtos *rtos; // RTOS信息</span><br><span class="line">struct list_head *smp_targets; // SMP列表节点</span><br><span class="line">struct gdb_service *gdb_service;  //  SMP场景，所有调试目标使用相同的GDB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调试目标列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/target/target.c</span><br><span class="line">static struct target_type *target_types[] = &#123;</span><br><span class="line">&amp;stm8_target,</span><br><span class="line">&amp;riscv_target,</span><br><span class="line">NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于ARM架构处理器，可以通过<code>container_of(target-&gt;arch_info, struct cortex_a_common, armv7a_common.arm)</code>，将<code>target</code>转换为<code>cortex_a_common</code>，然后可以获取ADI版本版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// struct adiv5_dap-&gt;adi_version</span><br><span class="line">struct cortex_a_common *cortex_a = target_to_cortex_a(target);</span><br><span class="line">struct armv7a_common *armv7a = &amp;cortex_a-&gt;armv7a_common;</span><br><span class="line">armv7a-&gt;debug_ap-&gt;dap-&gt;adi_version == 5; /** Indicates ADI version (5, 6 or 0 for unknown) being used */</span><br></pre></td></tr></table></figure><h3 id="适配器adapter">适配器adapter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// icd_openocd/src/jtag/interface.h</span><br><span class="line">struct adapter_driver &#123;</span><br><span class="line">const char * const *transports; // 传输列表</span><br><span class="line">const struct command_registration *commands; // 命令列表</span><br><span class="line">// JTAG设备操作接口</span><br><span class="line">int (*init)(void); // 初始化资源</span><br><span class="line">int (*reset)(int srst, int trst); // 控制设备SRST和TRST信号</span><br><span class="line"></span><br><span class="line">struct jtag_interface *jtag_ops; // 低等级JTAG接口</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JTAG接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// icd_openocd/src/jtag/interface.h</span><br><span class="line">struct jtag_interface &#123;</span><br><span class="line">unsigned supported; // 驱动支持能力的位表</span><br><span class="line">int (*execute_queue)(struct jtag_command *cmd_queue); // 执行队列中的命令</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="服务service">服务service</h3><p>服务<code>service</code>，主要用于管理服务。在创建服务时会复制对应的服务驱动接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/server/server.h</span><br><span class="line">struct service &#123;</span><br><span class="line">char *name;</span><br><span class="line">struct connection *connections;</span><br><span class="line">int (*new_connection)(struct connection *connection);</span><br><span class="line">int (*input)(struct connection *connection);</span><br><span class="line">void (*keep_client_alive)(struct connection *connection);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务驱动<code>service_driver</code>，主要定义基本结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/server/server.h</span><br><span class="line">struct service_driver &#123;</span><br><span class="line">const char *name;</span><br><span class="line">int (*new_connection_handler)(struct connection *connection);</span><br><span class="line">int (*input_handler)(struct connection *connection);</span><br><span class="line">void (*keep_client_alive_handler)(struct connection *connection);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GDB服务驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/server/gdb_server.c</span><br><span class="line">static const struct service_driver gdb_service_driver = &#123;</span><br><span class="line">.name = &quot;gdb&quot;,</span><br><span class="line">.new_connection_during_keep_alive_handler = NULL,</span><br><span class="line">.new_connection_handler = gdb_new_connection,</span><br><span class="line">.input_handler = gdb_input,</span><br><span class="line">.connection_closed_handler = gdb_connection_closed,</span><br><span class="line">.keep_client_alive_handler = gdb_keep_client_alive,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连接<code>connection</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/server/server.h</span><br><span class="line">struct connection &#123;</span><br><span class="line">int fd;</span><br><span class="line">int fd_out;/* When using pipes we&#x27;re writing to a different fd */</span><br><span class="line">struct sockaddr_in sin;</span><br><span class="line">struct command_context *cmd_ctx;</span><br><span class="line">struct service *service;</span><br><span class="line">bool input_pending;</span><br><span class="line">void *priv;</span><br><span class="line">struct connection *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="启动openocd">启动OpenOCD</h2><p>运行命令<code>./src/openocd -s tcl -f tcl/interface/cmsis-dap.cfg -f tcl/target/xxxx.cfg</code>启动OpenOCD。</p><h3 id="配置文件解析">配置文件解析</h3><p>适配器驱动处理，各tcl配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 适配器驱动文件 tcl/interface/cmsis-dap.cfg</span><br><span class="line">adapter driver cmsis-dap</span><br><span class="line">transport select jtag</span><br><span class="line">adapter speed 2000</span><br><span class="line"></span><br><span class="line">// 目标配置文件 tcl/target/xxxx.cfg</span><br><span class="line">telnet_port 4444</span><br><span class="line">gdb_port 3333</span><br><span class="line">jtag newtap $_CHIPNAME cpu -enable -irlen 32</span><br><span class="line">target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid $_HARTID</span><br></pre></td></tr></table></figure><p>解析tcl配置文件主流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主流程 src/openocd.c</span><br><span class="line">openocd_main</span><br><span class="line">    setup_command_handler // 注册命令处理函数</span><br><span class="line">        adapter_register_commands // 注册adapter命令处理服务</span><br><span class="line">    openocd_thread</span><br><span class="line">        parse_config_file // 解析配置文件</span><br><span class="line">        // 处理 tcl/interface/cmsis-dap.cfg 配置文件</span><br><span class="line">        // 处理 tcl/target/xxxx.cfg</span><br></pre></td></tr></table></figure><p><code>adapter</code>命令匹配<code>"cmsis-dap"</code>流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// adapter命令回调，适配器配置解析匹配名称 src/jtag/adapter.c</span><br><span class="line">interface_command_handlers // 匹配命令adapter</span><br><span class="line">    adapter_command_handlers // 匹配命令driver</span><br><span class="line">        handle_adapter_driver_command // 若驱动名称匹配，则切换adapter_driver，注册驱动的命令列表并更新allowed_transports列表</span><br></pre></td></tr></table></figure><p>适配器列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 适配器驱动列表 src/jtag/interfaces.c</span><br><span class="line">struct adapter_driver *adapter_drivers[] = &#123;</span><br><span class="line">#if BUILD_CMSIS_DAP_USB == 1 || BUILD_CMSIS_DAP_HID == 1</span><br><span class="line">&amp;cmsis_dap_adapter_driver,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">// &quot;cmsis-dap&quot;适配器驱动</span><br><span class="line">struct adapter_driver cmsis_dap_adapter_driver = &#123;</span><br><span class="line">.name = &quot;cmsis-dap&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他命令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 解析目标配置文件，处理文件中各行命令</span><br><span class="line">// 处理命令telnet_port，handle_telnet_port_command设置telnet_port</span><br><span class="line">// 处理命令gdb_port，handle_gdb_port_command设置gdb_port</span><br><span class="line">// 处理命令transport select，handle_transport_select在allowed_transports列表中匹配传输</span><br></pre></td></tr></table></figure><h3 id="主函数流程概览">主函数流程概览</h3><p><code>openocd_main</code>函数初始化逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// src/openocd.c</span><br><span class="line">int openocd_main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 注册各命令的处理函数</span><br><span class="line">    struct command_context *cmd_ctx;</span><br><span class="line">    cmd_ctx = setup_command_handler(NULL);</span><br><span class="line">    ...</span><br><span class="line">    ret = openocd_thread(argc, argv, cmd_ctx);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// src/openocd.c</span><br><span class="line">static int openocd_thread(int argc, char *argv[], struct command_context *cmd_ctx)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 解析命令行参数</span><br><span class="line">    parse_cmdline_args(cmd_ctx, argc, argv);</span><br><span class="line">    ...</span><br><span class="line">    // 解析配置文件，对调试器进行配置</span><br><span class="line">    ret = parse_config_file(cmd_ctx);</span><br><span class="line">    ...</span><br><span class="line">    ret = server_init(cmd_ctx);</span><br><span class="line">    ...</span><br><span class="line">    ret = command_run_line(cmd_ctx, &quot;init&quot;);</span><br><span class="line">    ...</span><br><span class="line">    ret = server_loop(cmd_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>server_init</code>函数初始化逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/server/server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">server_init</span><span class="params">(<span class="keyword">struct</span> command_context *cmd_ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = tcl_init();</span><br><span class="line">    ret = telnet_init(<span class="string">&quot;Open On-Chip Debugger&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/server/tcl_server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_service(&amp;tcl_service_driver, tcl_port, CONNECTION_LIMIT_UNLIMITED, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_driver</span> <span class="title">tcl_service_driver</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;tcl&quot;</span>,</span><br><span class="line">    .new_connection_during_keep_alive_handler = <span class="literal">NULL</span>,</span><br><span class="line">    .new_connection_handler = tcl_new_connection,</span><br><span class="line">    .input_handler = tcl_input,</span><br><span class="line">    .connection_closed_handler = tcl_closed,</span><br><span class="line">    .keep_client_alive_handler = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/server/telnet_server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">telnet_init</span><span class="params">(<span class="type">char</span> *banner)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = add_service(&amp;telnet_service_driver, telnet_port, CONNECTION_LIMIT_UNLIMITED,</span><br><span class="line">        telnet_service);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_driver</span> <span class="title">telnet_service_driver</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;telnet&quot;</span>,</span><br><span class="line">    .new_connection_during_keep_alive_handler = <span class="literal">NULL</span>,</span><br><span class="line">    .new_connection_handler = telnet_new_connection,</span><br><span class="line">    .input_handler = telnet_input,</span><br><span class="line">    .connection_closed_handler = telnet_connection_closed,</span><br><span class="line">    .keep_client_alive_handler = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>server_loop</code>主循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/server/server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">server_loop</span><span class="params">(<span class="keyword">struct</span> command_context *command_context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环处理services中所有服务的连接列表</span></span><br><span class="line">    <span class="keyword">while</span>(shutdown_openocd == CONTINUE_MAIN_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// socket_select多路复用监听fd</span></span><br><span class="line">        <span class="comment">// 轮询监听间隔为100ms</span></span><br><span class="line">        <span class="comment">// 若服务有数据（service-&gt;fd），则接受连接并创建新的连接</span></span><br><span class="line">        <span class="comment">// 若连接有数据（c-&gt;fd），则调用service-&gt;input进行处理</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="risc-v架构目标示例">RISC-V架构目标示例</h3><p>NEMU是RISC-V架构处理器硬件模拟器，OpenOCD通过TCP/51234接口连接它。</p><p>启动命令：<code>./src/openocd -s tcl -f tcl/interface/rvlink.cfg -f tcl/target/simu/nemu.cfg</code></p><p>TCL配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// tcl/interface/rvlink.cfg</span><br><span class="line">adapter driver RV-LINK</span><br><span class="line">transport select jtag</span><br><span class="line">rvlink connect 127.0.0.1 51234</span><br><span class="line"></span><br><span class="line">// tcl/target/simu/nemu.cfg</span><br><span class="line">if &#123; ![info exists _SMP_MODE] &#125; &#123;</span><br><span class="line">    set _SMP_MODE 1</span><br><span class="line">&#125;</span><br><span class="line">if &#123;![info exists _HARTID]&#125; &#123;</span><br><span class="line">set _HARTID 0x00</span><br><span class="line">&#125;</span><br><span class="line">if &#123;![info exists _CHIPNAME]&#125; &#123;</span><br><span class="line">set _CHIPNAME nemu</span><br><span class="line">&#125;</span><br><span class="line">set _TARGETNAME $_CHIPNAME.cpu</span><br><span class="line">adapter speed 2000</span><br><span class="line">telnet_port 4444</span><br><span class="line">gdb_port 3333</span><br><span class="line">jtag newtap $_CHIPNAME cpu -enable -irlen 32</span><br><span class="line">set _SMP_GROUP &quot;&quot;</span><br><span class="line">target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid $_HARTID</span><br><span class="line">set _SMP_GROUP &quot;$::_SMP_GROUP $_TARGETNAME&quot;</span><br><span class="line">if &#123; $_SMP_MODE == 1 &#125; &#123;</span><br><span class="line">    eval &quot;target smp $_SMP_GROUP&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功启动并连接时的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./src/openocd -s tcl -f tcl/interface/rvlink.cfg -f tcl/target/simu/nemu.cfg</span><br><span class="line">Open On-Chip Debugger 0.12.0+dev-03889-g5fefbc2da-dirty (2024-09-10-10:57)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">Info : Connected to server 127.0.0.1:51234</span><br><span class="line">Info : Listening on port 6666 for tcl connections</span><br><span class="line">Info : Listening on port 4444 for telnet connections</span><br><span class="line">Info : Note: The adapter &quot;RV-LINK&quot; doesn&#x27;t support configurable speed</span><br><span class="line">Info : JTAG tap: nemu.cpu tap/device found: 0x3ba0184d (mfg: 0x426 (Google Inc), part: 0xba01, ver: 0x3)</span><br><span class="line">Info : [nemu.cpu] datacount=1 progbufsize=0</span><br><span class="line">Warn : [nemu.cpu] We won&#x27;t be able to execute fence instructions on this target. Memory may not always appear consistent. (progbufsize=0, impebreak=0)</span><br><span class="line">Info : [nemu.cpu] Vector support with vlenb=0</span><br><span class="line">Info : [nemu.cpu] S?aia detected with IMSIC</span><br><span class="line">Info : [nemu.cpu] Core 0 made part of halt group 1.</span><br><span class="line">Info : [nemu.cpu] Examined RISC-V core</span><br><span class="line">Info : [nemu.cpu]  XLEN=32, misa=0x40000000</span><br><span class="line">[nemu.cpu] Target successfully examined.</span><br><span class="line">Info : [nemu.cpu] Examination succeed</span><br><span class="line">Info : [nemu.cpu] starting gdb server on 3333</span><br><span class="line">Info : Listening on port 3333 for gdb connections</span><br></pre></td></tr></table></figure><h4 id="rvlink.cfg文件">rvlink.cfg文件</h4><p><code>adapter</code>命令匹配<code>"RV-LINK"</code>流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// adapter命令回调，适配器配置解析匹配名称 src/jtag/adapter.c</span><br><span class="line">interface_command_handlers // 匹配命令adapter</span><br><span class="line">    adapter_command_handlers // 匹配命令driver</span><br><span class="line">        handle_adapter_driver_command // 若驱动名称匹配，则切换adapter_driver，注册驱动的命令列表并更新allowed_transports列表</span><br></pre></td></tr></table></figure><p>适配器列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 适配器驱动列表 src/jtag/interfaces.c</span><br><span class="line">struct adapter_driver *adapter_drivers[] = &#123;</span><br><span class="line">#if BUILD_RVLINK == 1</span><br><span class="line">&amp;rvlink_adapter_driver,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">// &quot;RV-LINK&quot;适配器驱动 src/jtag/drivers/rvlink.c</span><br><span class="line">struct adapter_driver rvlink_adapter_driver = &#123;</span><br><span class="line">.name = &quot;RV-LINK&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>transport</code>命令选择<code>jtag</code>流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// transport命令回调 src/transport/transport.c</span><br><span class="line">transport_group // 匹配命令transport</span><br><span class="line">transport_commands // 匹配命令select</span><br><span class="line">handle_transport_select // 若名称匹配，则更新transport</span><br><span class="line">transport_select // 调用select回调函数，并更新session</span><br></pre></td></tr></table></figure><p>内置jtag传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/jtag/core.c</span><br><span class="line">static struct transport jtag_transport = &#123;</span><br><span class="line">.name = &quot;jtag&quot;,</span><br><span class="line">.select = jtag_select,</span><br><span class="line">.init = jtag_init,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>rvlink</code>命令执行流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// src/jtag/drivers/rvlink.c</span><br><span class="line">rvlink_commands // 匹配命令rvlink</span><br><span class="line">rvlink_subcommands // 匹配命令connect</span><br><span class="line">rvlink_connect // 为目标建立TCP连接</span><br></pre></td></tr></table></figure><h4 id="nemu.cfg文件">nemu.cfg文件</h4><p><code>telnet_port</code>命令修改telnet端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// src/server/telnet_server.c</span><br><span class="line">telnet_command_handlers // 匹配命令telnet_port</span><br><span class="line">handle_telnet_port_command // 直接调用函数</span><br><span class="line">server_pipe_command // 修改telnet_port字符串的值</span><br></pre></td></tr></table></figure><p><code>gdb_port</code>命令修改gdb远程连接端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_command_handlers // 匹配gdb_port</span><br><span class="line">handle_gdb_port_command // 修改gdb_port字符串的值，并同步更新gdb_port_next</span><br></pre></td></tr></table></figure><p><code>jtag</code>命令创建新的tap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// jtag newtap nemu cpu -enable -irlen 32</span><br><span class="line">// src/jtag/tcl.c</span><br><span class="line">jtag_command_handlers // 匹配jtag</span><br><span class="line">jtag_subcommand_handlers // 匹配newtap</span><br><span class="line">handle_jtag_newtap // 创建nemu.cpu的tap对象</span><br><span class="line">handle_jtag_newtap_args // 初始化tap对象，名称、ir配置</span><br><span class="line">jtag_tap_init // 配置tap并将其加入tap列表__jtag_all_taps</span><br></pre></td></tr></table></figure><p><code>target</code>命令创建连接目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// target create nemu.cpu riscv -chain-position nemu.cpu -coreid 0x00</span><br><span class="line">// src/target/target.c</span><br><span class="line">target_command_handlers // 匹配target</span><br><span class="line">target_subcommand_handlers // 匹配create</span><br><span class="line">jim_target_create // 调整参数并调用函数</span><br><span class="line">target_create // 创建并匹配&quot;riscv&quot;调试目标，注册调试命令，更新all_targets</span><br></pre></td></tr></table></figure><p><code>target</code>命令设置smp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// target smp nemu.cpu</span><br><span class="line">// src/target/target.c</span><br><span class="line">target_command_handlers // 匹配target</span><br><span class="line">target_subcommand_handlers // 匹配smp</span><br><span class="line">handle_target_smp // 将所有target加入到smp列表中，每个组的smp编号从1开始</span><br></pre></td></tr></table></figure><h4 id="初始化命令">初始化命令</h4><p><code>init</code>命令初始化openocd，将会通过<code>command_run_line</code>函数触发一系列初始化函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// src/openocd.c</span><br><span class="line">openocd_command_handlers // 匹配init</span><br><span class="line">handle_init_command // 执行初始化函数。执行过程中jtag_poll_en为false，执行完成后恢复。</span><br><span class="line">// target init命令</span><br><span class="line">adapter_init // 适配器初始化 src/jtag/adapter.c</span><br><span class="line">adapter_driver_gpios_init // 适配器驱动通用IO口初始化</span><br><span class="line">// 特定（示例的rvlink）适配器初始化接口</span><br><span class="line">// transport init命令</span><br><span class="line">// dap init命令</span><br><span class="line">target_examine // 循环检查调试目标列表；</span><br><span class="line">// 延时检查</span><br><span class="line">target_examine_one // 单次检查</span><br><span class="line">target-&gt;type-&gt;examine(target) // 调用特定（示例为riscv）架构对应的检查接口</span><br><span class="line">// flash init命令</span><br><span class="line">// nand init命令</span><br><span class="line">// pld init命令</span><br><span class="line">// tpiu init命令</span><br><span class="line">gdb_target_add_all // 循环调试目标列表，启动对应的GDB server</span><br><span class="line">// _run_post_init_commands命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>target</code>命令初始化所有调试目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// target init </span><br><span class="line">// src/target/target.c</span><br><span class="line">target_command_handlers // 匹配target</span><br><span class="line">target_subcommand_handlers // 匹配init</span><br><span class="line">handle_target_init_command // 直接调用startup.tcl脚本命令 init_targets init_target_events init_board</span><br><span class="line"></span><br><span class="line">// init_targets 初始化函数为空</span><br><span class="line">// src/target/startup.tcl</span><br><span class="line">proc init_targets &#123;&#125; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// init_target_events // 循环遍历目标列表，通过set_default_target_event为所有目标设置默认事件命令</span><br><span class="line">// src/target/startup.tcl</span><br><span class="line">proc init_target_events &#123;&#125; &#123;</span><br><span class="line">set targets [target names] // 获取到所有调试目标名称</span><br><span class="line">foreach t $targets &#123;</span><br><span class="line">set_default_target_event $t gdb-flash-erase-start &quot;reset init&quot;</span><br><span class="line">set_default_target_event $t gdb-flash-write-end &quot;reset halt&quot;</span><br><span class="line">set_default_target_event $t gdb-attach &quot;halt 1000&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// init_board 初始化函数为空</span><br><span class="line">// src/target/startup.tcl</span><br><span class="line">proc init_board &#123;&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transport</code>传输初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// transport init</span><br><span class="line">// src/transport/transport.c</span><br><span class="line">transport_group // 匹配transport</span><br><span class="line">transport_commands // 匹配init</span><br><span class="line">handle_transport_init // 校验是否设置session变量，并调用特定（示例为jtag）的初始化接口</span><br><span class="line"></span><br><span class="line">// jtag适配器初始化</span><br><span class="line">// src/jtag/core.c</span><br><span class="line">jtag_init // 初始化jtag适配器并执行jtag_init命令</span><br><span class="line"></span><br><span class="line">// jtag_init</span><br><span class="line">// src/jtag/startup.tcl</span><br><span class="line">proc jtag_init &#123;&#125; &#123;</span><br><span class="line">if &#123;[catch &#123;jtag arp_init&#125; err]!=0&#125; &#123;</span><br><span class="line"># try resetting additionally</span><br><span class="line">init_reset startup</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jtag arp_init</span><br><span class="line">// src/jtag/tcl.c</span><br><span class="line">jtag_command_handlers // 匹配jtag</span><br><span class="line">jtag_subcommand_handlers // 匹配arp_init</span><br><span class="line">handle_jtag_arp_init // 直接调用内部函数</span><br><span class="line">jtag_init_inner // 执行jtag tap等初始化</span><br></pre></td></tr></table></figure><p><code>dap</code>初始化处理逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// dap init</span><br><span class="line">// src/target/arm_dap.c</span><br><span class="line">dap_commands // 匹配dap</span><br><span class="line">dap_subcommand_handlers // 匹配init</span><br><span class="line">handle_dap_init // 直接调用函数</span><br><span class="line">dap_init_all // 初始化所有dap对象</span><br></pre></td></tr></table></figure><p>简单命令：<code>flash init</code> <code>nand init</code><code>pld init</code> <code>tpiu init</code></p><p><code>_run_post_init_commands</code>初始化结束脚本命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/helper/startup.tcl</span><br><span class="line">// 循环处理post_init_commands列表</span><br><span class="line">proc _run_post_init_commands &#123;&#125; &#123;</span><br><span class="line">if &#123;[info exists ::post_init_commands]&#125; &#123;</span><br><span class="line">foreach cmd $::post_init_commands &#123;</span><br><span class="line">eval $cmd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// src/target/startup.tcl</span><br><span class="line">// 将以下脚本函数加入到post_init_commands列表</span><br><span class="line">lappend post_init_commands _post_init_target_array_mem</span><br><span class="line">lappend post_init_commands _post_init_target_cortex_a_cache_auto</span><br></pre></td></tr></table></figure><h2 id="gdb交互">GDB交互</h2><h3 id="gdb连接处理">GDB连接处理</h3><p><code>server_loop</code>主循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/server/server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">server_loop</span><span class="params">(<span class="keyword">struct</span> command_context *command_context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环处理services中所有服务的连接列表</span></span><br><span class="line">    <span class="keyword">while</span>(shutdown_openocd == CONTINUE_MAIN_LOOP)</span><br><span class="line">    &#123;</span><br><span class="line">        socket_select(fd_max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv); <span class="comment">// select处理所有服务连接，默认超时polling_period为100ms</span></span><br><span class="line">        target_call_timer_callbacks(); <span class="comment">// 调试目标计时器回调；会调用keep_alive和server_keep_clients_alive处理各服务的保活逻辑</span></span><br><span class="line">        process_jim_events(command_context); <span class="comment">// jim事件处理函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环遍历所有服务</span></span><br><span class="line">        <span class="keyword">for</span> (service = services; service; service = service-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 若服务连接有数据，则创建连接</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(service-&gt;fd, &amp;read_fds)) &#123;</span><br><span class="line">            add_connection(service, command_context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环遍历服务下所有客户端连接，调用服务输入处理接口</span></span><br><span class="line">            <span class="keyword">for</span> (c = service-&gt;connections; c; ) &#123;</span><br><span class="line">                service-&gt;input(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建连接">创建连接</h4><p>服务创建连接，并将其加入到服务连接队列中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/server/server.c</span><br><span class="line">add_connection</span><br><span class="line">// 创建connection对象</span><br><span class="line">accept(service-&gt;fd, (struct sockaddr *)&amp;service-&gt;sin, &amp;address_size);</span><br><span class="line">service-&gt;new_connection // gdb服务创建连接回调</span><br><span class="line">// connection对象加入到service-&gt;connections尾部</span><br></pre></td></tr></table></figure><p>GDB创建连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/server/gdb_server.c</span><br><span class="line">// service-&gt;new_connection</span><br><span class="line">gdb_service_driver</span><br><span class="line">gdb_new_connection // 初始化gdb连接目标</span><br><span class="line">// 创建gdb连接对象</span><br><span class="line">breakpoint_clear_target(target);</span><br><span class="line">watchpoint_clear_target(target);</span><br><span class="line">target_call_event_callbacks(target, TARGET_EVENT_GDB_ATTACH);</span><br></pre></td></tr></table></figure><h4 id="输入处理">输入处理</h4><p>GDB输入处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// src/server/gdb_server.c</span><br><span class="line">// service-&gt;input</span><br><span class="line">gdb_service_driver</span><br><span class="line">gdb_input // gdb输入处理回调函数，直接调用函数</span><br><span class="line">gdb_input_inner // gdb输入处理函数</span><br><span class="line">gdb_get_packet // 从连接获取协议包</span><br><span class="line">gdb_get_packet_inner // 从连接中读取数据包，若成功则回复ACK（&#x27;+&#x27;）</span><br><span class="line">gdb_get_char // 读取数据包，返回第一个字符</span><br><span class="line">fetch_packet // 解析剩余数据，并计算校验和；当切换到noack模式，则不会校验校验和，并跳过回复ACK（&#x27;+&#x27;）</span><br><span class="line">/* </span><br><span class="line">根据packet[0]第一个字符，执行对应的处理函数</span><br><span class="line">一般小写为读操作函数，大写为写操作函数</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="gdb远程协议">GDB远程协议</h4><p>具体协议需要参考GDB远程协议章节（Appendix E gdb Remote SerialProtocol）。</p><h3 id="连接openocd">连接OpenOCD</h3><p>GDB执行命令连接OpenOCD。执行GDB命令<code>set debug remote 1</code>打开远程调试后，再连接远程目标可以看到通信日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :3333</span><br><span class="line">0x80000004 in ?? ()</span><br></pre></td></tr></table></figure><h4 id="qsupported">qSupported</h4><p>探测OpenOCD支持哪些特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qSupported:multiprocess+;swbreak+;hwbreak+;qRelocInsn+;fork-events+;vfork-events+;exec-events+;vContSupported+;QThreadEvents+;no-resumed+;memory-tagging+;xmlRegisters=i386#77</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: PacketSize=4000;qXfer:memory-map:read-;qXfer:features:read+;qXfer:threads:read+;QStartNoAckMode+;vContSupported+</span><br><span class="line">  [remote] packet_ok: Packet qSupported (supported-packets) is supported</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_query_packet // 处理q/Q消息</span><br><span class="line">xml_printf // xml格式的回复消息</span><br><span class="line">gdb_put_packet // 回复消息</span><br></pre></td></tr></table></figure><h4 id="vmustreplyempty">vMustReplyEmpty</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $vMustReplyEmpty#3a</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: </span><br><span class="line">  </span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_v_packet // 处理v消息</span><br><span class="line">// 无法匹配中任何命令</span><br><span class="line">gdb_put_packet(connection, &quot;&quot;, 0) // 直接回复空消息</span><br></pre></td></tr></table></figure><h4 id="qstartnoackmode">QStartNoAckMode</h4><p>设置不回复ACK模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $QStartNoAckMode#b0</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_query_packet // 处理q/Q消息</span><br><span class="line">gdb_put_packet // 回复OK</span><br></pre></td></tr></table></figure><h4 id="hgxxx">Hgxxx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $Hg0#df</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line">  </span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_thread_packet // 处理H消息</span><br><span class="line">rtos_thread_packet // rtos线程包处理</span><br><span class="line">// 若调试目标存在rtos，则设置当前线程</span><br><span class="line">gdb_put_packet // 回复OK</span><br></pre></td></tr></table></figure><h4 id="qxferfeaturesread">qXfer:features:read</h4><p><code>qXfer:features:read:target.xml:&lt;offset,length&gt;</code>命令分页读取xml格式的架构描述文件，详细信息见riscv描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:0,1000#0c</span><br><span class="line">  [remote] Packet received: m&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE target SYSTEM &quot;gdb-target.dtd&quot;&gt;\n&lt;target version=&quot;1.0&quot;&gt;\n&lt;architecture&gt;riscv:rv32&lt;/architecture&gt;\n&lt;feature name=&quot;org.gnu.gdb.riscv.cpu&quot;&gt;\n&lt;reg name=&quot;zero&quot; bitsize=&quot;32&quot; regnum=&quot;0&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;ra&quot; bitsize=&quot;32&quot; regnum=&quot;1&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;sp&quot; bitsize=&quot;32&quot; regnum=&quot;2&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;gp&quot; bitsize=&quot;32&quot; regnum=&quot;3&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;genera [3585 bytes omitted]</span><br><span class="line">  ...</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:9000,1000#a5</span><br><span class="line">  [remote] Packet received: l type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter27h&quot; bitsize=&quot;32&quot; regnum=&quot;3292&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter28h&quot; bitsize=&quot;32&quot; regnum=&quot;3293&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter29h&quot; bitsize=&quot;32&quot; regnum=&quot;3294&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter30h&quot; bitsize=&quot;32&quot; regnum=&quot;3295&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter31h&quot; bitsize=&quot;32&quot; regnum=&quot;3296&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg  [882 bytes omitted]</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_query_packet // 处理q/Q消息</span><br><span class="line">decode_xfer_read // 解析qXfer命令</span><br><span class="line">gdb_get_target_description_chunk // 架构描述文件分块处理</span><br><span class="line">gdb_generate_target_description // xml格式打印完整的架构描述文件</span><br><span class="line">smp_reg_list_noread // 读取架构完整的寄存器列表</span><br><span class="line">get_reg_features_list // 获取架构寄存器特性列表</span><br><span class="line">xml_printf // 循环打印xml格式的描述文件</span><br><span class="line">gdb_put_packet(connection, xml, strlen(xml)) // 回复架构描述文件xml数据；第一个字符为&#x27;m&#x27;表示后面有分页；第一个字符为&#x27;l&#x27;表示最后一页；</span><br></pre></td></tr></table></figure><h4 id="qtstatus">qTStatus</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qTStatus#49</span><br><span class="line">  [remote] Packet received: </span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_query_packet // 处理q/Q消息</span><br><span class="line">// 无法匹配中任何命令</span><br><span class="line">gdb_put_packet(connection, &quot;&quot;, 0) // 直接回复空消息</span><br></pre></td></tr></table></figure><h4 id="section">?</h4><p>获取进入调试模式的原因对应的信号量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $?#3f</span><br><span class="line">  [remote] Packet received: S00</span><br><span class="line">  </span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_last_signal_packet 处理?消息</span><br><span class="line">gdb_last_signal // 获取上次收到gdb的信号量（根据进入调试模式的原因转换）</span><br><span class="line">gdb_put_packet(connection, sig_reply, 3); // 回复对应的信号量消息</span><br></pre></td></tr></table></figure><h4 id="qxferthreadsread">qXfer:threads:read</h4><p>获取线程列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qXfer:threads:read::0,1000#92</span><br><span class="line">  [remote] Packet received: l&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;threads&gt;\n&lt;/threads&gt;\n</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_query_packet // 处理q/Q消息</span><br><span class="line">decode_xfer_read // 解析qXfer命令</span><br><span class="line">gdb_get_thread_list_chunk // 线程列表线程信息分块处理</span><br><span class="line">gdb_generate_thread_list // xml格式打印完整的线程列表信息</span><br><span class="line">gdb_put_packet(connection, xml, strlen(xml)); // 回复线程列表信息xml数据；第一个字符为&#x27;m&#x27;表示后面有分页；第一个字符为&#x27;l&#x27;表示最后一页；</span><br></pre></td></tr></table></figure><h4 id="hc-xxx">Hc-xxx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $Hc-1#09</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_thread_packet // 处理H消息</span><br><span class="line">rtos_thread_packet // rtos线程包处理</span><br><span class="line">gdb_put_packet // 回复OK</span><br></pre></td></tr></table></figure><h4 id="qc">qC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qC#b4</span><br><span class="line">  [remote] Packet received: QC0</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">rtos_thread_packet // 处理q消息</span><br><span class="line">gdb_put_packet(connection, &quot;QC0&quot;, 3); // 无rtos，直接回复QC0</span><br></pre></td></tr></table></figure><h4 id="qattached">qAttached</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $qAttached#8f</span><br><span class="line">  [remote] Packet received: 1</span><br><span class="line">  [remote] packet_ok: Packet qAttached (query-attached) is supported</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">rtos_thread_packet // 处理q消息</span><br><span class="line">gdb_put_packet(connection, &quot;1&quot;, 1); // 直接回复&quot;1&quot;表示支持</span><br></pre></td></tr></table></figure><h4 id="g">g</h4><p>获取通用寄存器列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $g#67</span><br><span class="line">  [remote] Packet received: 000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000080</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_get_registers_packet // 处理g消息</span><br><span class="line">target_get_gdb_reg_list // 获取特定架构寄存器列表</span><br><span class="line">gdb_get_reg_value_as_str // 循环遍历所有寄存器，将寄存器的值格式化为字符串</span><br><span class="line">gdb_str_to_target // 格式化寄存器的值，每个字节格式化为十六进制2位字符</span><br><span class="line">gdb_put_packet(connection, reg_packet, reg_packet_size); // 返回寄存器值字符化后的数据</span><br></pre></td></tr></table></figure><h4 id="mxxx">mxxx</h4><p><code>m&lt;address&gt;,&lt;length&gt;</code>读取指定地址的内存数据。默认分别读取当前PC和上一次PC对应的指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  [remote] Sending packet: $m80000004,4#59</span><br><span class="line">  [remote] Packet received: 93051005</span><br><span class="line">  [remote] Sending packet: $m80000000,4#55</span><br><span class="line">  [remote] Packet received: 13050005</span><br><span class="line"></span><br><span class="line">// src/server/gdb_server.c</span><br><span class="line">gdb_read_memory_packet // 处理m消息</span><br><span class="line">target_read_buffer // 读取特定架构内存数据</span><br><span class="line">gdb_put_packet // 返回内存数据字符化后的数据</span><br></pre></td></tr></table></figure><h1 id="附件">附件</h1><h2 id="gdb通信日志">GDB通信日志</h2><h3 id="gdb远程连接日志">GDB远程连接日志</h3><p>执行GDB命令<code>set debug remote 1</code>打开远程调试后，再连接远程目标可以看到通信日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :3333</span><br><span class="line">Remote debugging using :3333</span><br><span class="line">[remote] start_remote_1: enter</span><br><span class="line">  [remote] Sending packet: $qSupported:multiprocess+;swbreak+;hwbreak+;qRelocInsn+;fork-events+;vfork-events+;exec-events+;vContSupported+;QThreadEvents+;no-resumed+;memory-tagging+;xmlRegisters=i386#77</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: PacketSize=4000;qXfer:memory-map:read-;qXfer:features:read+;qXfer:threads:read+;QStartNoAckMode+;vContSupported+</span><br><span class="line">  [remote] packet_ok: Packet qSupported (supported-packets) is supported</span><br><span class="line">  [remote] Sending packet: $vMustReplyEmpty#3a</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: </span><br><span class="line">  [remote] Sending packet: $QStartNoAckMode#b0</span><br><span class="line">  [remote] Received Ack</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line">  [remote] Sending packet: $Hg0#df</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:0,1000#0c</span><br><span class="line">  [remote] Packet received: m&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE target SYSTEM &quot;gdb-target.dtd&quot;&gt;\n&lt;target version=&quot;1.0&quot;&gt;\n&lt;architecture&gt;riscv:rv32&lt;/architecture&gt;\n&lt;feature name=&quot;org.gnu.gdb.riscv.cpu&quot;&gt;\n&lt;reg name=&quot;zero&quot; bitsize=&quot;32&quot; regnum=&quot;0&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;ra&quot; bitsize=&quot;32&quot; regnum=&quot;1&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;sp&quot; bitsize=&quot;32&quot; regnum=&quot;2&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;gp&quot; bitsize=&quot;32&quot; regnum=&quot;3&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;genera [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:1000,1000#9d</span><br><span class="line">  [remote] Packet received: m=&quot;sstateen0&quot; bitsize=&quot;32&quot; regnum=&quot;333&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen1&quot; bitsize=&quot;32&quot; regnum=&quot;334&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen2&quot; bitsize=&quot;32&quot; regnum=&quot;335&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen3&quot; bitsize=&quot;32&quot; regnum=&quot;336&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;snxti&quot; bitsize=&quot;32&quot; regnum=&quot;390&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sintstatus&quot; bitsize=&quot;32&quot; regnum=&quot;391&quot; save-restore=&quot;no&quot; ty [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:2000,1000#9e</span><br><span class="line">  [remote] Packet received: mno&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent8&quot; bitsize=&quot;32&quot; regnum=&quot;873&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent9&quot; bitsize=&quot;32&quot; regnum=&quot;874&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent10&quot; bitsize=&quot;32&quot; regnum=&quot;875&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent11&quot; bitsize=&quot;32&quot; regnum=&quot;876&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent12&quot; bitsize=&quot;32&quot; regnum=&quot;877&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmeven [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:3000,1000#9f</span><br><span class="line">  [remote] Packet received: m type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg6&quot; bitsize=&quot;32&quot; regnum=&quot;999&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg7&quot; bitsize=&quot;32&quot; regnum=&quot;1000&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg8&quot; bitsize=&quot;32&quot; regnum=&quot;1001&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg9&quot; bitsize=&quot;32&quot; regnum=&quot;1002&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg10&quot; bitsize=&quot;32&quot; regnum=&quot;1003&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg11&quot; bitsize=&quot;32&quot; r [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:4000,1000#a0</span><br><span class="line">  [remote] Packet received: m&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr35&quot; bitsize=&quot;32&quot; regnum=&quot;1044&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr36&quot; bitsize=&quot;32&quot; regnum=&quot;1045&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr37&quot; bitsize=&quot;32&quot; regnum=&quot;1046&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr38&quot; bitsize=&quot;32&quot; regnum=&quot;1047&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr39&quot; bitsize=&quot;32&quot; regnum=&quot;1048&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg n [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:5000,1000#a1</span><br><span class="line">  [remote] Packet received: m0h&quot; bitsize=&quot;32&quot; regnum=&quot;1629&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen1h&quot; bitsize=&quot;32&quot; regnum=&quot;1630&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen2h&quot; bitsize=&quot;32&quot; regnum=&quot;1631&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen3h&quot; bitsize=&quot;32&quot; regnum=&quot;1632&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;htval&quot; bitsize=&quot;32&quot; regnum=&quot;1668&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hip&quot; bitsize=&quot;32&quot; regnum=&quot;1669&quot; save-restore=&quot;no&quot; type=&quot;int [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:6000,1000#a2</span><br><span class="line">  [remote] Packet received: m&quot; bitsize=&quot;32&quot; regnum=&quot;2020&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;tinfo&quot; bitsize=&quot;32&quot; regnum=&quot;2021&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;tcontrol&quot; bitsize=&quot;32&quot; regnum=&quot;2022&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mcontext&quot; bitsize=&quot;32&quot; regnum=&quot;2025&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mscontext&quot; bitsize=&quot;32&quot; regnum=&quot;2027&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;dcsr&quot; bitsize=&quot;32&quot; regnum=&quot;2033&quot; save-restore=&quot;no&quot; type=&quot;int&quot; grou [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:7000,1000#a3</span><br><span class="line">  [remote] Packet received: m type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter5h&quot; bitsize=&quot;32&quot; regnum=&quot;3014&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter6h&quot; bitsize=&quot;32&quot; regnum=&quot;3015&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter7h&quot; bitsize=&quot;32&quot; regnum=&quot;3016&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter8h&quot; bitsize=&quot;32&quot; regnum=&quot;3017&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter9h&quot; bitsize=&quot;32&quot; regnum=&quot;3018&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg  [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:8000,1000#a4</span><br><span class="line">  [remote] Packet received: mestore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter16&quot; bitsize=&quot;32&quot; regnum=&quot;3153&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter17&quot; bitsize=&quot;32&quot; regnum=&quot;3154&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter18&quot; bitsize=&quot;32&quot; regnum=&quot;3155&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter19&quot; bitsize=&quot;32&quot; regnum=&quot;3156&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter20&quot; bitsize=&quot;32&quot; regnum=&quot;3157&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt; [3585 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qXfer:features:read:target.xml:9000,1000#a5</span><br><span class="line">  [remote] Packet received: l type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter27h&quot; bitsize=&quot;32&quot; regnum=&quot;3292&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter28h&quot; bitsize=&quot;32&quot; regnum=&quot;3293&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter29h&quot; bitsize=&quot;32&quot; regnum=&quot;3294&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter30h&quot; bitsize=&quot;32&quot; regnum=&quot;3295&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter31h&quot; bitsize=&quot;32&quot; regnum=&quot;3296&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg  [882 bytes omitted]</span><br><span class="line">  [remote] Sending packet: $qTStatus#49</span><br><span class="line">  [remote] Packet received: </span><br><span class="line">  [remote] packet_ok: Packet qTStatus (trace-status) is NOT supported</span><br><span class="line">  [remote] Sending packet: $?#3f</span><br><span class="line">  [remote] Packet received: S00</span><br><span class="line">  [remote] Sending packet: $qXfer:threads:read::0,1000#92</span><br><span class="line">  [remote] Packet received: l&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;threads&gt;\n&lt;/threads&gt;\n</span><br><span class="line">  [remote] Sending packet: $Hc-1#09</span><br><span class="line">  [remote] Packet received: OK</span><br><span class="line">  [remote] Sending packet: $qC#b4</span><br><span class="line">  [remote] Packet received: QC0</span><br><span class="line">  [remote] Sending packet: $qAttached#8f</span><br><span class="line">  [remote] Packet received: 1</span><br><span class="line">  [remote] packet_ok: Packet qAttached (query-attached) is supported</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the &quot;file&quot; command.</span><br><span class="line">  [remote] wait: enter</span><br><span class="line">    [remote] select_thread_for_ambiguous_stop_reply: enter</span><br><span class="line">      [remote] select_thread_for_ambiguous_stop_reply: process_wide_stop = 0</span><br><span class="line">      [remote] select_thread_for_ambiguous_stop_reply: first resumed thread is Remote target</span><br><span class="line">      [remote] select_thread_for_ambiguous_stop_reply: is this guess ambiguous? = 0</span><br><span class="line">    [remote] select_thread_for_ambiguous_stop_reply: exit</span><br><span class="line">  [remote] wait: exit</span><br><span class="line">  [remote] Sending packet: $g#67</span><br><span class="line">  [remote] Packet received: 000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000080</span><br><span class="line">  [remote] Sending packet: $qXfer:threads:read::0,1000#92</span><br><span class="line">  [remote] Packet received: l&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;threads&gt;\n&lt;/threads&gt;\n</span><br><span class="line">  [remote] Sending packet: $m80000004,4#59</span><br><span class="line">  [remote] Packet received: 93051005</span><br><span class="line">  [remote] Sending packet: $m80000000,4#55</span><br><span class="line">  [remote] Packet received: 13050005</span><br><span class="line">0x80000000 in ?? ()</span><br><span class="line">[remote] start_remote_1: exit</span><br></pre></td></tr></table></figure><h4 id="section-1"></h4><h2 id="架构描述文件">架构描述文件</h2><h3 id="riscv描述文件">riscv描述文件</h3><p>通信协议日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:0,1000#0c</span><br><span class="line">[remote] Packet received: m&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE target SYSTEM &quot;gdb-target.dtd&quot;&gt;\n&lt;target version=&quot;1.0&quot;&gt;\n&lt;architecture&gt;riscv:rv32&lt;/architecture&gt;\n&lt;feature name=&quot;org.gnu.gdb.riscv.cpu&quot;&gt;\n&lt;reg name=&quot;zero&quot; bitsize=&quot;32&quot; regnum=&quot;0&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;ra&quot; bitsize=&quot;32&quot; regnum=&quot;1&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;sp&quot; bitsize=&quot;32&quot; regnum=&quot;2&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;\n&lt;reg name=&quot;gp&quot; bitsize=&quot;32&quot; regnum=&quot;3&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;genera [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:1000,1000#9d</span><br><span class="line">[remote] Packet received: m=&quot;sstateen0&quot; bitsize=&quot;32&quot; regnum=&quot;333&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen1&quot; bitsize=&quot;32&quot; regnum=&quot;334&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen2&quot; bitsize=&quot;32&quot; regnum=&quot;335&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sstateen3&quot; bitsize=&quot;32&quot; regnum=&quot;336&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;snxti&quot; bitsize=&quot;32&quot; regnum=&quot;390&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;sintstatus&quot; bitsize=&quot;32&quot; regnum=&quot;391&quot; save-restore=&quot;no&quot; ty [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:2000,1000#9e</span><br><span class="line">[remote] Packet received: mno&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent8&quot; bitsize=&quot;32&quot; regnum=&quot;873&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent9&quot; bitsize=&quot;32&quot; regnum=&quot;874&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent10&quot; bitsize=&quot;32&quot; regnum=&quot;875&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent11&quot; bitsize=&quot;32&quot; regnum=&quot;876&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmevent12&quot; bitsize=&quot;32&quot; regnum=&quot;877&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmeven [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:3000,1000#9f</span><br><span class="line">[remote] Packet received: m type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg6&quot; bitsize=&quot;32&quot; regnum=&quot;999&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg7&quot; bitsize=&quot;32&quot; regnum=&quot;1000&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg8&quot; bitsize=&quot;32&quot; regnum=&quot;1001&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg9&quot; bitsize=&quot;32&quot; regnum=&quot;1002&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg10&quot; bitsize=&quot;32&quot; regnum=&quot;1003&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpcfg11&quot; bitsize=&quot;32&quot; r [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:4000,1000#a0</span><br><span class="line">[remote] Packet received: m&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr35&quot; bitsize=&quot;32&quot; regnum=&quot;1044&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr36&quot; bitsize=&quot;32&quot; regnum=&quot;1045&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr37&quot; bitsize=&quot;32&quot; regnum=&quot;1046&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr38&quot; bitsize=&quot;32&quot; regnum=&quot;1047&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;pmpaddr39&quot; bitsize=&quot;32&quot; regnum=&quot;1048&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg n [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:5000,1000#a1</span><br><span class="line">[remote] Packet received: m0h&quot; bitsize=&quot;32&quot; regnum=&quot;1629&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen1h&quot; bitsize=&quot;32&quot; regnum=&quot;1630&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen2h&quot; bitsize=&quot;32&quot; regnum=&quot;1631&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hstateen3h&quot; bitsize=&quot;32&quot; regnum=&quot;1632&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;htval&quot; bitsize=&quot;32&quot; regnum=&quot;1668&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hip&quot; bitsize=&quot;32&quot; regnum=&quot;1669&quot; save-restore=&quot;no&quot; type=&quot;int [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:6000,1000#a2</span><br><span class="line">[remote] Packet received: m&quot; bitsize=&quot;32&quot; regnum=&quot;2020&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;tinfo&quot; bitsize=&quot;32&quot; regnum=&quot;2021&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;tcontrol&quot; bitsize=&quot;32&quot; regnum=&quot;2022&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mcontext&quot; bitsize=&quot;32&quot; regnum=&quot;2025&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mscontext&quot; bitsize=&quot;32&quot; regnum=&quot;2027&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;dcsr&quot; bitsize=&quot;32&quot; regnum=&quot;2033&quot; save-restore=&quot;no&quot; type=&quot;int&quot; grou [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:7000,1000#a3</span><br><span class="line">[remote] Packet received: m type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter5h&quot; bitsize=&quot;32&quot; regnum=&quot;3014&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter6h&quot; bitsize=&quot;32&quot; regnum=&quot;3015&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter7h&quot; bitsize=&quot;32&quot; regnum=&quot;3016&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter8h&quot; bitsize=&quot;32&quot; regnum=&quot;3017&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;mhpmcounter9h&quot; bitsize=&quot;32&quot; regnum=&quot;3018&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg  [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:8000,1000#a4</span><br><span class="line">[remote] Packet received: mestore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter16&quot; bitsize=&quot;32&quot; regnum=&quot;3153&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter17&quot; bitsize=&quot;32&quot; regnum=&quot;3154&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter18&quot; bitsize=&quot;32&quot; regnum=&quot;3155&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter19&quot; bitsize=&quot;32&quot; regnum=&quot;3156&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter20&quot; bitsize=&quot;32&quot; regnum=&quot;3157&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt; [3585 bytes omitted]</span><br><span class="line">[remote] Sending packet: $qXfer:features:read:target.xml:9000,1000#a5</span><br><span class="line">[remote] Packet received: l type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter27h&quot; bitsize=&quot;32&quot; regnum=&quot;3292&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter28h&quot; bitsize=&quot;32&quot; regnum=&quot;3293&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter29h&quot; bitsize=&quot;32&quot; regnum=&quot;3294&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter30h&quot; bitsize=&quot;32&quot; regnum=&quot;3295&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg name=&quot;hpmcounter31h&quot; bitsize=&quot;32&quot; regnum=&quot;3296&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;\n&lt;reg  [882 bytes omitted]</span><br></pre></td></tr></table></figure><p>xml格式描述文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE target SYSTEM &quot;gdb-target.dtd&quot;&gt;</span><br><span class="line">&lt;target version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;architecture&gt;riscv:rv32&lt;/architecture&gt;</span><br><span class="line">  &lt;feature name=&quot;org.gnu.gdb.riscv.cpu&quot;&gt;</span><br><span class="line">    &lt;reg name=&quot;zero&quot; bitsize=&quot;32&quot; regnum=&quot;0&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;ra&quot; bitsize=&quot;32&quot; regnum=&quot;1&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sp&quot; bitsize=&quot;32&quot; regnum=&quot;2&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;gp&quot; bitsize=&quot;32&quot; regnum=&quot;3&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tp&quot; bitsize=&quot;32&quot; regnum=&quot;4&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t0&quot; bitsize=&quot;32&quot; regnum=&quot;5&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t1&quot; bitsize=&quot;32&quot; regnum=&quot;6&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t2&quot; bitsize=&quot;32&quot; regnum=&quot;7&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;fp&quot; bitsize=&quot;32&quot; regnum=&quot;8&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s1&quot; bitsize=&quot;32&quot; regnum=&quot;9&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a0&quot; bitsize=&quot;32&quot; regnum=&quot;10&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a1&quot; bitsize=&quot;32&quot; regnum=&quot;11&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a2&quot; bitsize=&quot;32&quot; regnum=&quot;12&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a3&quot; bitsize=&quot;32&quot; regnum=&quot;13&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a4&quot; bitsize=&quot;32&quot; regnum=&quot;14&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a5&quot; bitsize=&quot;32&quot; regnum=&quot;15&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a6&quot; bitsize=&quot;32&quot; regnum=&quot;16&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;a7&quot; bitsize=&quot;32&quot; regnum=&quot;17&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s2&quot; bitsize=&quot;32&quot; regnum=&quot;18&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s3&quot; bitsize=&quot;32&quot; regnum=&quot;19&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s4&quot; bitsize=&quot;32&quot; regnum=&quot;20&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s5&quot; bitsize=&quot;32&quot; regnum=&quot;21&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s6&quot; bitsize=&quot;32&quot; regnum=&quot;22&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s7&quot; bitsize=&quot;32&quot; regnum=&quot;23&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s8&quot; bitsize=&quot;32&quot; regnum=&quot;24&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s9&quot; bitsize=&quot;32&quot; regnum=&quot;25&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s10&quot; bitsize=&quot;32&quot; regnum=&quot;26&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;s11&quot; bitsize=&quot;32&quot; regnum=&quot;27&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t3&quot; bitsize=&quot;32&quot; regnum=&quot;28&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t4&quot; bitsize=&quot;32&quot; regnum=&quot;29&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t5&quot; bitsize=&quot;32&quot; regnum=&quot;30&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;t6&quot; bitsize=&quot;32&quot; regnum=&quot;31&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pc&quot; bitsize=&quot;32&quot; regnum=&quot;32&quot; save-restore=&quot;yes&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">  &lt;/feature&gt;</span><br><span class="line">  &lt;feature name=&quot;org.gnu.gdb.riscv.csr&quot;&gt;</span><br><span class="line">    &lt;reg name=&quot;utvt&quot; bitsize=&quot;32&quot; regnum=&quot;72&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;seed&quot; bitsize=&quot;32&quot; regnum=&quot;86&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;jvt&quot; bitsize=&quot;32&quot; regnum=&quot;88&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;unxti&quot; bitsize=&quot;32&quot; regnum=&quot;134&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;uintstatus&quot; bitsize=&quot;32&quot; regnum=&quot;135&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;uscratchcsw&quot; bitsize=&quot;32&quot; regnum=&quot;137&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;uscratchcswl&quot; bitsize=&quot;32&quot; regnum=&quot;138&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sedeleg&quot; bitsize=&quot;32&quot; regnum=&quot;323&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sideleg&quot; bitsize=&quot;32&quot; regnum=&quot;324&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;stvt&quot; bitsize=&quot;32&quot; regnum=&quot;328&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;senvcfg&quot; bitsize=&quot;32&quot; regnum=&quot;331&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sstateen0&quot; bitsize=&quot;32&quot; regnum=&quot;333&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sstateen1&quot; bitsize=&quot;32&quot; regnum=&quot;334&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sstateen2&quot; bitsize=&quot;32&quot; regnum=&quot;335&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sstateen3&quot; bitsize=&quot;32&quot; regnum=&quot;336&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;snxti&quot; bitsize=&quot;32&quot; regnum=&quot;390&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sintstatus&quot; bitsize=&quot;32&quot; regnum=&quot;391&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sscratchcsw&quot; bitsize=&quot;32&quot; regnum=&quot;393&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;sscratchcswl&quot; bitsize=&quot;32&quot; regnum=&quot;394&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;stimecmp&quot; bitsize=&quot;32&quot; regnum=&quot;398&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;stimecmph&quot; bitsize=&quot;32&quot; regnum=&quot;414&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsstatus&quot; bitsize=&quot;32&quot; regnum=&quot;577&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsie&quot; bitsize=&quot;32&quot; regnum=&quot;581&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vstvec&quot; bitsize=&quot;32&quot; regnum=&quot;582&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsscratch&quot; bitsize=&quot;32&quot; regnum=&quot;641&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsepc&quot; bitsize=&quot;32&quot; regnum=&quot;642&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vscause&quot; bitsize=&quot;32&quot; regnum=&quot;643&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vstval&quot; bitsize=&quot;32&quot; regnum=&quot;644&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsip&quot; bitsize=&quot;32&quot; regnum=&quot;645&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vstimecmp&quot; bitsize=&quot;32&quot; regnum=&quot;654&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vstimecmph&quot; bitsize=&quot;32&quot; regnum=&quot;670&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;vsatp&quot; bitsize=&quot;32&quot; regnum=&quot;705&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstatus&quot; bitsize=&quot;32&quot; regnum=&quot;833&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;misa&quot; bitsize=&quot;32&quot; regnum=&quot;834&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mie&quot; bitsize=&quot;32&quot; regnum=&quot;837&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtvec&quot; bitsize=&quot;32&quot; regnum=&quot;838&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtvt&quot; bitsize=&quot;32&quot; regnum=&quot;840&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mvien&quot; bitsize=&quot;32&quot; regnum=&quot;841&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mvip&quot; bitsize=&quot;32&quot; regnum=&quot;842&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;menvcfg&quot; bitsize=&quot;32&quot; regnum=&quot;843&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen0&quot; bitsize=&quot;32&quot; regnum=&quot;845&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen1&quot; bitsize=&quot;32&quot; regnum=&quot;846&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen2&quot; bitsize=&quot;32&quot; regnum=&quot;847&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen3&quot; bitsize=&quot;32&quot; regnum=&quot;848&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstatush&quot; bitsize=&quot;32&quot; regnum=&quot;849&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mieh&quot; bitsize=&quot;32&quot; regnum=&quot;853&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;menvcfgh&quot; bitsize=&quot;32&quot; regnum=&quot;859&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen0h&quot; bitsize=&quot;32&quot; regnum=&quot;861&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen1h&quot; bitsize=&quot;32&quot; regnum=&quot;862&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen2h&quot; bitsize=&quot;32&quot; regnum=&quot;863&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mstateen3h&quot; bitsize=&quot;32&quot; regnum=&quot;864&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mcountinhibit&quot; bitsize=&quot;32&quot; regnum=&quot;865&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent3&quot; bitsize=&quot;32&quot; regnum=&quot;868&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent4&quot; bitsize=&quot;32&quot; regnum=&quot;869&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent5&quot; bitsize=&quot;32&quot; regnum=&quot;870&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent6&quot; bitsize=&quot;32&quot; regnum=&quot;871&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent7&quot; bitsize=&quot;32&quot; regnum=&quot;872&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent8&quot; bitsize=&quot;32&quot; regnum=&quot;873&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent9&quot; bitsize=&quot;32&quot; regnum=&quot;874&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent10&quot; bitsize=&quot;32&quot; regnum=&quot;875&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent11&quot; bitsize=&quot;32&quot; regnum=&quot;876&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent12&quot; bitsize=&quot;32&quot; regnum=&quot;877&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent13&quot; bitsize=&quot;32&quot; regnum=&quot;878&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent14&quot; bitsize=&quot;32&quot; regnum=&quot;879&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent15&quot; bitsize=&quot;32&quot; regnum=&quot;880&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent16&quot; bitsize=&quot;32&quot; regnum=&quot;881&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent17&quot; bitsize=&quot;32&quot; regnum=&quot;882&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent18&quot; bitsize=&quot;32&quot; regnum=&quot;883&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent19&quot; bitsize=&quot;32&quot; regnum=&quot;884&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent20&quot; bitsize=&quot;32&quot; regnum=&quot;885&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent21&quot; bitsize=&quot;32&quot; regnum=&quot;886&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent22&quot; bitsize=&quot;32&quot; regnum=&quot;887&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent23&quot; bitsize=&quot;32&quot; regnum=&quot;888&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent24&quot; bitsize=&quot;32&quot; regnum=&quot;889&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent25&quot; bitsize=&quot;32&quot; regnum=&quot;890&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent26&quot; bitsize=&quot;32&quot; regnum=&quot;891&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent27&quot; bitsize=&quot;32&quot; regnum=&quot;892&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent28&quot; bitsize=&quot;32&quot; regnum=&quot;893&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent29&quot; bitsize=&quot;32&quot; regnum=&quot;894&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent30&quot; bitsize=&quot;32&quot; regnum=&quot;895&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent31&quot; bitsize=&quot;32&quot; regnum=&quot;896&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mscratch&quot; bitsize=&quot;32&quot; regnum=&quot;897&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mepc&quot; bitsize=&quot;32&quot; regnum=&quot;898&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mcause&quot; bitsize=&quot;32&quot; regnum=&quot;899&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtval&quot; bitsize=&quot;32&quot; regnum=&quot;900&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mip&quot; bitsize=&quot;32&quot; regnum=&quot;901&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mnxti&quot; bitsize=&quot;32&quot; regnum=&quot;902&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mintstatus&quot; bitsize=&quot;32&quot; regnum=&quot;903&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mscratchcsw&quot; bitsize=&quot;32&quot; regnum=&quot;905&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mscratchcswl&quot; bitsize=&quot;32&quot; regnum=&quot;906&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtinst&quot; bitsize=&quot;32&quot; regnum=&quot;907&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtval2&quot; bitsize=&quot;32&quot; regnum=&quot;908&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;miselect&quot; bitsize=&quot;32&quot; regnum=&quot;913&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mireg&quot; bitsize=&quot;32&quot; regnum=&quot;914&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;miph&quot; bitsize=&quot;32&quot; regnum=&quot;917&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtopei&quot; bitsize=&quot;32&quot; regnum=&quot;925&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg0&quot; bitsize=&quot;32&quot; regnum=&quot;993&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg1&quot; bitsize=&quot;32&quot; regnum=&quot;994&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg2&quot; bitsize=&quot;32&quot; regnum=&quot;995&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg3&quot; bitsize=&quot;32&quot; regnum=&quot;996&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg4&quot; bitsize=&quot;32&quot; regnum=&quot;997&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg5&quot; bitsize=&quot;32&quot; regnum=&quot;998&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg6&quot; bitsize=&quot;32&quot; regnum=&quot;999&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg7&quot; bitsize=&quot;32&quot; regnum=&quot;1000&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg8&quot; bitsize=&quot;32&quot; regnum=&quot;1001&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg9&quot; bitsize=&quot;32&quot; regnum=&quot;1002&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg10&quot; bitsize=&quot;32&quot; regnum=&quot;1003&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg11&quot; bitsize=&quot;32&quot; regnum=&quot;1004&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg12&quot; bitsize=&quot;32&quot; regnum=&quot;1005&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg13&quot; bitsize=&quot;32&quot; regnum=&quot;1006&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg14&quot; bitsize=&quot;32&quot; regnum=&quot;1007&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpcfg15&quot; bitsize=&quot;32&quot; regnum=&quot;1008&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr0&quot; bitsize=&quot;32&quot; regnum=&quot;1009&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr1&quot; bitsize=&quot;32&quot; regnum=&quot;1010&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr2&quot; bitsize=&quot;32&quot; regnum=&quot;1011&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr3&quot; bitsize=&quot;32&quot; regnum=&quot;1012&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr4&quot; bitsize=&quot;32&quot; regnum=&quot;1013&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr5&quot; bitsize=&quot;32&quot; regnum=&quot;1014&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr6&quot; bitsize=&quot;32&quot; regnum=&quot;1015&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr7&quot; bitsize=&quot;32&quot; regnum=&quot;1016&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr8&quot; bitsize=&quot;32&quot; regnum=&quot;1017&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr9&quot; bitsize=&quot;32&quot; regnum=&quot;1018&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr10&quot; bitsize=&quot;32&quot; regnum=&quot;1019&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr11&quot; bitsize=&quot;32&quot; regnum=&quot;1020&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr12&quot; bitsize=&quot;32&quot; regnum=&quot;1021&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr13&quot; bitsize=&quot;32&quot; regnum=&quot;1022&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr14&quot; bitsize=&quot;32&quot; regnum=&quot;1023&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr15&quot; bitsize=&quot;32&quot; regnum=&quot;1024&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr16&quot; bitsize=&quot;32&quot; regnum=&quot;1025&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr17&quot; bitsize=&quot;32&quot; regnum=&quot;1026&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr18&quot; bitsize=&quot;32&quot; regnum=&quot;1027&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr19&quot; bitsize=&quot;32&quot; regnum=&quot;1028&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr20&quot; bitsize=&quot;32&quot; regnum=&quot;1029&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr21&quot; bitsize=&quot;32&quot; regnum=&quot;1030&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr22&quot; bitsize=&quot;32&quot; regnum=&quot;1031&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr23&quot; bitsize=&quot;32&quot; regnum=&quot;1032&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr24&quot; bitsize=&quot;32&quot; regnum=&quot;1033&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr25&quot; bitsize=&quot;32&quot; regnum=&quot;1034&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr26&quot; bitsize=&quot;32&quot; regnum=&quot;1035&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr27&quot; bitsize=&quot;32&quot; regnum=&quot;1036&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr28&quot; bitsize=&quot;32&quot; regnum=&quot;1037&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr29&quot; bitsize=&quot;32&quot; regnum=&quot;1038&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr30&quot; bitsize=&quot;32&quot; regnum=&quot;1039&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr31&quot; bitsize=&quot;32&quot; regnum=&quot;1040&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr32&quot; bitsize=&quot;32&quot; regnum=&quot;1041&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr33&quot; bitsize=&quot;32&quot; regnum=&quot;1042&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr34&quot; bitsize=&quot;32&quot; regnum=&quot;1043&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr35&quot; bitsize=&quot;32&quot; regnum=&quot;1044&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr36&quot; bitsize=&quot;32&quot; regnum=&quot;1045&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr37&quot; bitsize=&quot;32&quot; regnum=&quot;1046&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr38&quot; bitsize=&quot;32&quot; regnum=&quot;1047&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr39&quot; bitsize=&quot;32&quot; regnum=&quot;1048&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr40&quot; bitsize=&quot;32&quot; regnum=&quot;1049&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr41&quot; bitsize=&quot;32&quot; regnum=&quot;1050&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr42&quot; bitsize=&quot;32&quot; regnum=&quot;1051&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr43&quot; bitsize=&quot;32&quot; regnum=&quot;1052&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr44&quot; bitsize=&quot;32&quot; regnum=&quot;1053&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr45&quot; bitsize=&quot;32&quot; regnum=&quot;1054&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr46&quot; bitsize=&quot;32&quot; regnum=&quot;1055&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr47&quot; bitsize=&quot;32&quot; regnum=&quot;1056&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr48&quot; bitsize=&quot;32&quot; regnum=&quot;1057&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr49&quot; bitsize=&quot;32&quot; regnum=&quot;1058&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr50&quot; bitsize=&quot;32&quot; regnum=&quot;1059&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr51&quot; bitsize=&quot;32&quot; regnum=&quot;1060&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr52&quot; bitsize=&quot;32&quot; regnum=&quot;1061&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr53&quot; bitsize=&quot;32&quot; regnum=&quot;1062&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr54&quot; bitsize=&quot;32&quot; regnum=&quot;1063&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr55&quot; bitsize=&quot;32&quot; regnum=&quot;1064&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr56&quot; bitsize=&quot;32&quot; regnum=&quot;1065&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr57&quot; bitsize=&quot;32&quot; regnum=&quot;1066&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr58&quot; bitsize=&quot;32&quot; regnum=&quot;1067&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr59&quot; bitsize=&quot;32&quot; regnum=&quot;1068&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr60&quot; bitsize=&quot;32&quot; regnum=&quot;1069&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr61&quot; bitsize=&quot;32&quot; regnum=&quot;1070&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr62&quot; bitsize=&quot;32&quot; regnum=&quot;1071&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;pmpaddr63&quot; bitsize=&quot;32&quot; regnum=&quot;1072&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;scontext&quot; bitsize=&quot;32&quot; regnum=&quot;1513&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstatus&quot; bitsize=&quot;32&quot; regnum=&quot;1601&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hedeleg&quot; bitsize=&quot;32&quot; regnum=&quot;1603&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hideleg&quot; bitsize=&quot;32&quot; regnum=&quot;1604&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hie&quot; bitsize=&quot;32&quot; regnum=&quot;1605&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;htimedelta&quot; bitsize=&quot;32&quot; regnum=&quot;1606&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hcounteren&quot; bitsize=&quot;32&quot; regnum=&quot;1607&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hgeie&quot; bitsize=&quot;32&quot; regnum=&quot;1608&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;henvcfg&quot; bitsize=&quot;32&quot; regnum=&quot;1611&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen0&quot; bitsize=&quot;32&quot; regnum=&quot;1613&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen1&quot; bitsize=&quot;32&quot; regnum=&quot;1614&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen2&quot; bitsize=&quot;32&quot; regnum=&quot;1615&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen3&quot; bitsize=&quot;32&quot; regnum=&quot;1616&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;htimedeltah&quot; bitsize=&quot;32&quot; regnum=&quot;1622&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;henvcfgh&quot; bitsize=&quot;32&quot; regnum=&quot;1627&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen0h&quot; bitsize=&quot;32&quot; regnum=&quot;1629&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen1h&quot; bitsize=&quot;32&quot; regnum=&quot;1630&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen2h&quot; bitsize=&quot;32&quot; regnum=&quot;1631&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hstateen3h&quot; bitsize=&quot;32&quot; regnum=&quot;1632&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;htval&quot; bitsize=&quot;32&quot; regnum=&quot;1668&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hip&quot; bitsize=&quot;32&quot; regnum=&quot;1669&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hvip&quot; bitsize=&quot;32&quot; regnum=&quot;1670&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;htinst&quot; bitsize=&quot;32&quot; regnum=&quot;1675&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hgatp&quot; bitsize=&quot;32&quot; regnum=&quot;1729&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hcontext&quot; bitsize=&quot;32&quot; regnum=&quot;1769&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent3h&quot; bitsize=&quot;32&quot; regnum=&quot;1892&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent4h&quot; bitsize=&quot;32&quot; regnum=&quot;1893&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent5h&quot; bitsize=&quot;32&quot; regnum=&quot;1894&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent6h&quot; bitsize=&quot;32&quot; regnum=&quot;1895&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent7h&quot; bitsize=&quot;32&quot; regnum=&quot;1896&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent8h&quot; bitsize=&quot;32&quot; regnum=&quot;1897&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent9h&quot; bitsize=&quot;32&quot; regnum=&quot;1898&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent10h&quot; bitsize=&quot;32&quot; regnum=&quot;1899&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent11h&quot; bitsize=&quot;32&quot; regnum=&quot;1900&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent12h&quot; bitsize=&quot;32&quot; regnum=&quot;1901&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent13h&quot; bitsize=&quot;32&quot; regnum=&quot;1902&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent14h&quot; bitsize=&quot;32&quot; regnum=&quot;1903&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent15h&quot; bitsize=&quot;32&quot; regnum=&quot;1904&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent16h&quot; bitsize=&quot;32&quot; regnum=&quot;1905&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent17h&quot; bitsize=&quot;32&quot; regnum=&quot;1906&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent18h&quot; bitsize=&quot;32&quot; regnum=&quot;1907&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent19h&quot; bitsize=&quot;32&quot; regnum=&quot;1908&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent20h&quot; bitsize=&quot;32&quot; regnum=&quot;1909&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent21h&quot; bitsize=&quot;32&quot; regnum=&quot;1910&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent22h&quot; bitsize=&quot;32&quot; regnum=&quot;1911&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent23h&quot; bitsize=&quot;32&quot; regnum=&quot;1912&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent24h&quot; bitsize=&quot;32&quot; regnum=&quot;1913&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent25h&quot; bitsize=&quot;32&quot; regnum=&quot;1914&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent26h&quot; bitsize=&quot;32&quot; regnum=&quot;1915&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent27h&quot; bitsize=&quot;32&quot; regnum=&quot;1916&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent28h&quot; bitsize=&quot;32&quot; regnum=&quot;1917&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent29h&quot; bitsize=&quot;32&quot; regnum=&quot;1918&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent30h&quot; bitsize=&quot;32&quot; regnum=&quot;1919&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmevent31h&quot; bitsize=&quot;32&quot; regnum=&quot;1920&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mseccfg&quot; bitsize=&quot;32&quot; regnum=&quot;1928&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mseccfgh&quot; bitsize=&quot;32&quot; regnum=&quot;1944&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tselect&quot; bitsize=&quot;32&quot; regnum=&quot;2017&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tdata1&quot; bitsize=&quot;32&quot; regnum=&quot;2018&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tdata2&quot; bitsize=&quot;32&quot; regnum=&quot;2019&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tdata3&quot; bitsize=&quot;32&quot; regnum=&quot;2020&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tinfo&quot; bitsize=&quot;32&quot; regnum=&quot;2021&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;tcontrol&quot; bitsize=&quot;32&quot; regnum=&quot;2022&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mcontext&quot; bitsize=&quot;32&quot; regnum=&quot;2025&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mscontext&quot; bitsize=&quot;32&quot; regnum=&quot;2027&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;dcsr&quot; bitsize=&quot;32&quot; regnum=&quot;2033&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;dpc&quot; bitsize=&quot;32&quot; regnum=&quot;2034&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;dscratch0&quot; bitsize=&quot;32&quot; regnum=&quot;2035&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;dscratch1&quot; bitsize=&quot;32&quot; regnum=&quot;2036&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mcycle&quot; bitsize=&quot;32&quot; regnum=&quot;2881&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;minstret&quot; bitsize=&quot;32&quot; regnum=&quot;2883&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter3&quot; bitsize=&quot;32&quot; regnum=&quot;2884&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter4&quot; bitsize=&quot;32&quot; regnum=&quot;2885&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter5&quot; bitsize=&quot;32&quot; regnum=&quot;2886&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter6&quot; bitsize=&quot;32&quot; regnum=&quot;2887&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter7&quot; bitsize=&quot;32&quot; regnum=&quot;2888&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter8&quot; bitsize=&quot;32&quot; regnum=&quot;2889&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter9&quot; bitsize=&quot;32&quot; regnum=&quot;2890&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter10&quot; bitsize=&quot;32&quot; regnum=&quot;2891&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter11&quot; bitsize=&quot;32&quot; regnum=&quot;2892&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter12&quot; bitsize=&quot;32&quot; regnum=&quot;2893&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter13&quot; bitsize=&quot;32&quot; regnum=&quot;2894&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter14&quot; bitsize=&quot;32&quot; regnum=&quot;2895&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter15&quot; bitsize=&quot;32&quot; regnum=&quot;2896&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter16&quot; bitsize=&quot;32&quot; regnum=&quot;2897&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter17&quot; bitsize=&quot;32&quot; regnum=&quot;2898&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter18&quot; bitsize=&quot;32&quot; regnum=&quot;2899&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter19&quot; bitsize=&quot;32&quot; regnum=&quot;2900&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter20&quot; bitsize=&quot;32&quot; regnum=&quot;2901&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter21&quot; bitsize=&quot;32&quot; regnum=&quot;2902&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter22&quot; bitsize=&quot;32&quot; regnum=&quot;2903&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter23&quot; bitsize=&quot;32&quot; regnum=&quot;2904&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter24&quot; bitsize=&quot;32&quot; regnum=&quot;2905&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter25&quot; bitsize=&quot;32&quot; regnum=&quot;2906&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter26&quot; bitsize=&quot;32&quot; regnum=&quot;2907&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter27&quot; bitsize=&quot;32&quot; regnum=&quot;2908&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter28&quot; bitsize=&quot;32&quot; regnum=&quot;2909&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter29&quot; bitsize=&quot;32&quot; regnum=&quot;2910&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter30&quot; bitsize=&quot;32&quot; regnum=&quot;2911&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter31&quot; bitsize=&quot;32&quot; regnum=&quot;2912&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mcycleh&quot; bitsize=&quot;32&quot; regnum=&quot;3009&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;minstreth&quot; bitsize=&quot;32&quot; regnum=&quot;3011&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter3h&quot; bitsize=&quot;32&quot; regnum=&quot;3012&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter4h&quot; bitsize=&quot;32&quot; regnum=&quot;3013&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter5h&quot; bitsize=&quot;32&quot; regnum=&quot;3014&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter6h&quot; bitsize=&quot;32&quot; regnum=&quot;3015&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter7h&quot; bitsize=&quot;32&quot; regnum=&quot;3016&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter8h&quot; bitsize=&quot;32&quot; regnum=&quot;3017&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter9h&quot; bitsize=&quot;32&quot; regnum=&quot;3018&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter10h&quot; bitsize=&quot;32&quot; regnum=&quot;3019&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter11h&quot; bitsize=&quot;32&quot; regnum=&quot;3020&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter12h&quot; bitsize=&quot;32&quot; regnum=&quot;3021&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter13h&quot; bitsize=&quot;32&quot; regnum=&quot;3022&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter14h&quot; bitsize=&quot;32&quot; regnum=&quot;3023&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter15h&quot; bitsize=&quot;32&quot; regnum=&quot;3024&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter16h&quot; bitsize=&quot;32&quot; regnum=&quot;3025&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter17h&quot; bitsize=&quot;32&quot; regnum=&quot;3026&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter18h&quot; bitsize=&quot;32&quot; regnum=&quot;3027&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter19h&quot; bitsize=&quot;32&quot; regnum=&quot;3028&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter20h&quot; bitsize=&quot;32&quot; regnum=&quot;3029&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter21h&quot; bitsize=&quot;32&quot; regnum=&quot;3030&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter22h&quot; bitsize=&quot;32&quot; regnum=&quot;3031&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter23h&quot; bitsize=&quot;32&quot; regnum=&quot;3032&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter24h&quot; bitsize=&quot;32&quot; regnum=&quot;3033&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter25h&quot; bitsize=&quot;32&quot; regnum=&quot;3034&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter26h&quot; bitsize=&quot;32&quot; regnum=&quot;3035&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter27h&quot; bitsize=&quot;32&quot; regnum=&quot;3036&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter28h&quot; bitsize=&quot;32&quot; regnum=&quot;3037&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter29h&quot; bitsize=&quot;32&quot; regnum=&quot;3038&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter30h&quot; bitsize=&quot;32&quot; regnum=&quot;3039&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhpmcounter31h&quot; bitsize=&quot;32&quot; regnum=&quot;3040&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;cycle&quot; bitsize=&quot;32&quot; regnum=&quot;3137&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;time&quot; bitsize=&quot;32&quot; regnum=&quot;3138&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;instret&quot; bitsize=&quot;32&quot; regnum=&quot;3139&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter3&quot; bitsize=&quot;32&quot; regnum=&quot;3140&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter4&quot; bitsize=&quot;32&quot; regnum=&quot;3141&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter5&quot; bitsize=&quot;32&quot; regnum=&quot;3142&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter6&quot; bitsize=&quot;32&quot; regnum=&quot;3143&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter7&quot; bitsize=&quot;32&quot; regnum=&quot;3144&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter8&quot; bitsize=&quot;32&quot; regnum=&quot;3145&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter9&quot; bitsize=&quot;32&quot; regnum=&quot;3146&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter10&quot; bitsize=&quot;32&quot; regnum=&quot;3147&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter11&quot; bitsize=&quot;32&quot; regnum=&quot;3148&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter12&quot; bitsize=&quot;32&quot; regnum=&quot;3149&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter13&quot; bitsize=&quot;32&quot; regnum=&quot;3150&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter14&quot; bitsize=&quot;32&quot; regnum=&quot;3151&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter15&quot; bitsize=&quot;32&quot; regnum=&quot;3152&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter16&quot; bitsize=&quot;32&quot; regnum=&quot;3153&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter17&quot; bitsize=&quot;32&quot; regnum=&quot;3154&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter18&quot; bitsize=&quot;32&quot; regnum=&quot;3155&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter19&quot; bitsize=&quot;32&quot; regnum=&quot;3156&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter20&quot; bitsize=&quot;32&quot; regnum=&quot;3157&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter21&quot; bitsize=&quot;32&quot; regnum=&quot;3158&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter22&quot; bitsize=&quot;32&quot; regnum=&quot;3159&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter23&quot; bitsize=&quot;32&quot; regnum=&quot;3160&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter24&quot; bitsize=&quot;32&quot; regnum=&quot;3161&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter25&quot; bitsize=&quot;32&quot; regnum=&quot;3162&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter26&quot; bitsize=&quot;32&quot; regnum=&quot;3163&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter27&quot; bitsize=&quot;32&quot; regnum=&quot;3164&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter28&quot; bitsize=&quot;32&quot; regnum=&quot;3165&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter29&quot; bitsize=&quot;32&quot; regnum=&quot;3166&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter30&quot; bitsize=&quot;32&quot; regnum=&quot;3167&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter31&quot; bitsize=&quot;32&quot; regnum=&quot;3168&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;cycleh&quot; bitsize=&quot;32&quot; regnum=&quot;3265&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;timeh&quot; bitsize=&quot;32&quot; regnum=&quot;3266&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;instreth&quot; bitsize=&quot;32&quot; regnum=&quot;3267&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter3h&quot; bitsize=&quot;32&quot; regnum=&quot;3268&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter4h&quot; bitsize=&quot;32&quot; regnum=&quot;3269&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter5h&quot; bitsize=&quot;32&quot; regnum=&quot;3270&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter6h&quot; bitsize=&quot;32&quot; regnum=&quot;3271&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter7h&quot; bitsize=&quot;32&quot; regnum=&quot;3272&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter8h&quot; bitsize=&quot;32&quot; regnum=&quot;3273&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter9h&quot; bitsize=&quot;32&quot; regnum=&quot;3274&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter10h&quot; bitsize=&quot;32&quot; regnum=&quot;3275&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter11h&quot; bitsize=&quot;32&quot; regnum=&quot;3276&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter12h&quot; bitsize=&quot;32&quot; regnum=&quot;3277&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter13h&quot; bitsize=&quot;32&quot; regnum=&quot;3278&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter14h&quot; bitsize=&quot;32&quot; regnum=&quot;3279&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter15h&quot; bitsize=&quot;32&quot; regnum=&quot;3280&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter16h&quot; bitsize=&quot;32&quot; regnum=&quot;3281&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter17h&quot; bitsize=&quot;32&quot; regnum=&quot;3282&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter18h&quot; bitsize=&quot;32&quot; regnum=&quot;3283&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter19h&quot; bitsize=&quot;32&quot; regnum=&quot;3284&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter20h&quot; bitsize=&quot;32&quot; regnum=&quot;3285&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter21h&quot; bitsize=&quot;32&quot; regnum=&quot;3286&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter22h&quot; bitsize=&quot;32&quot; regnum=&quot;3287&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter23h&quot; bitsize=&quot;32&quot; regnum=&quot;3288&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter24h&quot; bitsize=&quot;32&quot; regnum=&quot;3289&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter25h&quot; bitsize=&quot;32&quot; regnum=&quot;3290&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter26h&quot; bitsize=&quot;32&quot; regnum=&quot;3291&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter27h&quot; bitsize=&quot;32&quot; regnum=&quot;3292&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter28h&quot; bitsize=&quot;32&quot; regnum=&quot;3293&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter29h&quot; bitsize=&quot;32&quot; regnum=&quot;3294&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter30h&quot; bitsize=&quot;32&quot; regnum=&quot;3295&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hpmcounter31h&quot; bitsize=&quot;32&quot; regnum=&quot;3296&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;scountovf&quot; bitsize=&quot;32&quot; regnum=&quot;3553&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;hgeip&quot; bitsize=&quot;32&quot; regnum=&quot;3667&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mvendorid&quot; bitsize=&quot;32&quot; regnum=&quot;3922&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;marchid&quot; bitsize=&quot;32&quot; regnum=&quot;3923&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mimpid&quot; bitsize=&quot;32&quot; regnum=&quot;3924&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mhartid&quot; bitsize=&quot;32&quot; regnum=&quot;3925&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mconfigptr&quot; bitsize=&quot;32&quot; regnum=&quot;3926&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">    &lt;reg name=&quot;mtopi&quot; bitsize=&quot;32&quot; regnum=&quot;4081&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;csr&quot;/&gt;</span><br><span class="line">  &lt;/feature&gt;</span><br><span class="line">  &lt;feature name=&quot;org.gnu.gdb.riscv.virtual&quot;&gt;</span><br><span class="line">    &lt;reg name=&quot;priv&quot; bitsize=&quot;8&quot; regnum=&quot;4161&quot; save-restore=&quot;no&quot; type=&quot;int&quot; group=&quot;general&quot;/&gt;</span><br><span class="line">  &lt;/feature&gt;</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;基本信息&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/openocd-org/openocd&quot;&gt;OpenOCD&lt;/a&gt;（Open
On-Chip Debugger）&lt;/p&gt;
&lt;p&gt;提供依赖JTAG接口的分层架构的片上编程和调</summary>
      
    
    
    
    <category term="OpenOCD" scheme="https://oz1010.github.com/categories/OpenOCD/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式-ARM处理器使用</title>
    <link href="https://oz1010.github.com/2024/06/12/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://oz1010.github.com/2024/06/12/%E5%B5%8C%E5%85%A5%E5%BC%8F-ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2024-06-12T03:53:31.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注意事项">注意事项</h2><h3 id="指令差异">指令差异</h3><p>ARM处理器具有<code>ARM</code>和<code>Thumb</code>两种指令，相互切换一般采用<code>b</code>类指令进行跳转，否则处理器会返回异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;指令差异&quot;&gt;指令差异&lt;/h3&gt;
&lt;p&gt;ARM处理器具有&lt;code&gt;ARM&lt;/code&gt;和&lt;code&gt;Thumb&lt;/code&gt;两种指令，相互切换一般采用&lt;code&gt;b&lt;/code&gt;类指令进行跳转，否则处理器会返回异常。</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://oz1010.github.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式基础理论</title>
    <link href="https://oz1010.github.com/2024/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <id>https://oz1010.github.com/2024/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</id>
    <published>2024-06-08T04:13:13.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式基础理论">分布式基础理论</h1><h2 id="cap理论基本概念">CAP理论基本概念</h2><ul><li>数据一致性（consistency）：若系统更新操作成功，则它之后的读请求都必须读到这个新数据；若失败，则所有读请求都不能读到这个新数据，对调用者而言数据具有强一致性（strongconsistency）</li><li>服务可用性（availability）：所有请求在一定时间内得到响应，可终止，不会一直等待</li><li>分区容错性（partition-tolerance）：在网络分区的情况下，被分隔的节点仍能正常对外服务</li></ul><h2 id="cap三者不空兼得">CAP三者不空兼得</h2><p>若放弃P，即系统称为传统的单服务器模式；而分布式必然不能放弃P；</p><p>实现P就允许网络存在异常。若实现CP，向一个分区的更新操作因一致性要求，必然导致网络恢复前，其他分区不能满足可用性。若实现AP，存在不同分区因网络异常，无法保证强一致性。</p><p>因此，分布式系统理论上不可能选择CA架构，只能选择CP或AP架构。</p><h2 id="base理论">Base理论</h2><p>CAP理论的一种妥协，由于CAP只能二取一，Base理论降低了发生分区容错时对可用性和一致性的要求。</p><ol type="1"><li>基本可用：允许可用性降低（可能响应延长、可能服务降级）</li><li>软状态：指允许系统中的数据存在中间状态，并任务该中间状态不会影响系统整体可用性（比如支付完成前的支付中）</li><li>最终一致性：节点数据同步可能存在时延，但在一定的期限后必须达成数据的一致，状态变为最终状态</li></ol><h2 id="数据一致性模型">数据一致性模型</h2><p>强一致性：当更新操作完成后，任何多个后续进程的访问都会返回更新后的数据。根据CAP理论，这种实现需要牺牲可用性。</p><p>弱一致性：当更新操作完成后，不承诺立即可以读到更新后的数据，而这段时间存在“不一致性窗口”。</p><p>最终一致性：是弱一致性的特例，强调的是所有的数据副本，在经过一定时间的同步后，最终能够达到一个一致的状态。达到最终一致性的时间，就是不一致窗口时间。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p><p>最终一致性模型根据其提供的不同保证可以划分为因果一致性和会话一致性等等模型。</p><p>因果一致性：要求有因果关系的操作顺序要得到保证，非因果关系的操作顺序则无所谓。</p><p>会话一致性：将对系统数据的访问过程框定在了一个会话当中，约定了系统保证在同一个有效的会话中实现“读己之所写”的一致性。</p><h2 id="quorumwaro机制">Quorum、WARO机制</h2><p>WARO：一种简单的副本控制协议，写操作时，只有当所有副本都成功更新之后，这次写操作才算成功，否则视为失败。优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性。但只要有一个节点存活，任然能够提供读服务。</p><p>选举算法Quorum机制：如，10个副本，一次成功更新了三个，那么需要读取八个副本的数据，可以保证读到最新数据。无法保证强一致性，也就是无法实现任何时刻或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号的metadata服务，这样可以确定最新成功提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式基础理论&quot;&gt;分布式基础理论&lt;/h1&gt;
&lt;h2 id=&quot;cap理论基本概念&quot;&gt;CAP理论基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据一致性（consistency）：若系统更新操作成功，则它之后的读请求都必须读到这个新数据；若失败，则所有读请求都不能读到这个新数</summary>
      
    
    
    
    <category term="分布式" scheme="https://oz1010.github.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式Linux驱动开发笔记</title>
    <link href="https://oz1010.github.com/2024/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://oz1010.github.com/2024/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-24T01:48:01.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟vexpress-a9">模拟vexpress-a9</h1><p>使用QEMU模拟vexpress-a9开发板，网络上教程比较多，可以快速搭建好开发环境。</p><h2 id="基本环境">基本环境</h2><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>项目</th><th>信息</th></tr></thead><tbody><tr class="odd"><td>操作系统</td><td>Ubuntu 22.04</td></tr><tr class="even"><td>内核</td><td><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.334.tar.xz">linux-4.14.334</a></td></tr><tr class="odd"><td>根文件系统</td><td><a href="https://busybox.net/downloads/busybox-1.36.1.tar.bz2">busybox-1.36.1</a></td></tr><tr class="even"><td>引导程序</td><td><a href="https://ftp.denx.de/pub/u-boot/u-boot-2022.10-rc5.tar.bz2">u-boot-2022.10-rc5</a></td></tr></tbody></table><h2 id="安装依赖">安装依赖</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y make gcc bc libncurses5-dev bison flex libssl-dev u-boot-tools gcc-arm-linux-gnueabi g++-arm-linux-gnueabi qemu-system-arm</span><br></pre></td></tr></table></figure><h2 id="linux内核">Linux内核</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用vexpress默认配置编译</span></span><br><span class="line"><span class="built_in">cd</span> linux-4.14.334</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span><br><span class="line"><span class="comment"># 开启NFS4支持。</span></span><br><span class="line"><span class="comment"># 位置：File System -&gt; Network File Systems-&gt;NFS client support for NFS version 4 （相关的四项全勾上）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译内核</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- zImage -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- LOADADDR=0x60003000 uImage -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- dtbs -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动模拟器</span></span><br><span class="line">qemu-system-arm -M vexpress-a9 -m 128M -kernel linux-4.14.334/arch/arm/boot/zImage -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic -append <span class="string">&quot;console=ttyAMA0&quot;</span></span><br><span class="line"><span class="comment"># 这里注意文件的路径，是在linux-4.14.334源码目录执行的。</span></span><br><span class="line"><span class="comment"># -M vexpress-a9 模拟vexpress-a9单板，你能够使用-M ?參数来获取该qemu版本号支持的全部单板</span></span><br><span class="line"><span class="comment"># -m 128M 单板执行物理内存128M</span></span><br><span class="line"><span class="comment"># -kernel xx/zImage 告诉qemu单板执行内核镜像路径</span></span><br><span class="line"><span class="comment"># -dtb xx/vexpress-v2p-ca9.dtb  告诉qemu单板的设备树（必须加入）</span></span><br><span class="line"><span class="comment"># -nographic 不使用图形化界面，仅仅使用串口</span></span><br><span class="line"><span class="comment"># -append &quot;console=ttyAMA0&quot; 内核启动參数。这里告诉内核vexpress单板执行。串口设备是哪个tty。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提示没有根文件系统，接下来制作它。</p><h2 id="根文件系统">根文件系统</h2><h3 id="配置编译">配置编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.36.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- clean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig</span><br><span class="line"><span class="comment"># 配置页面选择</span></span><br><span class="line"><span class="comment"># Settings-&gt;Build Options-&gt;Build static binary</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># 默认安装在_install路径中</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h3 id="补充根文件系统">补充根文件系统</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝基本文件系统</span></span><br><span class="line"><span class="built_in">mkdir</span> rootfs-arm32</span><br><span class="line"><span class="built_in">cd</span> rootfs-arm32</span><br><span class="line"><span class="built_in">cp</span> -rfd ../busybox-1.36.1/_install/* .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建设备节点</span></span><br><span class="line"><span class="built_in">mkdir</span> dev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/tty1 c 4 1</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/tty2 c 4 2</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/tty3 c 4 3</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/tty4 c 4 4</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/console c 5 1</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> -m 666 dev/null c 1 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装动态链接库</span></span><br><span class="line"><span class="built_in">mkdir</span> lib</span><br><span class="line"><span class="built_in">cp</span> -d /usr/arm-linux-gnueabi/lib/*.so* ./lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置初始化进程rcS</span></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> 777 etc/init.d/rcS</span><br><span class="line"><span class="built_in">cat</span> &gt; etc/init.d/rcS &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string">PATH=/bin:/sbin:/usr/bin:/usr/sbin</span></span><br><span class="line"><span class="string">export LD_LIBRARY_PATH=/lib:/usr/lib</span></span><br><span class="line"><span class="string">/bin/mount -n -t ramfs ramfs /var</span></span><br><span class="line"><span class="string">/bin/mount -n -t ramfs ramfs /tmp</span></span><br><span class="line"><span class="string">/bin/mount -n -t sysfs none /sys</span></span><br><span class="line"><span class="string">/bin/mount -n -t ramfs none /dev</span></span><br><span class="line"><span class="string">/bin/mkdir /var/tmp</span></span><br><span class="line"><span class="string">/bin/mkdir /var/modules</span></span><br><span class="line"><span class="string">/bin/mkdir /var/run</span></span><br><span class="line"><span class="string">/bin/mkdir /var/log</span></span><br><span class="line"><span class="string">/bin/mkdir -p /dev/pts</span></span><br><span class="line"><span class="string">/bin/mkdir -p /dev/shm</span></span><br><span class="line"><span class="string">/sbin/mdev -s</span></span><br><span class="line"><span class="string">/bin/mount -a</span></span><br><span class="line"><span class="string">echo &quot;-----------------------------------&quot;</span></span><br><span class="line"><span class="string">echo &quot;*****welcome to vexpress board*****&quot;</span></span><br><span class="line"><span class="string">echo &quot;-----------------------------------&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件系统fstab</span></span><br><span class="line"><span class="built_in">cat</span> &gt; etc/fstab &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">proc    /proc           proc    defaults        0       0</span></span><br><span class="line"><span class="string">none    /dev/pts        devpts  mode=0622       0       0</span></span><br><span class="line"><span class="string">mdev    /dev            ramfs   defaults        0       0</span></span><br><span class="line"><span class="string">sysfs   /sys            sysfs   defaults        0       0</span></span><br><span class="line"><span class="string">tmpfs   /dev/shm        tmpfs   defaults        0       0</span></span><br><span class="line"><span class="string">tmpfs   /dev            tmpfs   defaults        0       0</span></span><br><span class="line"><span class="string">tmpfs   /mnt            tmpfs   defaults        0       0</span></span><br><span class="line"><span class="string">var     /dev            tmpfs   defaults        0       0</span></span><br><span class="line"><span class="string">ramfs   /dev            ramfs   defaults        0       0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置初始化脚本</span></span><br><span class="line"><span class="built_in">cat</span> &gt; etc/inittab &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">::sysinit:/etc/init.d/rcS </span></span><br><span class="line"><span class="string">::askfirst:-/bin/sh</span></span><br><span class="line"><span class="string">::restart:/sbin/init </span></span><br><span class="line"><span class="string">::ctrlaltdel:/sbin/reboot</span></span><br><span class="line"><span class="string">::shutdown:/bin/umount -a -r</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量，&#x27;EOF&#x27;可以防止内容被解析</span></span><br><span class="line"><span class="built_in">cat</span> &gt; etc/profile &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/sh </span></span><br><span class="line">USER=<span class="string">&quot;root&quot;</span></span><br><span class="line">LOGNAME=<span class="variable">$USER</span></span><br><span class="line"><span class="comment"># export HOSTNAME=vexpress-a9</span></span><br><span class="line"><span class="built_in">export</span> HOSTNAME=`<span class="built_in">cat</span> /etc/sysconfig/HOSTNAME`</span><br><span class="line"><span class="built_in">export</span> USER=root</span><br><span class="line"><span class="built_in">export</span> HOME=root</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;[<span class="variable">$USER</span>@<span class="variable">$HOSTNAME</span>:\w]\#&quot;</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin </span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加主机名</span></span><br><span class="line"><span class="built_in">mkdir</span> etc/sysconfig</span><br><span class="line"><span class="built_in">cat</span> &gt; etc/sysconfig/HOSTNAME &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">vexpress-a9</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建其他文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> mnt proc root sys tmp var</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>接下来需要制作根文件系统，有两种方式</p><h3 id="方式一模拟sd卡方式启动">方式一：模拟SD卡方式启动</h3><p>这种方式非常简单，但不适合需要经常修改文件系统中的文件的场景</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建SD卡根文件系统镜像</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /mnt/rootfs</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 /mnt/rootfs</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs-arm32.ext3 bs=1M count=64</span><br><span class="line">mkfs.ext3 rootfs-arm32.ext3</span><br><span class="line"><span class="built_in">sudo</span> mount -t ext3 rootfs-arm32.ext3 /mnt/rootfs -o loop</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -rf rootfs-arm32/* /mnt/rootfs/</span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/rootfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动模拟器</span></span><br><span class="line">qemu-system-arm -M vexpress-a9 \</span><br><span class="line">        -m 512M \</span><br><span class="line">        -kernel linux-4.14.334/arch/arm/boot/zImage \</span><br><span class="line">        -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class="line">        -nographic \</span><br><span class="line">        -append <span class="string">&quot;root=/dev/mmcblk0 rw console=ttyAMA0&quot;</span> \</span><br><span class="line">    -sd rootfs-arm32.ext3</span><br></pre></td></tr></table></figure><h3 id="方式二通过nfs挂载根文件系统">方式二：通过NFS挂载根文件系统</h3><p>首先，宿主机需要安装配置nfs</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置nfs</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /sync/rootfs</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 -R /home/johnny/project/ldd4/rootfs-arm32</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> &gt;&gt;/etc/exports &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">/home/johnny/project/ldd4/rootfs-arm32 *(rw,sync,no_root_squash,no_subtree_check)</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 为解决Linux内核与NFS服务器的兼容问题</span></span><br><span class="line"><span class="comment"># 设置Ubuntu20.04的NFS，使之兼容NFS-V2和NFS-V3并增加调试功能。</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/\(^RPCSVCGSSDOPTS=&quot;\).*/\1--nfs-version 2,3,4 --debug --syslog&quot;/g&#x27;</span> /etc/default/nfs-kernel-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nfs服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart rpcbind</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nfs-kernel-server</span><br></pre></td></tr></table></figure><p>配置主机网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y uml-utilities bridge-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置网桥</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/network/interfaces &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">auto lo</span></span><br><span class="line"><span class="string">iface lo inet loopback</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">auto eth0</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">auto br0</span></span><br><span class="line"><span class="string">iface br0 inet dhcp</span></span><br><span class="line"><span class="string">bridge_ports eth0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建tap0网卡，用于连接qemu虚拟开发板</span></span><br><span class="line"><span class="built_in">sudo</span> tunctl -u root -t tap0</span><br><span class="line"><span class="built_in">sudo</span> ifconfig tap0 172.16.16.10 promisc up</span><br></pre></td></tr></table></figure><p>启动模拟器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> qemu-system-arm \</span><br><span class="line">        -M vexpress-a9 \</span><br><span class="line">        -m 512M \</span><br><span class="line">        -kernel linux-4.14.334/arch/arm/boot/zImage \</span><br><span class="line">        -dtb linux-4.14.334/arch/arm/boot/dts/vexpress-v2p-ca9.dtb \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no,<span class="built_in">id</span>=net0 \</span><br><span class="line">    -net nic,macaddr=00:16:3e:00:00:01 \ </span><br><span class="line">        -nographic \</span><br><span class="line">        -append <span class="string">&quot;root=/dev/nfs rw nfsroot=172.16.16.10:/home/johnny/project/ldd4/rootfs-arm32,proto=tcp,nfsvers=3,nolock init=/linuxrc console=ttyAMA0 ip=172.16.16.20&quot;</span></span><br></pre></td></tr></table></figure><h1 id="ask-qemu">100ask-qemu</h1><p>目前只支持ubuntu 16.04和18.04，需要拥有桌面环境。</p><p>已经支持模拟网卡、LCD显示、LED灯、按键、AT24CXX I2C存储芯片的功能</p><p>具体参考<a href="http://wiki.100ask.org/Qemu">百问网嵌入式Linux</a></p><h1 id="linux驱动开发">Linux驱动开发</h1><p>与通用主机的差异是使用的内核与交叉编译工具不一样，详见Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>,arm)</span><br><span class="line">KERNELDIR ?= /home/johnny/project/ldd4/linux-4.14.334</span><br><span class="line">OBJECTDIR ?= /home/johnny/project/ldd4/objects/vexpress-v2p-ca9</span><br><span class="line">ROOTFS ?= /home/johnny/project/ldd4/rootfs-arm32</span><br><span class="line">CROSS_COMPILE ?= arm-linux-gnueabi-</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> O=<span class="variable">$(OBJECTDIR)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="section">modules_install:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> O=<span class="variable">$(OBJECTDIR)</span> modules INSTALL_MOD_PATH=<span class="variable">$(ROOTFS)</span> modules_install</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf  *.o  *.ko  .*.cmd  *.mod*  modules.order  Module.symvers   .tmp_versions</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">obj-m += globalfifo.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模拟vexpress-a9&quot;&gt;模拟vexpress-a9&lt;/h1&gt;
&lt;p&gt;使用QEMU模拟vexpress-a9开发板，网络上教程比较多，可以快速搭建好开发环境。&lt;/p&gt;
&lt;h2 id=&quot;基本环境&quot;&gt;基本环境&lt;/h2&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;co</summary>
      
    
    
    
    <category term="Linux" scheme="https://oz1010.github.com/categories/Linux/"/>
    
    <category term="Driver" scheme="https://oz1010.github.com/categories/Linux/Driver/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux驱动开发笔记</title>
    <link href="https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://oz1010.github.com/2024/04/24/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-24T01:47:35.000Z</published>
    <updated>2026-01-21T06:34:01.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建">环境搭建</h1><p>Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令<code>uname -r</code>。</p><p>对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交叉编译工具变量<code>CROSS_COMPILE</code>为指定的工具。</p><p>对于通用内核来说，可以使用包管理工具直接下载内核，例如在Ubuntu系统中使用命令<code>sudo apt-get install -y linux-headers-$(uname -r)</code>。默认内核安装路径在<code>/lib/modules/$(uname -r)</code>。编译驱动时，需要将内核路径指定到<code>/lib/modules/$(uname -r)/build</code>。对应的头文件在路径<code>/usr/src/linux-headers-$(uname -r)/include</code>中。</p><p>对于wsl来说，与通用内核类似，只是内核需要单独从<a href="https://github.com/microsoft/WSL2-Linux-Kernel/releases">微软wsl2内核仓库</a>下载。然后手动进行编译安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装编译wsl特供内核依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y libelf-dev build-essential pkg-config bison build-essential flex libssl-dev libelf-dev bc dwarves</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压进入到目录</span></span><br><span class="line">tar -xvf WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> WSL2-Linux-Kernel-linux-msft-wsl-5.15.90.1</span><br><span class="line"><span class="built_in">cp</span> Microsoft/config-wsl .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">sudo</span> make scripts</span><br><span class="line"><span class="built_in">sudo</span> make modules -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make modules_install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h1 id="驱动简介">驱动简介</h1><p>Linux驱动可以使用多种方式加载到系统中。</p><h2 id="基本框架">基本框架</h2><p><code>hello.c</code>文件的内容如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">// 包含内核编程最常用的函数声明，如printk</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">// 包含模块编程相关的宏定义，如：MODULE_LICENSE</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init初始化函数在模块被插入进内核时调用，主要作用为驱动功能做好预备工作被称为模块的入口函数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">__init的作用 : </span></span><br><span class="line"><span class="comment">  1. 一个宏，展开后为：__attribute__ ((__section__ (&quot;.init.text&quot;))) 实际是gcc的一个特殊链接标记</span></span><br><span class="line"><span class="comment">  2. 指示链接器将该函数放置在 .init.text区段</span></span><br><span class="line"><span class="comment">  3. 在模块插入时方便内核从ko文件指定位置读取入口函数的指令到特定内存位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体初始化逻辑</span></span><br><span class="line">    printk(<span class="string">&quot;hello module init.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">module_init 宏</span></span><br><span class="line"><span class="comment">1. 用法：module_init(模块入口函数名) </span></span><br><span class="line"><span class="comment">2. 动态加载模块，对应函数被调用</span></span><br><span class="line"><span class="comment">3. 静态加载模块，内核启动过程中对应函数被调用</span></span><br><span class="line"><span class="comment">4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.initcall段），方便系统初始化统一调用。</span></span><br><span class="line"><span class="comment">5. 对于动态加载的模块，由于内核模块的默认入口函数名是init_module,用该宏可以给对应模块入口函数起别名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exit退出函数在模块从内核中被移除时调用，主要作用做些init函数的反操作被称为模块的出口函数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">__exit的作用：</span></span><br><span class="line"><span class="comment">  1. 一个宏，展开后为：__attribute__ ((__section__ (&quot;.exit.text&quot;))) 实际也是gcc的一个特殊链接标记</span></span><br><span class="line"><span class="comment">  2. 指示链接器将该函数放置在 .exit.text区段</span></span><br><span class="line"><span class="comment">  3. 在模块插入时方便内核从ko文件指定位置读取出口函数的指令到另一个特定内存位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体反初始化逻辑</span></span><br><span class="line">    printk(<span class="string">&quot;hello module exit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">module_exit宏</span></span><br><span class="line"><span class="comment">  1. 用法：module_exit(模块出口函数名)</span></span><br><span class="line"><span class="comment">  2. 动态加载的模块在卸载时，对应函数被调用</span></span><br><span class="line"><span class="comment">  3. 静态加载的模块可以认为在系统退出时，对应函数被调用，实际上对应函数被忽略</span></span><br><span class="line"><span class="comment">  4. 对于静态加载的模块其本质是定义一个全局函数指针，并将其赋值为指定函数，链接时将地址放到特殊区段（.exitcall段），方便系统必要时统一调用，实际上该宏在静态加载时没有意义，因为静态编译的驱动无法卸载。</span></span><br><span class="line"><span class="comment">  5. 对于动态加载的模块，由于内核模块的默认出口函数名是cleanup_module,用该宏可以给对应模块出口函数起别名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MODULE_LICENSE(字符串常量);</span></span><br><span class="line"><span class="comment">字符串常量内容为源码的许可证协议 可以是&quot;GPL&quot; &quot;GPL v2&quot;  &quot;GPL and additional rights&quot;  &quot;Dual BSD/GPL&quot;  &quot;Dual MIT/GPL&quot; &quot;Dual MPL/GPL&quot;等, &quot;GPL&quot;最常用</span></span><br><span class="line"><span class="comment">其本质也是一个宏，宏体也是一个特殊链接标记，指示链接器在ko文件指定位置说明本模块源码遵循的许可证</span></span><br><span class="line"><span class="comment">在模块插入到内核时，内核会检查新模块的许可证是不是也遵循GPL协议，如果发现不遵循GPL，则在插入模块时打印抱怨信息：</span></span><br><span class="line"><span class="comment">myhello：module license &#x27;unspecified&#x27; taints kernel</span></span><br><span class="line"><span class="comment">Disabling lock debugging due to kernel taint</span></span><br><span class="line"><span class="comment">也会导致新模块没法使用一些内核其它模块提供的高级功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Makefile</code>文件的内容如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>,arm)</span><br><span class="line">KERNELDIR ?= /root/ldd4/linux-4.14.334</span><br><span class="line"><span class="comment"># OBJECTDIR ?= /root/ldd4/objects/vexpress-v2p-ca9</span></span><br><span class="line">ROOTFS ?= /root/ldd4/rootfs-arm32</span><br><span class="line">CROSS_COMPILE ?= arm-linux-gnueabi-</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> O=<span class="variable">$(OBJECTDIR)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="section">modules_install:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> O=<span class="variable">$(OBJECTDIR)</span> modules INSTALL_MOD_PATH=<span class="variable">$(ROOTFS)</span> modules_install</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf  *.o  *.ko  .*.cmd  *.mod*  modules.order  Module.symvers   .tmp_versions</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>驱动编译成功后，使用附录中的常用命令进行测试。</p><h1 id="字符设备驱动">字符设备驱动</h1><p>Linux字符设备会涉及到关键数据结构<code>cdev</code>及<code>file_operations</code>结构体的操作方法。</p><p><code>cdev</code>定义在文件<code>include/linux/cdev.h</code>中，主要描述设备驱动基本信息。</p><p><code>file_operations</code>定义在文件<code>include/linux/fs.h</code>中，主要描述设备驱动提供的基本接口函数，比如open、read、write、llseek、unlocked_ioctl等基本操作函数。</p><h2 id="关键函数">关键函数</h2><p>初始化基本流程为：注册设备号-&gt;申请驱动内存-&gt;初始化与新增字符设备描述符</p><p>注销基本流程为：删除字符设备描述符-&gt;释放驱动内存-&gt;删除设备号</p><h3 id="设备号">设备号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">dev_t</span>;</span><br><span class="line"><span class="comment">// 生成设备号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,minor) (((ma) &lt;&lt; 20) | (mi))</span></span><br><span class="line"><span class="comment">// 获取主设备号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="comment">// 获取次设备号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)((unsigned int) ((dev) &amp; MINORMASK))</span></span><br></pre></td></tr></table></figure><p><code>dev_t</code>为设备编号类型，为32位无符号整数。</p><ul><li>ma为主设备号major</li><li>mi为次设备号minor</li></ul><p>在创建设备节点时，通过设备号来绑定驱动模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态注册设备号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> dev, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 动态申请设备号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> minor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 注销设备号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li>dev为设备编号，动态申请时通过指针传值方式返回</li><li>minor为需要分配的起始次设备号</li><li>count为需要分配的设备数量，主设备号一样，次设备号依次累加</li><li>name为设备驱动名称，可以在<code>/proc/devices</code>中查看</li></ul><h3 id="驱动内存">驱动内存</h3><p>值得注意的是，设备驱动运行在内核空间，因此内存需要使用内核内存管理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存并置零。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="comment">// 内存释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span></span><br></pre></td></tr></table></figure><ul><li>size申请内存大小</li><li>flags内存标志位，这里使用GFP_KERNEL</li><li>p内存指针指向待释放的内存</li></ul><h3 id="字符设备">字符设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化字符设备描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *ops)</span>;</span><br><span class="line"><span class="comment">// 新增字符设备描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span>;</span><br><span class="line"><span class="comment">// 删除字符设备描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *cdev)</span>;</span><br></pre></td></tr></table></figure><ul><li>cdev字符设备描述符</li><li>ops文件操作描述符</li><li>dev设备编号</li></ul><h3 id="其他宏">其他宏</h3><table><thead><tr class="header"><th>名称</th><th>作用</th><th>必选</th></tr></thead><tbody><tr class="odd"><td>module_init</td><td>导出设备驱动的初始化函数</td><td>✅</td></tr><tr class="even"><td>module_exit</td><td>导出设备驱动的退出函数</td><td>✅</td></tr><tr class="odd"><td>module_param</td><td>导出设备驱动参数</td><td>❌</td></tr><tr class="even"><td>MODULE_LICENSE</td><td>声明许可信息</td><td>✅</td></tr><tr class="odd"><td>MODULE_AUTHOR</td><td>声明作者信息</td><td>❌</td></tr><tr class="even"><td>MODULE_DESCRIPTION</td><td>声明描述信息</td><td>❌</td></tr></tbody></table><h2 id="简单的模拟缓存设备">简单的模拟缓存设备</h2><p>支持最多创建10个设备节点，每个节点可以读取或写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAJOR 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为避免多个设备命令污染，Linux推荐使用_IO _IOR _IOW _IOWR来定义ioctl的命令</span></span><br><span class="line"><span class="comment">// 已经定义的设备类型可以见内核文档Documentation/ioctl/ioctl-number.txt</span></span><br><span class="line"><span class="comment">// 内核预定义的控制命令不会被设备驱动处理，这些定义在include/uapi/asm-generic/ioctls.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAGIC <span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR _IO(GLOBALMEM_MAGIC, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class="line">module_param(globalmem_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">dev_t</span> id;</span><br><span class="line">    <span class="comment">// 字符设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cd</span>;</span></span><br><span class="line">    <span class="comment">// 模拟的设备内存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[GLOBALMEM_SIZE];</span><br><span class="line">&#125; <span class="type">globalmem_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">globalmem_dev_t</span> *globalmem_devp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的打开函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">globalmem_dev_t</span> *dev = container_of(inode-&gt;i_cdev, <span class="type">globalmem_dev_t</span>, cd);</span><br><span class="line">    filp-&gt;private_data = dev;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的释放函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的I/O控制函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">globalmem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">globalmem_dev_t</span> *dev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">        <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;globalmem is set to zero\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的读操作。*ppos是要读的位置相对于内存开头的偏移，如果大于或等于GLOBALMEM_SIZE，则会返回0（EOF）</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> p = *ppos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = size;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">globalmem_dev_t</span> *dev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">        count = GLOBALMEM_SIZE - p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, dev-&gt;mem + p, count))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;read %u bytes(s) from %lu\n&quot;</span>, count, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 驱动设备的写操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> p = *ppos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = size;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">globalmem_dev_t</span> *dev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt; GLOBALMEM_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">        count = GLOBALMEM_SIZE - p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(dev-&gt;mem + p, buf, count))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;written %u bytes(s) from %lu\n&quot;</span>, count, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的定位操作。</span></span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">globalmem_llseek_impl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> orig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">loff_t</span> f_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (orig)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* 从内存当前位置开始seek */</span></span><br><span class="line">        f_pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 从内存开头位置seek */</span></span><br><span class="line">        <span class="keyword">if</span> ((f_pos + offset) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((f_pos + offset) &gt; GLOBALMEM_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filp-&gt;f_pos = f_pos;</span><br><span class="line">        ret = filp-&gt;f_pos;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalmem_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .llseek = globalmem_llseek_impl,</span><br><span class="line">    .read = globalmem_read,</span><br><span class="line">    .write = globalmem_write,</span><br><span class="line">    .unlocked_ioctl = globalmem_ioctl,</span><br><span class="line">    .open = globalmem_open,</span><br><span class="line">    .release = globalmem_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cdev的初始化和添加</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">globalmem_setup_cdev</span><span class="params">(<span class="type">globalmem_dev_t</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    cdev_init(&amp;dev-&gt;cd, &amp;globalmem_fops);</span><br><span class="line">    dev-&gt;cd.owner = THIS_MODULE;</span><br><span class="line">    err = cdev_add(&amp;dev-&gt;cd, dev-&gt;id, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;Error %d adding globalmem&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">globalmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备号的申请</span></span><br><span class="line">    <span class="type">dev_t</span> id = MKDEV(globalmem_major, GLOBALMEM_MINOR);</span><br><span class="line">    <span class="keyword">if</span> (globalmem_major)</span><br><span class="line">        <span class="comment">// 1. 静态申请设备号</span></span><br><span class="line">        ret = register_chrdev_region(id, DEVICE_NUM, <span class="string">&quot;globalmemND&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 动态申请设备号</span></span><br><span class="line">        ret = alloc_chrdev_region(&amp;id, <span class="number">0</span>, DEVICE_NUM, <span class="string">&quot;globalmemND&quot;</span>);</span><br><span class="line">        globalmem_major = MAJOR(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内核中申请一份globalmem_dev的内存并清零</span></span><br><span class="line">    globalmem_devp = kzalloc(<span class="keyword">sizeof</span>(<span class="type">globalmem_dev_t</span>) * DEVICE_NUM, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!globalmem_devp)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> fail_malloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        (globalmem_devp + i)-&gt;id = MKDEV(globalmem_major, i);</span><br><span class="line">        globalmem_setup_cdev(globalmem_devp + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_malloc:</span><br><span class="line">    unregister_chrdev_region(id, DEVICE_NUM);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出设备驱动的初始化函数</span></span><br><span class="line">module_init(globalmem_init);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备驱动的退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">globalmem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEVICE_NUM; ++i)</span><br><span class="line">        cdev_del(&amp;(globalmem_devp + i)-&gt;cd);</span><br><span class="line">    kfree(globalmem_devp);</span><br><span class="line">    unregister_chrdev_region(globalmem_devp-&gt;id, DEVICE_NUM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出设备驱动的退出函数</span></span><br><span class="line">module_exit(globalmem_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者版权声明</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;johnny &lt;johnny@gmail.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="阻塞和非阻塞">阻塞和非阻塞</h1><h1 id="异步通知和异步io">异步通知和异步I/O</h1><h2 id="异步通知">异步通知</h2><p>异步通知使用Linux信号机制。</p><p>设备驱动中使用异步通知，主要用到一个数据结构和两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步通知数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span>;</span></span><br><span class="line"><span class="comment">// 处理标志变更</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> mode, <span class="keyword">struct</span> fasync_struct **fa)</span>;</span><br><span class="line"><span class="comment">// 释放信号函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fa, <span class="type">int</span> sig, <span class="type">int</span> band)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异步io">异步I/O</h2><p>Linux内核AIO。</p><p>AIO无法解决系统调用问题，已经被摒弃，使用<code>io_uring</code>替代AIO机制。<a href="https://zhuanlan.zhihu.com/p/583298936">一文图解原理｜Linux I/O神器之 io_uring</a></p><h1 id="中断与时钟">中断与时钟</h1><p>Linux将中断处理程序分解为两个半部：顶半部（Top Half）和底半部（BottomHalf）。</p><p>ARMLinux默认情况下，中断都是在CPU0上产生的，需要通过接口<code>irq_set_affinity</code>把中断irq设定到CPUi上去。</p><p>顶半部用于完成尽量少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态，并在清除中断标志后就进行“登记中断”的工作。</p><p>中断处理工作的重心就落在了底半部的头上，需用它来完成中断事件的绝大多数任务。</p><h2 id="关键函数-1">关键函数</h2><h3 id="顶半部">顶半部</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">irqreturn_t</span>;</span><br><span class="line"><span class="comment">// 申请irq</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br><span class="line"><span class="comment">// 申请irq。区别是devm_开头的API申请的是内核“managed”的资源，一般不需要在出错处理和remove（）接口里再显式的释放。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"><span class="comment">// 释放irq</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev_id)</span>;</span><br><span class="line"><span class="comment">// 屏蔽使能中断源</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">int</span> irq)</span>;</span><br></pre></td></tr></table></figure><p>中断共享需要在申请时，增加IRQF_SHARED标志。</p><h3 id="底半部">底半部</h3><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断和线程化irq。</p><h2 id="内核定时器">内核定时器</h2><h3 id="定时器">定时器</h3><p>timer_list</p><h3 id="工作队列">工作队列</h3><h2 id="内核延时">内核延时</h2><h3 id="短延时">短延时</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忙等待</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">msleep_interruptible</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ssleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 睡着延时</span></span><br><span class="line">schedule_timeout</span><br></pre></td></tr></table></figure><h1 id="内存与io访问">内存与I/O访问</h1><p>x86处理器中存在I/O空间的概念，而大多数嵌入式微处理器中并不提供I/O空间。</p><h2 id="linux内存管理">Linux内存管理</h2><p>在Linux系统中，进程的4GB内存空间被分为两个部分——用户空间与内核空间。用户空间的地址一般分布为0<sub>3GB（即PAGE_OFFSET，在0x86中它等于0xC0000000），而3</sub>4GB为内核空间。用户进程通常只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。用户进程只能通过系统调用等方式才可以访问到内核空间。</p><p>内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域。</p><p>对于x86系统而言，一般情况下，物理内存映射区最大长度为896MB。当系统物理内存大于896MB时，超过物理内存映射区的那部分内存称为高端内存。</p><p>内核空间最顶部FIXADDR_TOP~4GB的区域作为保留区。</p><p>紧接着最顶端的保留区以下的一段区域为专用页面映射区（FIXADDR_START~FIXADDR_TOP）。</p><p>virt_to_phys（）和phys_to_virt（）方法仅适用于DMA和常规区域，高端内存的虚拟地址与物理地址之间不存在如此简单的换算关系。</p><h2 id="内存存取">内存存取</h2><h3 id="用户空间动态申请">用户空间动态申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span></span><br><span class="line"><span class="built_in">free</span></span><br></pre></td></tr></table></figure><h3 id="内核空间动态申请">内核空间动态申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖底层__get_free_pages（）来实现，分配标志的前缀GFP正好是这个底层函数的缩写。</span></span><br><span class="line"><span class="comment">// 最常用的分配标志是GFP_KERNEL，其含义是在内核空间的进程中申请内存。</span></span><br><span class="line"><span class="comment">// 使用GFP_KERNEL标志申请内存时，若暂时不能满足，则进程会睡眠等待页，即会引起阻塞，因此不能在中断上下文或持有自旋锁的时候使用GFP_KERNE申请内存。</span></span><br><span class="line"><span class="comment">// 使用GFP_ATOMIC标志申请内存时，若不存在空闲页，则不等待，直接返回。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br><span class="line">kfree</span><br><span class="line"><span class="comment">// 一般只为存在于软件中（没有对应的硬件意义）的较大的顺序缓冲区分配内存</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">void</span> * addr)</span>;</span><br></pre></td></tr></table></figure><p>slab缓存</p><p>完全使用页为单元申请和释放内存容易导致浪费（如果要申请少量字节，也需要用1页）；另一方面，在操作系统的运作过程中，经常会涉及大量对象的重复生成、使用和释放内存问题。如果我们能够用合适的方法使得对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，就可以大大提高效率。slab算法就是针对上述特点设计的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建slab缓存</span></span><br><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> size,<span class="type">size_t</span> align, <span class="type">unsigned</span> <span class="type">long</span> flags,<span class="type">void</span> (*ctor)(<span class="type">void</span>*, <span class="keyword">struct</span> kmem_cache *, <span class="type">unsigned</span> <span class="type">long</span>),<span class="type">void</span> (*dtor)(<span class="type">void</span>*, <span class="keyword">struct</span> kmem_cache *, <span class="type">unsigned</span> <span class="type">long</span>))</span>;</span><br><span class="line"><span class="comment">// 分配和释放slab缓存</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp)</span>;</span><br><span class="line"><span class="comment">// 回收slab缓存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>;</span><br></pre></td></tr></table></figure><p>内存池</p><p>内存池技术也是一种非常经典的用于分配大量小对象的后备缓存技术。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建内存池</span></span><br><span class="line"><span class="type">mempool_t</span> *<span class="title function_">mempool_create</span><span class="params">(<span class="type">int</span> min_nr, <span class="type">mempool_alloc_t</span> *alloc_fn,<span class="type">mempool_free_t</span> *free_fn, <span class="type">void</span> *pool_data)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(<span class="type">mempool_alloc_t</span>)(<span class="type">int</span> gfp_mask, <span class="type">void</span> *pool_data); <span class="comment">// 标准对象分配的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(<span class="type">mempool_free_t</span>)</span><span class="params">(<span class="type">void</span> *element, <span class="type">void</span> *pool_data)</span>; <span class="comment">// 标准对象回收的函数指针</span></span><br><span class="line"><span class="comment">// 内存池中分配和回收对象</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mempool_alloc</span><span class="params">(<span class="type">mempool_t</span> *pool, <span class="type">int</span> gfp_mask)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mempool_free</span><span class="params">(<span class="type">void</span> *element, <span class="type">mempool_t</span> *pool)</span>;</span><br><span class="line"><span class="comment">// 回收内存池</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mempool_destroy</span><span class="params">(<span class="type">mempool_t</span> *pool)</span>;</span><br></pre></td></tr></table></figure><h2 id="io端口和io内存">I/O端口和I/O内存</h2><p>当位于I/O空间时，通常被称为I/O端口；当位于内存空间时，对应的内存空间被称为I/O内存。</p><h3 id="io端口访问">I/O端口访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写字节端口（8位宽）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">inb</span><span class="params">(<span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte, <span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="comment">// 读写字端口（16位宽）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">inw</span><span class="params">(<span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> word, <span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="comment">// 读写长字端口（32位宽）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">inl</span><span class="params">(<span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl</span><span class="params">(<span class="type">unsigned</span> longword, <span class="type">unsigned</span> port)</span>;</span><br><span class="line"><span class="comment">// 读写一串字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insb</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsb</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="comment">// 读写一串字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insw</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsw</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="comment">// 读写一串长字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insl</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsl</span><span class="params">(<span class="type">unsigned</span> port, <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure><h3 id="io内存访问">I/O内存访问</h3><p>在内核中访问I/O内存（通常是芯片内部的各个I2C、SPI、USB等控制器的寄存器或者外部内存总线上的设备）之前，需首先使用ioremap（）函数将设备所处的物理地址映射到虚拟地址上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个特殊的虚拟地址，该地址可用来存取特定的物理地址范围，这个虚拟地址位于vmalloc映射区域。</span></span><br><span class="line"><span class="comment">// 通过devm_ioremap进行的映射通常不需要在驱动退出和出错处理的时候进行iounmap</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ioremap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> __iomem *<span class="title function_">devm_ioremap</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">resource_size_t</span> offset,<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="comment">// 释放ioremap映射的地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span><span class="params">(<span class="type">void</span> * addr)</span>;</span><br></pre></td></tr></table></figure><p>是Linux内核推荐用一组标准的API来完成设备内存映射的虚拟地址的读写。</p><p>没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是前者包含一个内存屏障。</p><p>以下分别是读写8bit、16bit、32bit的寄存器的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readb(c) (&#123; u8 __v = readb_relaxed(c); __iormb(); __v; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readw(c) (&#123; u16__v = readw_relaxed(c); __iormb(); __v; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readl(c) (&#123; u32 __v = readl_relaxed(c); __iormb(); __v; &#125;)</span></span><br><span class="line"><span class="comment">// 写寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writeb(v,c) (&#123; __iowmb(); writeb_relaxed(v,c); &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writew(v,c) (&#123; __iowmb(); writew_relaxed(v,c); &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writel(v,c) (&#123; __iowmb(); writel_relaxed(v,c); &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="申请释放io端口和io内存">申请释放I/O端口和I/O内存</h3><p>Linux内核提供了一组函数以申请和释放I/O端口，表明该驱动要访问这片区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请I/O端口</span></span><br><span class="line"><span class="comment">// 变体devm_request_region</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> first, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 归还I/O端口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure><p>Linux内核也提供了一组函数以申请和释放I/O内存的范围。此处的“申请”表明该驱动要访问这片区域，它不会做任何内存映射的动作，更多的是类似于“reservation”的概念。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请I/O内存</span></span><br><span class="line"><span class="comment">// 变体devm_request_mem_region</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">request_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 归还I/O内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_mem_region</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> len)</span>;</span><br></pre></td></tr></table></figure><h3 id="io端口和io内存访问流程">I/O端口和I/O内存访问流程</h3><p>I/O端口访问的一种途径是直接使用I/O端口操作函数：在设备打开或驱动模块被加载时申请I/O端口区域，之后使用inb（）、outb（）等进行端口访问，最后，在设备关闭或驱动被卸载时释放I/O端口范围。</p><p>I/O内存的访问步骤，首先是调用request_mem_region（）申请资源，接着将寄存器地址通过ioremap（）映射到内核空间虚拟地址，之后就可以通过Linux设备访问编程接口访问这些设备的寄存器了。访问完成后，应对ioremap（）申请的虚拟地址进行释放，并释放release_mem_region（）申请的I/O内存资源。</p><h3 id="设备地址映射到用户空间">设备地址映射到用户空间</h3><p>一般情况下，用户空间是不可能也不应该直接访问设备的，但是，设备驱动程序中可实现mmap（）函数，这个函数可使得用户空间能直接访问设备的物理地址。</p><p>mmap（）必须以PAGE_SIZE为单位进行映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动中mmap原型</span></span><br><span class="line"><span class="type">int</span>(*mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct*);</span><br></pre></td></tr></table></figure><p><code>vm_operations_struct</code>结构体的实体会在<code>file_operations</code>的mmap（）成员函数里被赋值给相应的<code>vma-&gt;vm_ops</code>。一般open（）函数也通常在mmap（）里调用，close（）函数会在用户调用munmap（）的时候被调用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建页表项</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>I/O内存被映射时需要是nocache的，这时候，我们应该对vma-&gt;vm_page_prot设置nocache标志之后再映射。</p><p>当访问的页不在内存里，即发生缺页异常时，fault（）会被内核自动调用，而fault（）的具体行为可以自定义。</p><h2 id="io内存静态映射">I/O内存静态映射</h2><p>在将Linux移植到目标电路板的过程中，有得会建立外设I/O内存物理地址到虚拟地址的静态映射，这个映射通过在与电路板对应的map_desc结构体数组中添加新的成员来完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virtual; <span class="comment">/* 虚拟地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pfn;     <span class="comment">/* __phys_to_pfn(phy_addr) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;  <span class="comment">/* 大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;     <span class="comment">/* 类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 然后通过函数iotable_init(struct map_desc&amp;, size_t)建立映射。</span></span><br></pre></td></tr></table></figure><p>驱动工程师可以对非常规内存区域的I/O内存（外设控制器寄存器、MCU内部集成的外设控制器寄存器等）依照电路板的资源使用情况添加到map_desc数组中，但是目前该方法已经不值得推荐。</p><h2 id="dma">DMA</h2><p>DMA是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。</p><p>DMA方式的数据传输由DMA控制器（DMAC）控制，在传输期间，CPU可以并发地执行其他任务。当DMA结束后，DMAC通过中断通知CPU数据传输已经结束，然后由CPU执行相应的中断服务程序进行后处理。</p><h3 id="dma与cache一致性">DMA与Cache一致性</h3><p>如果DMA的目的地址与Cache所缓存的内存地址访问有重叠，经过DMA操作，与Cache缓存对应的内存中的数据已经被修改，而CPU本身并不知道，它仍然认为Cache中的数据就是内存中的数据。这样就会发生Cache与内存之间数据“不一致性”的错误。</p><p>Cache的不一致性问题并不是只发生在DMA的情况下，实际上，它还存在于Cache使能和关闭的时刻。</p><h3 id="linux下的dma编程">Linux下的DMA编程</h3><p>申请DMA缓冲区时应使用GFP_DMA标志，这样能保证获得的内存位于DMA区域中，并具备DMA能力。</p><p>在内核中定义了__get_free_pages（）针对DMA的“快捷方式”__get_dma_pages（），它在申请标志中添加了GFP_DMA。</p><p>如果不想使用log2size（即order）为参数申请DMA内存，则可以使用另一个函数dma_mem_alloc（）。</p><p>内核提供了如下函数以进行简单的虚拟地址/总线地址转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">virt_to_bus</span><span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> *address)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">bus_to_virt</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure><p>在使用IOMMU或反弹缓冲区的情况下，上述函数一般不会正常工作。而且，这两个函数并不建议使用。</p><p>设备并不一定能在所有的内存地址上执行DMA操作，在这种情况下应该通过下列函数执行DMA地址掩码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dma_set_mask</span><span class="params">(<span class="keyword">struct</span> device *dev, u64 mask)</span>;</span><br></pre></td></tr></table></figure><p>内核中提供了如下函数以分配一个DMA一致性的内存区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请Cache一致的DMA缓冲区</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *handle,<span class="type">gfp_t</span> gfp)</span>;</span><br><span class="line"><span class="comment">// 释放Cache一致的DMA缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr,<span class="type">dma_addr_t</span> handle)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请写合并的DMA缓冲区</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">dma_alloc_writecombine</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span>*handle, <span class="type">gfp_t</span> gfp)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dma_free_writecombine(dev,size,cpu_addr,handle) \</span></span><br><span class="line"><span class="meta">    dma_free_coherent(dev,size,cpu_addr,handle)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PCI设备申请DMA缓冲区</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">pci_alloc_consistent</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_addrp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_free_consistent</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr,<span class="type">dma_addr_t</span> dma_addr)</span>;</span><br></pre></td></tr></table></figure><p>缓冲区来自内核的较上层（如网卡驱动中的网络报文、块设备驱动中要写入设备的数据等），上层很可能用普通的kmalloc（）、__get_free_pages（）等方法申请，这时候就要使用流式DMA映射。</p><p>对于单个已经分配的缓冲区而言，使用dma_map_single（）可实现流式DMA映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DMA映射。第4个参数为DMA的方向，可能的值包括DMA_TO_DEVICE、DMA_FROM_DEVICE、DMA_BIDIRECTIONAL和DMA_NONE</span></span><br><span class="line"><span class="type">dma_addr_t</span> <span class="title function_">dma_map_single</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *buffer, <span class="type">size_t</span> size,<span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"><span class="comment">// DMA反映射</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_unmap_single</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_addr_t</span> dma_addr, <span class="type">size_t</span> size,<span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得DMA缓冲区的拥有权</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_single_for_cpu</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_handle_t</span> bus_addr,<span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"><span class="comment">// 将其所有权返还给设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_single_for_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">dma_handle_t</span> bus_addr,<span class="type">size_t</span> size, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射SG</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dma_map_sg</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg, <span class="type">int</span> nents,<span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"><span class="comment">// 去除映射SG</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_unmap_sg</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *<span class="built_in">list</span>,<span class="type">int</span> nents, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"><span class="comment">// 返回scatterlist对应的缓冲区的总线地址和缓冲区的长度</span></span><br><span class="line"><span class="type">dma_addr_t</span> <span class="title function_">sg_dma_address</span><span class="params">(<span class="keyword">struct</span> scatterlist *sg)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sg_dma_len</span><span class="params">(<span class="keyword">struct</span> scatterlist *sg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得DMA缓冲区的拥有权</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_sg_for_cpu</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg,<span class="type">int</span> nents, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br><span class="line"><span class="comment">// 将其所有权返还给设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_sync_sg_for_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg,<span class="type">int</span> nents, <span class="keyword">enum</span> dma_data_direction direction)</span>;</span><br></pre></td></tr></table></figure><p>Linux内核目前推荐使用dmaengine的驱动架构来编写DMA控制器的驱动，同时外设的驱动使用标准的dmaengineAPI进行DMA的准备、发起和完成时的回调工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请DMA通道</span></span><br><span class="line"><span class="keyword">struct</span> dma_chan *<span class="title function_">dma_request_slave_channel</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_chan</span> *__<span class="title">dma_request_channel</span>(<span class="title">const</span> <span class="title">dma_cap_mask_t</span> *<span class="title">mask</span>,<span class="title">dma_filter_fn</span> <span class="title">fn</span>, <span class="title">void</span> *<span class="title">fn_param</span>);</span></span><br><span class="line"><span class="comment">// 释放DMA通道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma_release_channel</span><span class="params">(<span class="keyword">struct</span> dma_chan *chan)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMA完成回调函数原型：void (dma_fini_callback)(void*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请DMA描述符，然后填充callback和callback_param参数</span></span><br><span class="line">dmaengine_prep_slave_single</span><br><span class="line"><span class="comment">// 把描述符插入队列</span></span><br><span class="line">dmaengine_submit</span><br><span class="line"><span class="comment">// 发起DMA动作</span></span><br><span class="line">dma_async_issue_pending</span><br></pre></td></tr></table></figure><h1 id="linux设备驱动的软件架构思想">Linux设备驱动的软件架构思想</h1><p>让驱动以某种标准方法拿到这些平台信息呢Linux总线、设备和驱动模型实际上可以做到这一点，驱动只管驱动，设备只管设备，总线则负责匹配设备和驱动，而驱动则以标准途径拿到板级信息。</p><p>一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附于PCI、USB、I2C、SPI等的设备而言，这自然不是问题。在SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设等却不依附于此类总线。Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform_device，而驱动成为platform_driver。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">devicedev</span>;</span></span><br><span class="line">    u32 num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device * <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mod_name; <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> suppress_bind_attrs; <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与platform_driver地位对等的i2c_driver、spi_driver、usb_driver、pci_driver中都包含了device_driver结构体实例成员。它其实描述了各种xxx_driver（xxx是总线名）在驱动意义上的一些共性。</p><p>资源本身由resource结构体描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">resource__size_t</span> start;</span><br><span class="line">    <span class="type">resource_size_t</span> end;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// 值可以为IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORE-SOURCE_DMA等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中通过platform_get_resource（）这样的API来获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取资源通用接口</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>,<span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">// 获取IRQ资源封装接口，相当于platform_get_resource(dev, IORESOURCE_IRQ, num);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure><p>platform也提供了platform_data的支持，platform_data的形式是由每个驱动自定义的</p><h3 id="将globalfifo作为platform设备">将globalfifo作为platform设备</h3><p>globalfifo驱动挂接到platform总线上，这要完成两个工作：</p><ul><li>将globalfifo移植为platform驱动</li><li>在板文件中添加globalfifo这个platform设备</li></ul><p>移植时需要屏蔽module_init和module_exit宏定义的入口。</p><p>为了完成在板文件中添加globalfifo这个platform设备的工作，需要在板文件<code>arch/arm/mach-&lt;soc名&gt;/mach-&lt;板名&gt;.c</code>中添加相应的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">globalfifo_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;globalfifo&quot;</span>,</span><br><span class="line">    .id = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="设备驱动分层思想">设备驱动分层思想</h2><p>非常推荐使用misc类型设备驱动框架，编写字符类设备。</p><p>可以额外编写驱动触发设备驱动<code>xxx_probe</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">globalfifodev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    globalfifo_pdev = platform_device_alloc(<span class="string">&quot;globalfifo&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!globalfifo_pdev)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    ret = platform_device_add(globalfifo_pdev);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        platform_device_put(globalfifo_pdev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalfifodev_init);</span><br></pre></td></tr></table></figure><h1 id="linux块设备驱动">Linux块设备驱动</h1><p>块设备是与字符设备并列的概念，这两类设备在Linux中的驱动结构有较大差异，总体而言，块设备驱动比字符设备驱动要复杂得多。缓冲、I/O调度、请求队列等都是与块设备驱动相关的概念。</p><h2 id="linux块设备驱动结构">Linux块设备驱动结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块设备操作描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 打开和释放</span></span><br><span class="line">    <span class="type">int</span> (*open)(<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I/O控制</span></span><br><span class="line">    <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*compat_ioctl)(<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 介质改变，以后会被check_events取代</span></span><br><span class="line">    <span class="type">int</span> (*media_changed)(<span class="keyword">struct</span> gendisk *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使介质有效</span></span><br><span class="line">    <span class="type">int</span> (*revalidate_disk)(<span class="keyword">struct</span> gendisk *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取驱动器信息</span></span><br><span class="line">    <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块指针，通常指向THIS_MODULE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    <span class="type">int</span> (*rw_page)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="keyword">struct</span> page *, <span class="type">int</span> rw);</span><br><span class="line">    <span class="type">int</span> (*direct_access)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="type">void</span> **, <span class="type">unsigned</span> <span class="type">long</span> *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span><span class="params">(<span class="keyword">struct</span> gendisk *disk, <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line">    <span class="type">void</span> (*unlock_native_capacity)(<span class="keyword">struct</span> gendisk *);</span><br><span class="line">    <span class="type">void</span> (*swap_slot_free_notify)(<span class="keyword">struct</span> block_device *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="gendisk">gendisk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 磁盘描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// major、first_minor和minors共同表征了磁盘的主、次设备号，同一个磁盘的各个分区共享一个主设备号，而次设备号则不同</span></span><br><span class="line">    <span class="type">int</span> major;</span><br><span class="line">    <span class="type">int</span> first_minor;</span><br><span class="line">    <span class="type">int</span> minors;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述的块设备操作集合</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="comment">// 管理这个设备的I/O请求队列的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="comment">// 指向磁盘的任何私有数据，与字符设备驱动的private_data类似</span></span><br><span class="line">    <span class="type">void</span> *private_data;</span><br><span class="line">    <span class="comment">// 表示一个分区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line">    <span class="comment">// 容纳分区表。与part0的关系：disk-&gt;part_tbl-&gt;part[0] = &amp;disk-&gt;part0;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line">    <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">umode_t</span> *mode);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> events;       <span class="comment">/* supported events */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> async_events; <span class="comment">/* async events, subset of all */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">driverfs_dev</span>;</span> <span class="comment">// <span class="doctag">FIXME:</span> remove</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span> sync_io; <span class="comment">/* RAID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_integrity</span> *<span class="title">integrity</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配gendisk</span></span><br><span class="line"><span class="keyword">struct</span> gendisk *<span class="title function_">alloc_disk</span><span class="params">(<span class="type">int</span> minors)</span>;</span><br><span class="line"><span class="comment">// 增加gendisk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span>;</span><br><span class="line"><span class="comment">// 释放gendisk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_gendisk</span><span class="params">(<span class="keyword">struct</span> gendisk *gp)</span>;</span><br><span class="line"><span class="comment">// gendisk引用计数</span></span><br><span class="line"><span class="keyword">struct</span> kobject *<span class="title function_">get_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span>;</span><br></pre></td></tr></table></figure><h3 id="biorequest和request_queue">bio、request和request_queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sector_t</span> bi_sector;   <span class="comment">/* device address in 512byte sectors */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bi_size; <span class="comment">/* residual I/O count */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bi_idx; <span class="comment">/* current index into bvl_vec */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bi_bvec_done; <span class="comment">/* number of bytes completed in current bvec */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bi_next</span>;</span> <span class="comment">/* request queue link */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_flags; <span class="comment">/* status, command, etc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bi_rw;    <span class="comment">/* bottom bits READ/WRITE,</span></span><br><span class="line"><span class="comment">                             * top bits priority</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> <span class="title">bi_iter</span>;</span></span><br><span class="line">    <span class="comment">/* Number of segments in this BIO after</span></span><br><span class="line"><span class="comment">     * physical address coalescing is performed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bi_phys_segments;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* the actual vec list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span> *<span class="title">bi_pool</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can inline a number of vecs at the end of the bio, to avoid</span></span><br><span class="line"><span class="comment">     * double allocations for a small number of bio_vecs. This member</span></span><br><span class="line"><span class="comment">     * MUST obviously be kept at the very end of the bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与bio对应的数据每次存放的内存不一定是连续的，因此需要一个向量。向量中的每个元素实际是一个[page，offset，len]，我们一般也称它为一个片段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I/O调度算法可将连续的bio合并成一个请求。请求是bio经由I/O调度进行调整后的结果，这是请求和bio的区别。</p><p>每个块设备或者块设备的分区都对应有自身的request_queue，从I/O调度器合并和排序出来的请求会被分发（Dispatch）到设备级的request_queue。</p><p>主要API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化请求队列</span></span><br><span class="line"><span class="type">request_queue_t</span> *<span class="title function_">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="type">spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="comment">// 清除请求队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_cleanup_queue</span><span class="params">(<span class="type">request_queue_t</span> * q)</span>;</span><br><span class="line"><span class="comment">// 分配请求队列</span></span><br><span class="line"><span class="type">request_queue_t</span> *<span class="title function_">blk_alloc_queue</span><span class="params">(<span class="type">int</span> gfp_mask)</span>;</span><br><span class="line"><span class="comment">// 对于RAMDISK这种完全随机访问的非机械设备，并不需要进行复杂的I/O调度。</span></span><br><span class="line"><span class="comment">// 使用如下函数来绑定请求队列和“制造请求”函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_make_request</span><span class="params">(<span class="type">request_queue_t</span> * q, make_request_fn * mfn)</span>;</span><br><span class="line"><span class="comment">// 提取请求</span></span><br><span class="line"><span class="keyword">struct</span> request * <span class="title function_">blk_peek_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span>;</span><br><span class="line"><span class="comment">// 启动请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_start_request</span><span class="params">(<span class="keyword">struct</span> request *req)</span>;</span><br><span class="line"><span class="comment">// 报告完成</span></span><br><span class="line"><span class="type">void</span> __blk_end_request_all(<span class="keyword">struct</span> request *rq, <span class="type">int</span> error);</span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_end_request_all</span><span class="params">(<span class="keyword">struct</span> request *rq, <span class="type">int</span> error)</span>;</span><br><span class="line"><span class="comment">// 用blk_queue_make_request（）绕开I/O调度，但是在bio处理完成后应该使用bio_endio</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bio_endio</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">int</span> error)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是I/O操作故障，可以调用快捷函数bio_io_error（）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bio_io_error(bio) bio_endio((bio), -EIO)</span></span><br><span class="line"><span class="comment">// 遍历一个请求的所有bio</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rq_for_each_bio(_bio, rq) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((rq-&gt;bio))                  \</span></span><br><span class="line"><span class="meta">        for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)</span></span><br><span class="line"><span class="comment">// 遍历一个bio的所有bio_vec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bio_for_each_segment(bvl, bio, iter, start) \</span></span><br><span class="line"><span class="meta">    for (iter = (start);                              \</span></span><br><span class="line"><span class="meta">         (iter).bi_size &amp;&amp;                            \</span></span><br><span class="line"><span class="meta">         ((bvl = bio_iter_iovec((bio), (iter))), 1);  \</span></span><br><span class="line"><span class="meta">         bio_advance_iter((bio), &amp;(iter), (bvl).bv_len))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bio_for_each_segment(bvl, bio, iter) \</span></span><br><span class="line"><span class="meta">    __bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span></span><br><span class="line"><span class="comment">// 迭代遍历一个请求所有bio中的所有segment</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rq_for_each_segment(bvl, _rq, _iter) \</span></span><br><span class="line"><span class="meta">    __rq_for_each_bio(_iter.bio, _rq)        \</span></span><br><span class="line"><span class="meta">        bio_for_each_segment(bvl, _iter.bio, _iter.iter)</span></span><br></pre></td></tr></table></figure><h3 id="io调度器">I/O调度器</h3><p>Linux 2.6以后的内核包含4个I/O调度器，它们分别是NoopI/O调度器（适合Flash）、Anticipatory I/O调度器、DeadlineI/O调度器（适合读取多的场景，数据库）与CFQI/O调度器（适合多媒体应用）。其中，AnticipatoryI/O调度器算法已经在2010年从内核中去掉了。</p><p>可以通过给内核添加启动参数，选择所使用的I/O调度算法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel elevator=deadline</span><br></pre></td></tr></table></figure><p>通过类似如下的命令，改变一个设备的调度器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> SCHEDULER &gt; /sys/block/DEVICE/queue/scheduler</span><br></pre></td></tr></table></figure><h2 id="linux块设备驱动初始化">Linux块设备驱动初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册设备</span></span><br><span class="line"><span class="comment">// major参数是块设备要使用的主设备号，name为设备名，它会显示在/proc/devices中。</span></span><br><span class="line"><span class="comment">// 如果major为0，内核会自动分配一个新的主设备号，register_blkdev（）函数的返回值就是这个主设备号。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 注销设备</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unregister_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><h2 id="块设备的打开释放">块设备的打开释放</h2><p>块设备驱动的open（）函数和其字符设备驱动的对等体不太相似，前者不以相关的inode和file结构体指针作为参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> block_device *bdev, <span class="type">fmode_t</span> mode);</span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> gendisk *disk, <span class="type">fmode_t</span> mode);</span><br></pre></td></tr></table></figure><h2 id="块设备ioctl函数">块设备ioctl函数</h2><p>与字符设备驱动一样，块设备可以包含一个ioctl（）函数以提供对设备的I/O控制能力。高层的块设备层代码处理了绝大多数I/O控制。例如，<code>drivers/block/floppy.c</code>实现了与软驱相关的命令，<code>drivers/mmc/card/block.c</code>实现了MMC子系统的命令处理。</p><h2 id="块设备驱动的io请求处理">块设备驱动的I/O请求处理</h2><p>使用请求队列的源码见<code>drivers/memstick/core/ms_block.c</code>。</p><p>使用请求队列对于一个机械磁盘设备而言的确有助于提高系统的性能，但是对于RAMDISK、ZRAM（CompressedRAM BlockDevice）等完全可真正随机访问的设备而言，无法从高级的请求队列逻辑中获益。源码见<code>drivers/block/zram/zram_drv.c</code></p><h2 id="实例vmem_disk驱动">实例：vmem_disk驱动</h2><h3 id="vmem_disk硬件原理">vmem_disk硬件原理</h3><p>vmem_disk是一种模拟磁盘，其数据实际上存储在RAM中。它使用通过vmalloc（）分配出来的内存空间来模拟出一个磁盘，以块设备的方式来访问这片内存。该驱动是对字符设备驱动章节中globalmem驱动的块方式改造。</p><p>加载vmem_disk.ko后，在使用默认模块参数的情况下，系统会增加4个块设备节点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /dev/vmem_disk*</span><br><span class="line">brw-rw---- 1 root disk 252, 0 2月 25 14:00 /dev/vmem_diska</span><br><span class="line">brw-rw---- 1 root disk 252, 16 2月 25 14:00 /dev/vmem_diskb</span><br><span class="line">brw-rw---- 1 root disk 252, 32 2月 25 14:00 /dev/vmem_diskc</span><br><span class="line">brw-rw---- 1 root disk 252, 48 2月 25 14:00 /dev/vmem_diskd</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> mkfs.ext2 /dev/vmem_diska</span><br><span class="line">mke2fs 1.42.9 (4-Feb-2014)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Fragment size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Stride=0 blocks, Stripe width=0blocks</span><br><span class="line">64 inodes, 512 blocks</span><br><span class="line">25 blocks (4.88%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=1</span><br><span class="line">Maximum filesystem blocks=524288</span><br><span class="line">1 block group</span><br><span class="line">8192 blocks per group, 8192fragments per group</span><br><span class="line">64 inodes per group</span><br><span class="line">Allocating group tables: <span class="keyword">done</span></span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="驱动开发常用项">驱动开发常用项</h1><h2 id="驱动属性项">驱动属性项</h2><p><code>linux/device.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 设备属性处理函数</span><br><span class="line">static ssize_t xxx1_store(struct device *dev,</span><br><span class="line">      struct device_attribute *attr,</span><br><span class="line">      const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">int input;</span><br><span class="line">if (kstrtoint(buf, 10, &amp;input))</span><br><span class="line">return -EINVAL;</span><br><span class="line">...</span><br><span class="line">schedule_work(&amp;work);</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br><span class="line">// 声明设备属性结构体dev_attr_xxx1，并赋值xxx1_store为对应的处理函数</span><br><span class="line">static DEVICE_ATTR_WO(xxx1);</span><br><span class="line">static struct attribute *xxx_attrs[] = &#123;</span><br><span class="line">&amp;dev_attr_xxx1.attr,</span><br><span class="line">&amp;dev_attr_xxx2.attr,</span><br><span class="line">NULL,</span><br><span class="line">&#125;;</span><br><span class="line">static const struct attribute_group xxx_group = &#123;</span><br><span class="line">.attrs = xxx_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在进行初始化时进行，例如probe中</span><br><span class="line">// 注册设备属性</span><br><span class="line">sysfs_create_group(&amp;dev-&gt;kobj, &amp;xxx_group);</span><br><span class="line">// 移除设备属性</span><br><span class="line">sysfs_remove_group(&amp;dev-&gt;kobj, &amp;xxx_group);</span><br></pre></td></tr></table></figure><h2 id="工作队列-1">工作队列</h2><p>内核驱动处理时，遇到比较费时类型的任务时，可以将任务放到工作队列，稍后在合适的时候进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 工作队列结构体</span><br><span class="line">struct work_struct&#123;&#125;</span><br><span class="line">// 工作队列处理函数</span><br><span class="line">void xxx_handle(struct work_struct *work);</span><br><span class="line">// 初始化工作队列</span><br><span class="line">INIT_WORK(&amp;xxx_work, xxx_handle);</span><br><span class="line">// 调度工作队列</span><br><span class="line">schedule_work(&amp;work);</span><br></pre></td></tr></table></figure><h1 id="附录">附录</h1><h2 id="常用命令">常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载驱动</span></span><br><span class="line">$ <span class="built_in">sudo</span> insmod globalmem.ko</span><br><span class="line"><span class="comment"># 卸载驱动</span></span><br><span class="line">$ <span class="built_in">sudo</span> rmmod globalmem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看最新的内核打印消息</span></span><br><span class="line">$ dmesg -W</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看驱动主设备号</span></span><br><span class="line">$ <span class="built_in">cat</span> /proc/devices | grep globalmem</span><br><span class="line">230 globalmem</span><br><span class="line"><span class="comment"># 查看驱动设备节点信息</span></span><br><span class="line">$ <span class="built_in">ls</span> -l /dev/globalmem</span><br><span class="line">crwxrwxrwx 1 root root 230, 0 Dec 27 17:40 /dev/globalmem</span><br><span class="line"><span class="comment"># 查看platform驱动</span></span><br><span class="line"><span class="built_in">ls</span> /sys/devices/platform/globalfifo -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root    0  1月  2 17:00 driver -&gt; ../../../bus/platform/drivers/globalfifo</span><br><span class="line">-rw-r--r-- 1 root root 4096  1月  2 17:03 driver_override</span><br><span class="line">-r--r--r-- 1 root root 4096  1月  2 17:03 modalias</span><br><span class="line">drwxr-xr-x 2 root root    0  1月  2 17:03 power</span><br><span class="line">lrwxrwxrwx 1 root root    0  1月  2 17:03 subsystem -&gt; ../../../bus/platform</span><br><span class="line">-rw-r--r-- 1 root root 4096  1月  2 17:00 uevent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建设备节点</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mknod</span> /dev/globalmem c 230 0</span><br><span class="line"><span class="comment"># 删除设备节点</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">unlink</span> /dev/globalmem</span><br><span class="line"><span class="comment"># 创建支持多设备的节点</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mknod</span> /dev/globalmem0 c 230 0</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mknod</span> /dev/globalmem1 c 230 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建的设备普通用户没有写入权限，需要增加写入权限</span></span><br><span class="line"><span class="comment"># 或者给予全权限</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 /dev/globalmem*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向设备写入数据</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world 0&quot;</span> &gt;&gt; /dev/globalmem0</span><br><span class="line"><span class="comment"># 读取设备中的数据</span></span><br><span class="line">$ <span class="built_in">cat</span> /dev/globalmem0</span><br><span class="line">hello world 0</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://github.com/kevinwangkk/LDD4.0_note/blob/master/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%80%E6%96%B0%E7%9A%84Linux4.0%E5%86%85%E6%A0%B8.pdf">Linux设备驱动开发详解：基于最新的Linux4.0内核.pdf</a></p><p><a href="https://blog.csdn.net/cotex_a9/category_12427627.html">嵌入式王道长-Linux内核驱动开发</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;Linux驱动开发依赖驱动运行内核的版本和对应的编译工具。内核版本查看使用命令&lt;code&gt;uname -r&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于嵌入式来说，一般都是源码编译，编译驱动时需要指定目标系统的内核源码。此外，需要设置交</summary>
      
    
    
    
    <category term="Linux" scheme="https://oz1010.github.com/categories/Linux/"/>
    
    <category term="Driver" scheme="https://oz1010.github.com/categories/Linux/Driver/"/>
    
    
  </entry>
  
  <entry>
    <title>Xv6-RISC-V阅读笔记</title>
    <link href="https://oz1010.github.com/2024/04/24/Xv6-RISC-V%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://oz1010.github.com/2024/04/24/Xv6-RISC-V%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-24T01:44:41.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf">参考原文</a></p><h1 id="chapter-1-系统接口">Chapter 1 系统接口</h1><h2 id="unix-utilities实验">Unix utilities实验</h2><p><a href="https://pdos.csail.mit.edu/6.828/2023/labs/util.html">实验说明</a></p><h3 id="启动系统">启动系统</h3><h3 id="sleep">sleep</h3><p>重点：使用<code>user/user.h</code>的sleep接口实现，单位为jiffies(1/10)。</p><h3 id="pingpong">pingpong</h3><p>重点：使用pip接口通信。</p><h3 id="primes">primes</h3><p>目的：主进程准备好2-35的数字写入管道。</p><p>从管道中读取数字n（此数字为素数），创建一个子进程，并将剩余的非n的倍数的数写入子管道中。然后进程等待子进程的退出。子进程会重复父进程的动作，直到读取的数字到达35，则不再创建子进程。</p><h3 id="find">find</h3><p>重点：熟悉文件属性读取，和路径拼接。</p><h3 id="xargs">xargs</h3><p>重点：使用exec接口实现，并需要构建新的参数数组。</p><h1 id="chapter-2-系统结构">Chapter 2 系统结构</h1><blockquote><p>RISC-V has three modes in which the CPU can execute instructions:machine mode, supervisor mode, and user mode.</p></blockquote><blockquote><p>An application can execute only user-mode instructions and is said tobe running in user space, while the software in supervisor mode can alsoexecute privileged instructions and is said to be running in kernelspace.</p></blockquote><blockquote><p>CPUs provide a special instruction ( RISC-V provides the<code>ecall</code> instruction ) that switches the CPU from user mode tosupervisor mode and enters the kernel at an entry point specified by thekernel.</p></blockquote><blockquote><p>the entire operating system resides in the kernel, so that theimplementations of all system calls run in supervisor mode. Thisorganization is called a monolithic kernel.</p></blockquote><blockquote><p>OS designers can minimize the amount of operating system code thatruns in supervisor mode, and execute the bulk of the operating system inuser mode. This kernel organization is called a microkernel.</p></blockquote><p>源码文件功能描述如下</p><table><thead><tr class="header"><th>文件名</th><th>功能描述</th></tr></thead><tbody><tr class="odd"><td>bio.c</td><td>Disk block cache for the file system.</td></tr><tr class="even"><td>console.c</td><td>Connect to the user keyboard and screen.</td></tr><tr class="odd"><td>entry.S</td><td>Very first boot instructions.</td></tr><tr class="even"><td>exec.c</td><td>exec() system call.</td></tr><tr class="odd"><td>file.c</td><td>File descriptor support.</td></tr><tr class="even"><td>fs.c</td><td>File system.</td></tr><tr class="odd"><td>kalloc.c</td><td>Physical page allocator.</td></tr><tr class="even"><td>kernelvec.S</td><td>Handle traps from kernel, and timer interrupts.</td></tr><tr class="odd"><td>log.c</td><td>File system logging and crash recovery.</td></tr><tr class="even"><td>main.c</td><td>Control initialization of other modules during boot.</td></tr><tr class="odd"><td>pipe.c</td><td>Pipes.</td></tr><tr class="even"><td>plic.c</td><td>RISC-V interrupt controller.</td></tr><tr class="odd"><td>printf.c</td><td>Formatted output to the console.</td></tr><tr class="even"><td>proc.c</td><td>Processes and scheduling.</td></tr><tr class="odd"><td>sleeplock.c</td><td>Locks that yield the CPU.</td></tr><tr class="even"><td>spinlock.c</td><td>Locks that don’t yield the CPU.</td></tr><tr class="odd"><td>start.c</td><td>Early machine-mode boot code.</td></tr><tr class="even"><td>string.c</td><td>C string and byte-array library.</td></tr><tr class="odd"><td>swtch.S</td><td>Thread switching.</td></tr><tr class="even"><td>syscall.c</td><td>Dispatch system calls to handling function.</td></tr><tr class="odd"><td>sysfile.c</td><td>File-related system calls.</td></tr><tr class="even"><td>sysproc.c</td><td>Process-related system calls.</td></tr><tr class="odd"><td>trampoline.S</td><td>Assembly code to switch between user and kernel.</td></tr><tr class="even"><td>trap.c</td><td>C code to handle and return from traps and interrupts.</td></tr><tr class="odd"><td>uart.c</td><td>Serial-port console device driver.</td></tr><tr class="even"><td>virtio_disk.c</td><td>Disk device driver.</td></tr><tr class="odd"><td>vm.c</td><td>Manage page tables and address spaces.</td></tr></tbody></table><p>进程虚拟空间分布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">地址    功能域</span><br><span class="line"></span><br><span class="line">MAXVA   &lt;---------&gt;</span><br><span class="line">        trampoline</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        trapframe</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        heap</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        user stack</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        user text</span><br><span class="line">        and data</span><br><span class="line">        (followed by global variables)</span><br><span class="line">        (Instructions come first)</span><br><span class="line">0       &lt;---------&gt;</span><br></pre></td></tr></table></figure><p>risc-v指针宽度为64位，但硬件只使用低39位用于在页表中寻找虚拟地址，而xv6系统中只使用了38位。因此最大地址为<code>2^38 - 1=0x3f,ffff,ffff MAXVA</code>(kernel/riscv.h:363)</p><p>进程重要信息存储在<code>struct proc</code>(kernel/proc.h:85)</p><blockquote><p>RISC-V <code>ecall</code> instruction raises the hardware privilegelevel and changes the program counter to a kernel-defined entrypoint.</p></blockquote><p>When the system call completes, the kernel switches back to the userstack and returns to user space by calling the <code>sret</code>instruction, which lowers the hardware privilege level and resumesexecuting user instructions just after the system call instruction.</p><p>启动流程：</p><ul><li>boot loader将kernel加载到内存<code>0x8000 0000</code></li><li>在machinemode下，跳转到<code>_entry</code>(kernel/entry.S:7)，设置堆栈，并跳转运行C代码</li><li>在C代码入口函数<code>start</code>(kernel/start.c:21)中，切换到supervisormode，配置时钟中断，并跳转到主函数。</li><li>在主函数<code>main</code>(kernel/main.c:11)中，初始化设备和子系统，创建第一个进程</li><li>在初始化进程<code>userinit</code>(kernel/proc.c:233)中，寄存器a7装载<code>SYS_EXEC</code>(kernel/syscall.h:8)后再次进入内核</li><li>在内核系统调用处理函数<code>syscall</code>(kernel/syscall.c:132)中，启动<code>/init</code>进程</li><li>系统调用完成后，返回进程<code>init</code>(user/init.c)，创建一个新console设备文件，并打开文件描述符0,1,2。</li></ul><blockquote><p>it sets the previous privilege mode to supervisor in the registermstatus, it sets the return address to main by writing main’s addressinto the register mepc, disables virtual address translation insupervisor mode by writing 0 into the page-table register satp, anddelegates all interrupts and exceptions to supervisor mode.</p></blockquote><h2 id="system-call实验">system call实验</h2><h3 id="system-call-tracing">System call tracing</h3><p>新增一个<code>trace</code>系统调用，它接收一个整数参数，它表明哪些系统调用被标记。当被标记的系统调用返回时，需要打印<code>&lt;pid&gt;: syscall &lt;call name&gt; -&gt; &lt;return value&gt;</code>。此标记对子进程和forks都有效，但对其他进程无效。</p><p>关键点</p><ul><li><code>user/trace.c</code>中设置调用<code>trace(x)</code>后需要再<code>trace(0)</code>清空进程标记；</li><li><code>user/user.h</code>中增加用户调用系统函数<code>int trace(int sys_mask);</code>，<code>user/usys.pl</code>增加<code>trace</code>生成相关汇编代码；</li><li><code>kernel/syscall.h</code>新增宏编号<code>#define SYS_trace 22</code>，<code>kernel/sysproc.c</code>新增标记实现函数<code>uint64 sys_trace(void)</code></li><li><code>syscall</code>增加标记打印逻辑，需要注意<code>allocproc</code>中共用<code>struct proc proc[NPROC];</code>，申请后要清空之前的标记；</li></ul><h3 id="sysinfo">Sysinfo</h3><p>新增一个<code>sysinfo</code>系统调用，它会收集系统空闲内存字节大小<code>freemem</code>和正在使用的进程数量<code>nproc</code>。需要提供用户测试程序<code>sysinfotest</code>调用这个接口，若整个调用没有问题，则打印<code>"sysinfotest: OK"</code>。</p><p>关键点</p><ul><li>需要使用接口<code>copyout</code>将内核空间的数据拷贝到用户空间中</li></ul><h2 id="练习">练习</h2><ol type="1"><li>增加一个系统调用，返回系统剩余可用内存大小</li></ol><h1 id="chapter-3-页表">Chapter 3 页表</h1><h2 id="创建地址空间">创建地址空间</h2><p>核心的数据结构<code>pagetable_t kernel_pagetable</code>(kernel/vm.c:1)中，核心的功能函数是<code>walk</code>，用于查找虚拟地址对应的PTE。</p><p><code>main</code>中调用<code>kvminit</code>(kernel/vm.c:54)创建内核页表，再调用<code>kvmmake</code>，最终通过<code>kvmmap</code>、<code>mappages</code>和<code>walk</code>完成物理地址虚拟地址映射。</p><p><code>main</code>中调用<code>kvminithart</code>(kernel/vm.c:62)安装内核页表。主要讲根页表的地址设置到<code>satp</code>寄存器中，设置前后需要刷新<code>TLB</code>缓存。</p><blockquote><p>The RISC-V has an instruction sfence.vma that flushes the currentCPU’s TLB. Xv6 executes sfence.vma in kvminithart after reloading thesatp register</p></blockquote><h2 id="物理内存分配">物理内存分配</h2><p>分配器定义在<code>kalloc.c</code>(kernel/kalloc.c:1)。每个空闲页的列表元素都是一个<code>struct run</code>。</p><p><code>main</code>中调用<code>kinit</code>(kernel/kalloc.c:27)来初始化分配器。它将初始化空闲列表<code>kmem-&gt;freelist</code>(kernel/kalloc.c:21)用于保存内核结束位置到<code>PHYSTOP</code>区间的每一页。</p><h2 id="进程地址空间">进程地址空间</h2><p>每个进程都有独立的页表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MAXVA   &lt;---------&gt;</span><br><span class="line">        trampoline  RX--</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        trapframe   R-W-</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        unused</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        heap        R-WU</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        stack       R-WU</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        guard page</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        data        R-WU</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        unused</span><br><span class="line">        &lt;---------&gt;</span><br><span class="line">        text        RX-U</span><br><span class="line">0       &lt;---------&gt;</span><br></pre></td></tr></table></figure><p>一个进程的用户内存从虚拟地址零开始，可以增长到<code>MAXVA</code>(kernel/riscv.h:360)，允许最大使用256GB内存。</p><p>零地址放置的text代码，没有写入权限，当异常的程序试图向零地址写入数据，会出发<code>page fault</code>。</p><h2 id="sbrk">sbrk</h2><p><code>sbrk</code>是进程为调整内存时的系统调用。它由函数<code>growproc</code>(kernel/proc.c:260)实现。</p><h2 id="exec">exec</h2><p><code>exec</code>是一个系统调用，它可以用从文件读取的数据替换进程用户空间数据，这样的文件被称为二进制或可行性文件。函数<code>exec</code>(kernel/exec.c:23)会读取并解析ELF格式的文件，它包含<code>struct elfhdr</code>ELF文件头部和一系列<code>struct proghdr</code>程序区域头部。每个程序区域头部描述程序必须加载到内存的位置。</p><p><code>/init</code>程序区域头部像下面这样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -p user/_init </span><br><span class="line"></span><br><span class="line">user/_init:     file format elf64-little</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">0x70000003 off    0x0000000000006bac vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**0</span><br><span class="line">         filesz 0x0000000000000033 memsz 0x0000000000000000 flags r--</span><br><span class="line">    LOAD off    0x0000000000001000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12</span><br><span class="line">         filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x</span><br><span class="line">    LOAD off    0x0000000000002000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12</span><br><span class="line">         filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-</span><br><span class="line">   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4</span><br><span class="line">         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></td></tr></table></figure><p>值得注意的是，头部信息中<code>filesz</code>可能会小于<code>memsz</code>，那时因为这些变量值为0，文件中无需存储，但加载时需要申请<code>memsz</code>大小的空间并清零。</p><p>然后，函数需要拷贝参数列表，并将堆栈和PC设置好。最后将释放旧页表，使用新页表。</p><h2 id="练习-1">练习</h2><ol type="1"><li>解析riscv的设备树，找出总共拥有多少物理内存</li><li>写一个用户程序调用<code>sbrk(1)</code>，观察调用前后页表的变化。内核申请了多少空间？新内存的PTE包含哪些数据？</li><li>修改源码让内核使用超级页</li><li>在Unix系统中，若<code>exec</code>处理的可执行文件以<code>#!</code>开头，则会使用第一行剩余部分替换程序作为解释文件执行。修改源码让内核支持这个特性。</li><li>实现一个地址空间随机分布的内核。</li></ol><h1 id="chapter-4-traps和系统调用">Chapter 4 traps和系统调用</h1><h2 id="riscv的trap机制">riscv的trap机制</h2><blockquote><p>Each RISC-V CPU has a set of control registers that the kernel writesto tell the CPU how to handle traps, and that the kernel can read tofind out about a trap that has occurred.</p></blockquote><p>在文件<code>riscv.h</code>(kernel/riscv.h:1)中包含系统用到的所有描述。这里列举最重要的寄存器</p><ul><li><code>stvec</code>: 内核写入trap处理程序的地址</li><li><code>sepc</code>:当trap发生时，处理器会保存<code>pc</code>；当从trap返回时，调用<code>sret</code>会从此寄存器恢复<code>pc</code>。</li><li><code>scause</code>: 处理器会存放一个数字描述trap的原因</li><li><code>sscratch</code>:trap处理程序使用<code>sscratch</code>来避免改写用户寄存器</li><li><code>sstatus</code>:SIE位控制设备中断是否使能；SPP位指示trap触发前是user mode还是supervisormode；</li></ul><p>xv6只将它们使用在计时器中断的特殊场景</p><p>硬件处理所有类型trap流程：</p><ul><li>若<code>sstatus</code>的SIE位被清零，则后面的步骤略过</li><li><code>sstatus</code>的SIE位清零</li><li>拷贝<code>pc</code>值到<code>sepc</code></li><li>保存当前模式到<code>sstatus</code>的SPP位</li><li>设置<code>scause</code></li><li>模式切换为supervisor mode</li><li>拷贝<code>stvec</code>到<code>pc</code></li><li>继续从<code>pc</code>处开始执行</li></ul><blockquote><p>Note that the CPU doesn’t switch to the kernel page table, doesn’tswitch to a stack in the kernel, and doesn’t save any registers otherthan the pc.</p></blockquote><h2 id="用户空间的traps流程">用户空间的traps流程</h2><p>用户空间trap路径是：<code>uservec</code>(kernel/trampoline.S:21)-&gt;<code>usertrap</code>(kernel/trap.c:37)-return-&gt;<code>usertrapret</code>(kernel/trap.c:90)-&gt;userret(kernel/trampoline.S:101)</p><p>xv6使用trampoline页来存储<code>stvec</code>，它页包含<code>uservec</code>。trampoline页会被每个进程映射到TRAMPOLINE的地址处。</p><p><code>uservec</code>函数会将32个用户寄存器存储到TRAPFRAME地址所在的<code>trapframe</code>结构中，然后将寄存器<code>satp</code>切换为内核页表，再调用<code>usertrap</code>函数。</p><p><code>usertrap</code>(kernel/trap.c:37)函数会检测trap的原因并处理它。首先将设置<code>stvec</code>为<code>kernelvec</code>，以便处理内核trap。保存<code>sepc</code>寄存器。如果trap是系统调用，则调用<code>syscall</code>处理它；若是设备中断，<code>devintr</code>处理它；否则，是一种异常场景，调用内核终止异常的进程。若是系统调用，则在函数结束时会调用<code>usertrapret</code></p><p>返回用户空间的第一步是调用<code>usertrapret</code>(kernel/trap.c:90)。它会将<code>stvec</code>设置回<code>uservec</code>，<code>uservec</code>的映射地址可以通过TRAMPOLINE、trampoline和uservec计算出来（注意内核中这些是物理地址）。然后恢复<code>pc</code>，最后调用<code>userret</code>函数并将<code>a0</code>设置为用户页表。</p><p><code>userret</code>(kernel/trampoline.S:101)函数将切换<code>satp</code>为用户页表，并恢复32个用户寄存器。最后调用<code>sret</code>返回用户空间。</p><h2 id="系统调用流程">系统调用流程</h2><p>以initcode.S中第一个系统调用<code>exec</code>为例。</p><p>initcode.S在寄存器<code>a0</code>和<code>a1</code>存放着<code>exec</code>的参数，并将系统调用编号存放在<code>a7</code>中。根据系统调用编号在<code>syscalls</code>(kernel/syscall.c:107)数组中匹配到处理函数。指令<code>ecall</code>会触发trap切换到内核中并引发<code>uservec</code>、<code>usertrap</code>和<code>syscall</code>执行。</p><h2 id="系统调用参数列表">系统调用参数列表</h2><p>内核trap代码将用户寄存器放在当前进程的trapframe上，可以通过内核函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>返回第n个参数，它们通过调用<code>argraw</code>实现(kernel/syscall.c:34)。</p><p>有些参数通过用户地址传递，<code>fechstr</code>(kernel/syscall.c:25)函数能够拷贝用户传递的字符串。</p><h2 id="内核空间的traps流程">内核空间的traps流程</h2><p>内核空间trap路径是：<code>kernelvec</code>(kernel/kernelvec.S:12)-&gt;<code>kerneltrap</code>(kernel/trap.c:135)-&gt;<code>kernelvec</code>(kernel/kernelvec.S:12)</p><p>若trap不是设备中断，则异常会直接导致xv6内核出panic。</p><p>当处理器遇到trap进入内核空间时，总会禁用中断，直到设置<code>stvec</code>后。</p><h2 id="缺页异常">缺页异常</h2><p>若发生在用户空间，内核将终止相关进程。若发生在内核空间，则会直接panic。</p><p>许多内核利用缺页异常来实现写时复制（copy-on-write, COW）机制。COWfork的基本方法是，为父进程和子进程初始化共享所有物理页，但将他们的全部设置为只读。当进程向某页写入数据时，会触发storepagefaults。此时内核需要重新申请新的一页将数据拷贝过来，并再次进行映射。一个重要的优化项是，对于缺页发生在仅从该进程中引用的，无需进行拷贝。</p><p>另一个广泛使用的特性是惰性分配（lazyallocation）。当一个应用调用<code>sbrk</code>请求更多内存，内核只调整其使用大小，但不会申请物理内存和创建PTEs。当这些新地址被访问时，才会申请对应的内存页并完成映射。</p><p>还有一个广泛使用的特性是需求分页（demandpaging）。当大型程序启动时，内核无需将所有数据加载到内存中，而仅仅配置足够的用户地址空间，并将其设置为无效。当发生页错误时，内核将页的内容读入并映射到用户空间。</p><p>为应对程序运行时需要的空间比硬件RAM大的场景，操作系统可以实现磁盘映射（pagingto disk）。</p><h2 id="练习-2">练习</h2><ol type="1"><li>配置内核页表，让内核可以直接使用用户空间地址；</li><li>实现惰性内存分配机制；</li><li>实现COW fork；</li><li>是否有方法消除TRAPFRAME页映射到每个用户地址空间？比如，修改<code>uservec</code>函数将32个用户寄存器存入内核栈，或将其存入<code>proc</code>结构中？</li><li>是否有方法消除TRAMPOLINE页映射？</li></ol><h1 id="中断和设备驱动">中断和设备驱动</h1><p>在xv6中，内核trap会处理和识别设备中断，最终交于<code>devintr</code>(kernel/trap.c:178)。</p><blockquote><p>Many device drivers execute code in two contexts: a top half thatruns in a process’s kernel thread, and a bottom half that executes atinterrupt time.</p></blockquote><h2 id="终端输入">终端输入</h2><p>终端驱动(kernel/console.c)是一个简单的驱动框架的示例。</p><blockquote><p>The UART hardware that the driver talks to is a 16550 chip [13]emulated by QEMU. On a real computer, a 16550 would manage an RS232serial link connecting to a terminal or other computer. When runningQEMU, it’s connected to your keyboard and display.</p></blockquote><p>UART的基地址是0x10000000(UART0,kernel/memlayout.h:21)，UART0各寄存器定义在文件(kernel/uart.c:22)中。</p><p>xv6的<code>main</code>调用<code>consoleinit</code>(kernel/console.c:182)函数，然后再调用<code>uartinit</code>(kernel/uart.c:53)函数来初始化UART硬件。</p><p>在init.c(user/init.c:19)打开的文件描述符，它能够读取xv6的命令。调用<code>read</code>系统调用，通过内核来调用<code>consoleread</code>(kernel/console.c:80)。它会一直等待中断并缓存数据到<code>cons.buf</code>中，直到整个行输入完成，会将缓存中数据拷贝给用户最终返回到用户空间。</p><p>当用户输入一个字符，UART硬件设备会想处理器产生一个中断，它会激活xv6的trap处理程序。设备中断最后会调用<code>devintr</code>(kernel/trap.c:178)进行处理。接着，通过PLIC硬件单元来分辨是哪个设备中断，如果是UART设备<code>devintr</code>会调用<code>uartintr</code>。</p><p><code>uartintr</code>(kernel/uart.c:176)会从UART硬件读取任意输入字符，并交于<code>consoleintr</code>(kernel/console.c:136)进行处理；<code>consoleintr</code>的任务就是将输入放到<code>cons.buf</code>，直到整行输入完成，立即唤醒<code>consoleread</code>。</p><h2 id="终端输出">终端输出</h2><p>在一个连接到终端的文件描述符的<code>write</code>系统调用，最终会调用<code>uartputc</code>(kernel/uart.c:87)。对于每个字符，会调用<code>uartstart</code>来开启设备发送。</p><h2 id="驱动的并发">驱动的并发</h2><blockquote><p>These calls acquire a lock, which protects the console driver’s datastructures from concurrent access.</p></blockquote><h2 id="计时器中断">计时器中断</h2><blockquote><p>Xv6 uses timer interrupts to maintain its clock and to enable it toswitch among compute-bound processes; the yield calls in usertrap andkerneltrap cause this switching.</p></blockquote><blockquote><p>RISC-V requires that timer interrupts be taken in machine mode, notsupervisor mode.</p></blockquote><p>代码在start.c配置接收计时器中断(kernel/start.c:63)。部分工作的目的是编写CLINT硬件（core-localinterruptor），在特定延时后产生一个中断。最终，<code>start</code>配置<code>mtvec</code>到<code>timervec</code>并使能计时器中断。</p><blockquote><p>A timer interrupt can occur at any point when user or kernel code isexecuting; there’s no way for the kernel to disable timer interruptsduring critical operations.</p></blockquote><blockquote><p>The basic strategy is for the handler to ask the RISC-V to raise a“software interrupt” and immediately return.</p></blockquote><p>在machinemode的中断处理程序是<code>timervec</code>(kernel/kernelvec.S:95)，它主要配置CLINT的<code>MTIMECMP</code>寄存器，并设置<code>sip</code>为2后立刻返回。</p><h2 id="练习-3">练习</h2><ol type="1"><li>修改uart.c完全不使用中断，同时也需要修改console.c</li><li>增加一个以太网卡驱动</li></ol><h1 id="chapter-6-锁">Chapter 6 锁</h1><blockquote><p>Xv6 uses a number of concurrency control techniques, depending on thesituation; many more are possible. This chapter focuses on a widely usedtechnique: the lock.</p></blockquote><h2 id="竞争">竞争</h2><h2 id="锁">锁</h2><blockquote><p>On the RISC-V this instruction is <code>amoswap r, a</code>.<code>amoswap</code> reads the value at the memory address<code>a</code>, writes the contents of register <code>r</code> to thataddress, and puts the value it read into <code>r</code>.</p></blockquote><blockquote><p>It performs this sequence atomically, using special hardware toprevent any other CPU from using the memory address between the read andthe write.</p></blockquote><blockquote><p>Xv6’s acquire (kernel/spinlock.c:22) uses the portable C library call__sync_lock_test_and_set, which boils down to the amoswap instruction;the return value is the old (swapped) contents of lk-&gt;locked.</p></blockquote><p><code>acquire</code>(kernel/spinlock.c:22)利用riscv处理器的指令<code>amoswap.w.aq a0, a0, (s1)</code>实现。当获取锁成功时<code>lk-&gt;locked</code>为1。</p><p><code>release</code>(kernel/spinlock.c:47)利用riscv处理器的指令<code>amoswap.w zero, zero, (s1)</code>实现。当释放锁成功时<code>lk-&gt;locked</code>为0。</p><h2 id="使用锁">使用锁</h2><blockquote><p>A hard part about using locks is deciding how many locks to use andwhich data and invariants each lock should protect.</p></blockquote><h2 id="再入锁">再入锁</h2><blockquote><p>It might appear that some deadlocks and lock-ordering challengescould be avoided by using re-entrant locks, which are also calledrecursive locks. The idea is that if the lock is held by a process andif that process attempts to acquire the lock again, then the kernelcould just allow this (since the process already has the lock), insteadof calling panic, as the xv6 kernel does.</p></blockquote><h2 id="锁和中断处理程序">锁和中断处理程序</h2><blockquote><p>Some xv6 spinlocks protect data that is used by both threads andinterrupt handlers.</p></blockquote><blockquote><p>To avoid this situation, if a spinlock is used by an interrupthandler, a CPU must never hold that lock with interrupts enabled.</p></blockquote><p>例如，<code>clockintr</code>计时器中断处理会增加<code>ticks</code>(kernel/trap.c:164)，同时内核线程<code>sys_sleep</code>(kernel/sysproc.c:59)会读取<code>ticks</code>的值。锁<code>tickslock</code>会让两次访问串行化。</p><h2 id="指令和内存顺序">指令和内存顺序</h2><blockquote><p>It is natural to think of programs executing in the order in whichsource code statements appear. That’s a reasonable mental model forsingle-threaded code, but is incorrect when multiple threads interactthrough shared memory.</p></blockquote><blockquote><p>To tell the hardware and compiler not to re-order, xv6 uses__sync_synchronize() in both acquire (kernel/spinlock.c:22) and release(kernel/spinlock.c:47). __sync_synchronize() is a memory barrier: ittells the compiler and CPU to not reorder loads or stores across thebarrier.</p></blockquote><h2 id="睡眠锁">睡眠锁</h2><blockquote><p>Xv6 provides such locks in the form of sleep-locks. acquiresleep(kernel/sleeplock.c:22) yields the CPU while waiting</p></blockquote><h2 id="练习-4">练习</h2><ol type="1"><li>若屏蔽<code>kalloc</code>(kernel/kalloc.c:69)<code>acquire</code>和<code>release</code>的调用，会出现哪些问题？若没有看到问题，原因是什么？</li><li>在<code>kfree</code>中屏蔽锁（恢复<code>kalloc</code>中的锁），会出现哪些问题？</li><li>修改<code>kalloc.c</code>源码让内存申请支持并发，CPU不用相互等待。</li><li>使用POSIX线程进行编码。例如，实现一个并行哈希表并测试<code>puts/gets</code>数据量是否随着核数量的增加而增加。</li><li>在xv6中实现pthreads的子集。实现一个用户级的线程库，这样一个用户进程就可以有多个线程，并安排这些线程运行在不同的cpu上并行运行。想出一个设计，正确地处理一个线程进行阻塞系统调用，并改变其共享地址空间。</li></ol><h1 id="调度">调度</h1><h2 id="复用">复用</h2><blockquote><p>Xv6 multiplexes by switching each CPU from one process to another intwo situations. First, xv6’s sleep and wakeup mechanism switches when aprocess waits for device or pipe I/O to complete, or waits for a childto exit, or waits in the sleep system call. Second, xv6 periodicallyforces a switch to cope with processes that compute for long periodswithout sleeping.</p></blockquote><h2 id="上下文切换">上下文切换</h2><blockquote><p>it just saves and restores sets of 32 RISC-V registers, calledcontexts.</p></blockquote><p>当进程想放弃CPU时，内核线程会调用<code>swtch</code>来保存它的上下文并返回调度器上下文。每个上下文都包含在<code>struct context</code>(kernel/proc.h:2)，进程的<code>struct proc</code>和CPU的<code>struct cpu</code>都包含上下文。</p><p><code>swtch</code>(kernel/swtch.S:3)只保存被调用者保存的寄存器。C编译器会生成代码保存调用者保存的寄存器到栈上。</p><blockquote><p>When swtch returns, it returns to the instructions pointed to by therestored ra register, that is, the instruction from which the new threadpreviously called swtch.</p></blockquote><h2 id="调度-1">调度</h2><p>当调用函数<code>swtch</code>后，会切换到调度器的栈。调度器会继续在循环中查找可以切换的进程，并再次调用<code>swtch</code>进行切换。</p><blockquote><p>We just saw that xv6 holds p-&gt;lock across calls to swtch: thecaller of swtch must already hold the lock, and control of the lockpasses to the switched-to code.</p></blockquote><h2 id="mycpu和myproc">mycpu和myproc</h2><blockquote><p>Xv6 maintains a struct cpu for each CPU (kernel/proc.h:22), whichrecords the process currently running on that CPU (if any), savedregisters for the CPU’s scheduler thread, and the count of nestedspinlocks needed to manage interrupt disabling.</p></blockquote><blockquote><p>RISC-V numbers its CPUs, giving each a hartid. Xv6 ensures that eachCPU’s hartid is stored in that CPU’s tp register while in the kernel.This allows mycpu to use tp to index an array of cpu structures to findthe right one.</p></blockquote><blockquote><p>It would be more convenient if xv6 could ask the RISC-V hardware forthe current hartid whenever needed, but RISC-V allows that only inmachine mode, not in supervisor mode.</p></blockquote><blockquote><p>The return value of myproc is safe to use even if interrupts areenabled: if a timer interrupt moves the calling process to a differentCPU, its struct proc pointer will stay the same.</p></blockquote><h2 id="睡眠和唤醒">睡眠和唤醒</h2><blockquote><p>Sleep and wakeup are often called sequence coordination orconditional synchronization mechanisms.</p></blockquote><h2 id="管道">管道</h2><blockquote><p>A more complex example that uses sleep and wakeup to synchronizeproducers and consumers is xv6’s implementation of pipes. Each pipe isrepresented by a struct pipe, which contains a lock and a databuffer.</p></blockquote><blockquote><p>Let’s suppose that calls to piperead and pipewrite happensimultaneously on two different CPUs.</p></blockquote><h2 id="进程锁">进程锁</h2><blockquote><p>The lock associated with each process (p-&gt;lock) is the mostcomplex lock in xv6. A simple way to think about p-&gt;lock is that itmust be held while reading or writing any of the following struct procfields: p-&gt;state, p-&gt;chan, p-&gt;killed, p-&gt;xstate, andp-&gt;pid.</p></blockquote><h2 id="练习-5">练习</h2><ol type="1"><li></li></ol><h1 id="文件系统">文件系统</h1><h2 id="概述">概述</h2><blockquote><p>The xv6 file system implementation is organized in seven layers</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;----------------&gt;</span><br><span class="line">File descriptor</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Pathname</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Directory</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Inode</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Logging</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Buffer cache</span><br><span class="line">&lt;----------------&gt;</span><br><span class="line">Disk</span><br><span class="line">&lt;----------------&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Disk hardware traditionally presents the data on the disk as anumbered sequence of 512-byte blocks (also called sectors): sector 0 isthe first 512 bytes, sector 1 is the next, and so on.</p></blockquote><blockquote><p>The file system does not use block 0 (it holds the boot sector).Block 1 is called the superblock; it contains metadata about the filesystem (the file system size in blocks, the number of data blocks, thenumber of inodes, and the number of blocks in the log). Blocks startingat 2 hold the log. After the log are the inodes, with multiple inodesper block. After those come bitmap blocks tracking which data blocks arein use. The remaining blocks are data blocks</p></blockquote><p>xv6文件系统结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0       &lt;----------------&gt;</span><br><span class="line">        boot</span><br><span class="line">1       &lt;----------------&gt;</span><br><span class="line">        super</span><br><span class="line">2       &lt;----------------&gt;</span><br><span class="line">        log</span><br><span class="line"></span><br><span class="line">        &lt;----------------&gt;</span><br><span class="line">        inodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;----------------&gt;</span><br><span class="line">        bit map</span><br><span class="line">        &lt;----------------&gt;</span><br><span class="line">        data</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        data</span><br><span class="line">        &lt;----------------&gt;</span><br></pre></td></tr></table></figure><h2 id="缓存层">缓存层</h2><p>代码在<code>bio.c</code>中，缓存层有两个任务</p><ul><li>同步访问硬盘块block。确保只有一个块的副本在内存中，且同一时间只有一个内核线程在使用它。</li><li>缓存热门数据块block。</li></ul><blockquote><p>The main interface exported by the buffer cache consists of bread andbwrite. A kernel thread must release a buffer by calling brelse when itis done with it.</p></blockquote><blockquote><p>bread (kernel/bio.c:93) calls bget to get a buffer for the givensector (kernel/bio.c:97).</p></blockquote><blockquote><p>When the caller is done with a buffer, it must call brelse to releaseit.</p></blockquote><h2 id="日志层">日志层</h2><blockquote><p>One of the most interesting problems in file system design is crashrecovery.</p></blockquote><blockquote><p>Xv6 solves the problem of crashes during file-system operations witha simple form of logging.</p></blockquote><blockquote><p>Once the system call has logged all of its writes, it writes aspecial commit record to the disk indicating that the log contains acomplete operation. At that point the system call copies the writes tothe on-disk file system data structures. After those writes havecompleted, the system call erases the log on disk.</p></blockquote><h2 id="block块分配器">block块分配器</h2><blockquote><p>File and directory content is stored in disk blocks, which must beallocated from a free pool. Xv6’s block allocator maintains a freebitmap on disk, with one bit per block.</p></blockquote><h2 id="inode层">inode层</h2><blockquote><p>It might refer to the on-disk data structure containing a file’s sizeand list of data block numbers. Or “inode” might refer to an in-memoryinode</p></blockquote><p>磁盘上数据展现形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dinode</span><br><span class="line">|----------------|</span><br><span class="line">type</span><br><span class="line">|----------------|</span><br><span class="line">major</span><br><span class="line">|----------------|</span><br><span class="line">minor</span><br><span class="line">|----------------|</span><br><span class="line">nlink</span><br><span class="line">|----------------|</span><br><span class="line">size</span><br><span class="line">|----------------|</span><br><span class="line">address 1           --&gt;     data0_1</span><br><span class="line">|----------------|</span><br><span class="line">...</span><br><span class="line">|----------------|</span><br><span class="line">address 12          --&gt;     data0_12</span><br><span class="line">|----------------|</span><br><span class="line">indirect            --&gt;     indirect block</span><br><span class="line">|----------------|          |----------------|</span><br><span class="line">                            address 1           --&gt;     data1_1</span><br><span class="line">                            |----------------|</span><br><span class="line">                            ...</span><br><span class="line">                            |----------------|</span><br><span class="line">                            address 256         --&gt;     data1_256</span><br><span class="line">                            |----------------|</span><br></pre></td></tr></table></figure><h2 id="文件夹层">文件夹层</h2><blockquote><p>A directory is implemented internally much like a file.</p></blockquote><h2 id="目录名称">目录名称</h2><h2 id="文件描述符层">文件描述符层</h2><blockquote><p>All the open files in the system are kept in a global file table, theftable.</p></blockquote><blockquote><p>The functions sys_link and sys_unlink edit directories, creating orremoving references to inodes. They are another good example of thepower of using transactions.</p></blockquote><h2 id="练习-6">练习</h2><h1 id="附录">附录</h1><h2 id="ch.1-unix-utilities实验代码">CH.1 Unix utilities实验代码</h2><h3 id="sleep-1">sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;sleep: need one arg\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ticks = 1/10 seconds</span></span><br><span class="line">    seconds = <span class="number">10</span> * atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (seconds &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(seconds);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pingpong-1">pingpong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>]; <span class="comment">// parent-&gt;child</span></span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>]; <span class="comment">// child-&gt;parent</span></span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        read(p1[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), buffer);</span><br><span class="line">        write(p2[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        write(p1[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        read(p2[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), buffer);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="primes-1">primes</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUMBER 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p0[<span class="number">2</span>]; <span class="comment">// parent-&gt;child</span></span><br><span class="line">    <span class="type">int</span> n, prime;</span><br><span class="line">    pipe(p0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feeds the numbers 2 through 35</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAX_NUMBER; ++i)</span><br><span class="line">        write(p0[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (read(p0[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d prime %d\n&quot;</span>, getpid(), n);</span><br><span class="line">        prime = n;</span><br><span class="line">        <span class="type">int</span> p1[<span class="number">2</span>]; <span class="comment">// child -&gt; grandchild</span></span><br><span class="line">        pipe(p1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child</span></span><br><span class="line">            close(p0[<span class="number">0</span>]);</span><br><span class="line">            close(p0[<span class="number">1</span>]);</span><br><span class="line">            p0[<span class="number">0</span>] = p1[<span class="number">0</span>];</span><br><span class="line">            p0[<span class="number">1</span>] = p1[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// parent</span></span><br><span class="line">            <span class="keyword">while</span> (n &lt; MAX_NUMBER &amp;&amp; read(p0[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)))</span><br><span class="line">                <span class="keyword">if</span> (n % prime != <span class="number">0</span>)</span><br><span class="line">                    write(p1[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// close all resources</span></span><br><span class="line">            close(p0[<span class="number">0</span>]);</span><br><span class="line">            close(p0[<span class="number">1</span>]);</span><br><span class="line">            close(p1[<span class="number">0</span>]);</span><br><span class="line">            close(p1[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// wait children</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; MAX_NUMBER)</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d exit\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="find-1">find</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmp_file</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str1, *str2;</span><br><span class="line">    <span class="keyword">for</span> (str1 = path + <span class="built_in">strlen</span>(path), str2 = name + <span class="built_in">strlen</span>(name); str1 &gt;= path &amp;&amp; str2 &gt;= name &amp;&amp; *str1 == *str2; --str1, --str2)</span><br><span class="line">        ; <span class="comment">// printf(&quot;%c %c\n&quot;, *str1, *str2);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">int</span>)(str2 - name) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *patern)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: connot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: connot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        cmp_file(path, patern);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">if</span> (*(p - <span class="number">1</span>) != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;.&quot;</span>, de.name) == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;..&quot;</span>, de.name) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            find(buf, patern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: need more args\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="xargs-1">xargs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span> *newarg[MAXARG];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> new_idx;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>, new_idx = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            newarg[new_idx++] = argv[i];</span><br><span class="line">    <span class="keyword">while</span> (*gets(buffer, <span class="keyword">sizeof</span>(buffer)) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[<span class="built_in">strlen</span>(buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        newarg[new_idx] = buffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exec(newarg[<span class="number">0</span>], newarg);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ch.2-system-calls实验代码">CH.2 system calls实验代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf&quot;&gt;参考原文&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;chapter-1-系统接口&quot;&gt;Chapter 1 系统接口&lt;/h1&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Xv6" scheme="https://oz1010.github.com/categories/Xv6/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB使用说明</title>
    <link href="https://oz1010.github.com/2024/04/24/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://oz1010.github.com/2024/04/24/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2024-04-24T01:05:01.000Z</published>
    <updated>2026-01-21T06:34:01.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gdb-常用命令">GDB-常用命令</h1><p>打开GDB调试开关命令：<code>set debug remote 1</code></p><h1 id="gdb-远程序列化协议">GDB-远程序列化协议</h1><h2 id="简介">简介</h2><p>所有GDB命令和响应都是以包（packet）形式进行送。一个包的基本结构：<code>$包数据#2字节校验和</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$packet-data#checksum</span><br></pre></td></tr></table></figure><p>2字节校验和是计算<code>$</code>和<code>#</code>之间的所有字符数值和，并取模256后的两位十六进制数。</p><p>GDB 5.0之前的协议需要包含两字节序列编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sequence-id:packet-data#checksum</span><br></pre></td></tr></table></figure><p>当主机或目标机接收到第一个包，预期的一个响应是确认：可以是<code>+</code>（表明包接收正确）或<code>-</code>（请求重传）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; $packet-data#checksum</span><br><span class="line">&lt;- +</span><br></pre></td></tr></table></figure><p>连接一旦建立，可以禁用<code>+</code>/<code>-</code>确认。</p><p>主机（GDB）发送命令，而目标机（调试目标）发送响应。</p><p>包数据不能包含非法字符<code>#</code>和<code>$</code>。</p><p>若包数据中可以使用<code>,</code> <code>;</code>或<code>:</code>作为分隔符。除特别说明，所有数字均使用十六进制表示。</p><p>GDB5.0之前的协议不能使用<code>:</code>作为分隔符（与sequence-id的分隔符冲突）。</p><p>在许多包中二进制数据都以两位十六进制字符表示。</p><p>二进制数据<code>7d</code>（ASCII字符<code>&#125;</code>)作为转义字符。任何转义字符传输时需要跟一个与<code>0x20</code>异或后的结果。例如，单字节<code>0x7d</code>在传输时会转为两个字节<code>0x7d 0x5d</code>。常见的转义字符有<code>0x23 #</code><code>0x24 $</code> <code>0x7d &#125;</code> <code>0x2a *</code>。</p><p>响应数据可以使用运行长度编号来节省空间。例如：编号后<code>'0* '</code>表示编码字符串<code>'0000'</code>，<code>*</code>后面的空格表示重复<code>0</code>字符32-29=3次。</p><p>对于可打印字符<code>#</code>和<code>$</code>或数值超过126的都不可使用。对于7次重复（字符<code>$</code>）可以使用5次（字符<code>"</code>）来分开表示。例如，<code>'00000000'</code>编码后为<code>'0*"00'</code>。</p><p>对于不支持的命令，会返回空响应<code>$#00</code>。</p><p>在最小场景中，目标机必须支持<code>?</code>命令来告诉GDB停止的原因，<code>g</code>和<code>G</code>命令用于寄存器访问，<code>m</code>和<code>M</code>命令用于内存访问。对于单线程目标要实现<code>c</code>命令，并支持单步调试命令<code>s</code>。多线程目标需要支持<code>vCont</code>命令。其他所有命令都是可选的。</p><h2 id="包">包</h2><p>下表中，命令中的空格表示语义分隔，但实际数据包不需要发送。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th>命令</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>!</td><td>使能扩展模式</td></tr><tr class="even"><td>?</td><td>当连接第一次建立后，会被询问目标机停止的原因。回复与step和continue一样。</td></tr><tr class="odd"><td>A arglen,argnum,arg,…</td><td>初始化<code>argv[]</code>参数数组传递给程序。其中arglen是十六进制编码后的字节流参数arg的长度。</td></tr><tr class="even"><td>b baud</td><td>（不推荐使用）改变串行通信速率</td></tr><tr class="odd"><td>B addr,mode</td><td>（不推荐使用，使用Z和z包替代）设置(mode是S)或清除（mode是C）在addr处的断点。</td></tr><tr class="even"><td>bc</td><td>向后继续执行。目标系统反向执行。</td></tr><tr class="odd"><td>bs</td><td>向后单步执行。反向执行一条执行。</td></tr><tr class="even"><td>c [addr]</td><td>从addr处继续执行；addr省略时，从当前地址继续。</td></tr><tr class="odd"><td>C sig[;addr]</td><td>与c命令一样，额外可携带一个信号量sig（十六进制数）</td></tr><tr class="even"><td>d</td><td>（不推荐使用）其他调试标志</td></tr><tr class="odd"><td>D<br>D;pid</td><td>通知远端目标机GDB断开连接。第二种包含进程编号，只对特定的进程生效。</td></tr><tr class="even"><td>F RC,EE,CF;XX</td><td>文件I/O扩展协议命令</td></tr><tr class="odd"><td>g</td><td>读取通用寄存器<br>回复：‘XX…’<br>寄存器每个字节由两个十六进制表示。当目标寄存器不可用时，会使用字符<code>x</code>进行占位。</td></tr><tr class="even"><td>G XX…</td><td>写通用寄存器</td></tr><tr class="odd"><td>z0,addr,kind<br>Z0,addr,kind<br>[;con_list…]<br>[;cmds:persis,cmd_list]</td><td>插入（Z0）或移除（z0）在addr处kind类型的一个软件断点</td></tr><tr class="even"><td>z1,addr,kind<br>Z1,addr,kind<br>[;con_list…]<br>[;cmds:persis,cmd_list]</td><td>插入（Z1）或移除（z1）在addr处kind类型的一个硬件断点</td></tr><tr class="odd"><td>z2,addr,kind<br>Z2,addr,kind</td><td>插入（Z2）或移除（z2）在addr处的一个写监控点。监控的字节数由kind指定</td></tr><tr class="even"><td>z3,addr,kind<br>Z3,addr,kind</td><td>插入（Z3）或移除（z3）在addr处的一个读监控点。监控的字节数由kind指定</td></tr><tr class="odd"><td>z4,addr,kind<br>Z4,addr,kind</td><td>插入（Z4）或移除（z4）在addr处的一个访问监控点。监控的字节数由kind指定</td></tr><tr class="even"><td>…</td><td></td></tr></tbody></table><h2 id="停止回复包">停止回复包</h2><h2 id="通用包">通用包</h2><p>以<code>q</code>开头的是通用询问包；以<code>Q</code>开头的是通用设置包；</p><h2 id="参考">参考</h2><p>详见<a href="https://sourceware.org/gdb/download/onlinedocs/">官方文档</a>Appendix E gdb Remote Serial Protocol章节</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gdb-常用命令&quot;&gt;GDB-常用命令&lt;/h1&gt;
&lt;p&gt;打开GDB调试开关命令：&lt;code&gt;set debug remote 1&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;gdb-远程序列化协议&quot;&gt;GDB-远程序列化协议&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;</summary>
      
    
    
    
    <category term="GDB" scheme="https://oz1010.github.com/categories/GDB/"/>
    
    
    <category term="命令" scheme="https://oz1010.github.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Verilog-硬件描述语言使用</title>
    <link href="https://oz1010.github.com/2024/04/08/Verilog-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://oz1010.github.com/2024/04/08/Verilog-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/</id>
    <published>2024-04-08T03:34:41.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言简介">语言简介</h1><p>Verilog在线学习<a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits主页</a></p><h2 id="基本语句">基本语句</h2><h3 id="常量">常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3&#x27;b101 // binary 101</span><br><span class="line">4&#x27;hf // binary 1111</span><br><span class="line">4&#x27;d10// binary 1010</span><br></pre></td></tr></table></figure><h3 id="线wire">线wire</h3><p>物理线路没有方向，但建模上需要指定方向。</p><p>创造一个模型，有三个输入和四个输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; w</span><br><span class="line">b -&gt; x</span><br><span class="line">b -&gt; y</span><br><span class="line">c -&gt; z</span><br></pre></td></tr></table></figure><p><img src="https://hdlbits.01xz.net/mw/images/1/15/Wire4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input a,b,c,</span><br><span class="line">    output w,x,y,z );</span><br><span class="line">    </span><br><span class="line">    assign w=a;</span><br><span class="line">    assign x=b;</span><br><span class="line">    assign y=b;</span><br><span class="line">    assign z=c;</span><br><span class="line"></span><br><span class="line">// If we&#x27;re certain about the width of each signal, using </span><br><span class="line">// the concatenation operator is equivalent and shorter:</span><br><span class="line">// assign &#123;w,x,y,z&#125; = &#123;a,b,b,c&#125;;</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非门inverter">非门Inverter</h3><p>电路中产生一个非门</p><p><img src="https://hdlbits.01xz.net/mw/images/9/9e/Notgate.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module top_module( input in, output out );</span><br><span class="line">assign out = !in;</span><br><span class="line">// similar</span><br><span class="line">// assign out = ~in;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="与门and-gate">与门AND gate</h3><p>电路中产生一个与门</p><p><img src="https://hdlbits.01xz.net/mw/images/7/78/Andgate.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input a, </span><br><span class="line">    input b, </span><br><span class="line">    output out );</span><br><span class="line"></span><br><span class="line">    assign out = a &amp; b;</span><br><span class="line">    </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="或非门nor-gate">或非门Nor gate</h3><p>电路中产生一个或非门</p><p><img src="https://hdlbits.01xz.net/mw/images/5/5b/Norgate.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input a, </span><br><span class="line">    input b, </span><br><span class="line">    output out );</span><br><span class="line"></span><br><span class="line">    assign out = ~(a | b);</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异或非门xnor-gate">异或非门XNOR gate</h3><p>电路中产生一个异或非门</p><p><img src="https://hdlbits.01xz.net/mw/images/6/6d/Xnorgate.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input a, </span><br><span class="line">    input b, </span><br><span class="line">    output out );</span><br><span class="line"></span><br><span class="line">    assign out = ~(a ^ b);</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="声明线declaring-wires">声明线Declaring wires</h3><p><img src="https://hdlbits.01xz.net/mw/images/3/3a/Wiredecl2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">`default_nettype none</span><br><span class="line">module top_module(</span><br><span class="line">    input a,</span><br><span class="line">    input b,</span><br><span class="line">    input c,</span><br><span class="line">    input d,</span><br><span class="line">    output out,</span><br><span class="line">    output out_n   ); </span><br><span class="line"></span><br><span class="line">    wire w1, w2, w3;    </span><br><span class="line">    assign out = w3;</span><br><span class="line">    assign out_n = ~w3;</span><br><span class="line">  </span><br><span class="line">    assign w3 = w1 | w2;</span><br><span class="line">    assign w1 = a &amp; b;</span><br><span class="line">    assign w2 = c &amp; d;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="芯片">7458芯片</h3><p><img src="https://hdlbits.01xz.net/mw/images/e/e1/7458.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module top_module ( </span><br><span class="line">    input p1a, p1b, p1c, p1d, p1e, p1f,</span><br><span class="line">    output p1y,</span><br><span class="line">    input p2a, p2b, p2c, p2d,</span><br><span class="line">    output p2y );</span><br><span class="line"></span><br><span class="line">wire wp11,wp12;</span><br><span class="line">    assign p1y = wp11 | wp12;</span><br><span class="line">    assign wp11 = p1a &amp; p1b &amp; p1c;</span><br><span class="line">    assign wp12 = p1f &amp; p1e &amp; p1d;</span><br><span class="line">    </span><br><span class="line">    wire wp21,wp22;</span><br><span class="line">    assign p2y = wp21 | wp22;</span><br><span class="line">    assign wp21 = p2a &amp; p2b;</span><br><span class="line">    assign wp22 = p2c &amp; p2d;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="向量vector">向量Vector</h2><h3 id="基本使用">基本使用</h3><p>声明语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type [upper:lower] vector_name;</span><br></pre></td></tr></table></figure><p>类型可以是wire, reg等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wire [7:0] w;         // 8-bit wire</span><br><span class="line">reg  [4:1] x;         // 4-bit reg</span><br><span class="line">output reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)</span><br><span class="line">input wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)</span><br><span class="line">output [3:0] a;       // 4-bit output wire. Type is &#x27;wire&#x27; unless specified otherwise.</span><br><span class="line">wire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.</span><br></pre></td></tr></table></figure><p>隐含声明可能导致意想不到的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wire [2:0] a, c;   // Two vectors</span><br><span class="line">assign a = 3&#x27;b101;  // a = 101</span><br><span class="line">assign b = a;       // b =   1  implicitly-created wire</span><br><span class="line">assign c = b;       // c = 001  &lt;-- bug</span><br><span class="line">my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.</span><br><span class="line">                    // This could be a bug if the port was intended to be a </span><br></pre></td></tr></table></figure><p>unpacked数组维度跟在名称后，packed数组维度放在名称前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg [7:0] mem [255:0];   // 256 unpacked elements, each of which is a 8-bit packed vector of reg.</span><br><span class="line">reg mem2 [28:0];         // 29 unpacked elements, each of which is a 1-bit reg.</span><br></pre></td></tr></table></figure><p>描绘如下电路</p><p><img src="https://hdlbits.01xz.net/mw/images/a/ae/Vector0.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module top_module ( </span><br><span class="line">    input wire [2:0] vec,</span><br><span class="line">    output wire [2:0] outv,</span><br><span class="line">    output wire o2,</span><br><span class="line">    output wire o1,</span><br><span class="line">    output wire o0  ); // Module body starts after module declaration</span><br><span class="line"></span><br><span class="line">    assign &#123;o2,o1,o0&#125; = vec[2:0];</span><br><span class="line">    assign outv = vec;</span><br><span class="line">    </span><br><span class="line">    // This is ok too</span><br><span class="line">   //assign o0 = vec[0];</span><br><span class="line">//assign o1 = vec[1];</span><br><span class="line">//assign o2 = vec[2];</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将字数据（2字节）按高低位分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">`default_nettype none     // Disable implicit nets. Reduces some types of bugs.</span><br><span class="line">module top_module( </span><br><span class="line">    input wire [15:0] in,</span><br><span class="line">    output wire [7:0] out_hi,</span><br><span class="line">    output wire [7:0] out_lo );</span><br><span class="line"></span><br><span class="line">    assign out_hi = in[15:8];</span><br><span class="line">    assign out_lo = in[7:0];</span><br><span class="line">    </span><br><span class="line">    // Concatenation operator also works: assign &#123;out_hi, out_lo&#125; = in;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="向量门">向量门</h3><p>按位与<code>&amp;</code>和逻辑与<code>&amp;</code>对于N-bit位输入来说，会产生不同结果。前者会产生N-bit位输出，而后者只产生1-bit位输出（作为布尔值，非0值为true，0值为false）。</p><p>描绘如下电路，<code>out_not</code>高5-3位为<code>b</code>的非，其余为<code>a</code>的非。</p><p><img src="https://hdlbits.01xz.net/mw/images/1/1b/Vectorgates.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input [2:0] a,</span><br><span class="line">    input [2:0] b,</span><br><span class="line">    output [2:0] out_or_bitwise,</span><br><span class="line">    output out_or_logical,</span><br><span class="line">    output [5:0] out_not</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    assign out_or_bitwise = a | b;</span><br><span class="line">    assign out_or_logical = a || b;</span><br><span class="line">    // ! is logical inverse</span><br><span class="line">    assign out_not = &#123;~b, ~a&#125;;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="颠倒8位">颠倒8位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input [7:0] in,</span><br><span class="line">output [7:0] out</span><br><span class="line">);</span><br><span class="line">assign out = &#123;in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]&#125;;</span><br><span class="line">//assign &#123;out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]&#125; = in;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">// I know you&#x27;re dying to know how to use a loop to do this:</span><br><span class="line"></span><br><span class="line">// Create a combinational always block. This creates combinational logic that computes the same result</span><br><span class="line">// as sequential code. for-loops describe circuit *behaviour*, not *structure*, so they can only be used </span><br><span class="line">// inside procedural blocks (e.g., always block).</span><br><span class="line">// The circuit created (wires and gates) does NOT do any iteration: It only produces the same result</span><br><span class="line">// AS IF the iteration occurred. In reality, a logic synthesizer will do the iteration at compile time to</span><br><span class="line">// figure out what circuit to produce. (In contrast, a Verilog simulator will execute the loop sequentially</span><br><span class="line">// during simulation.)</span><br><span class="line">always @(*) begin</span><br><span class="line">for (int i=0; i&lt;8; i++)// int is a SystemVerilog type. Use integer for pure Verilog.</span><br><span class="line">out[i] = in[8-i-1];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// It is also possible to do this with a generate-for loop. Generate loops look like procedural for loops,</span><br><span class="line">// but are quite different in concept, and not easy to understand. Generate loops are used to make instantiations</span><br><span class="line">// of &quot;things&quot; (Unlike procedural loops, it doesn&#x27;t describe actions). These &quot;things&quot; are assign statements,</span><br><span class="line">// module instantiations, net/variable declarations, and procedural blocks (things you can create when NOT inside </span><br><span class="line">// a procedure). Generate loops (and genvars) are evaluated entirely at compile time. You can think of generate</span><br><span class="line">// blocks as a form of preprocessing to generate more code, which is then run though the logic synthesizer.</span><br><span class="line">// In the example below, the generate-for loop first creates 8 assign statements at compile time, which is then</span><br><span class="line">// synthesized.</span><br><span class="line">// Note that because of its intended usage (generating code at compile time), there are some restrictions</span><br><span class="line">// on how you use them. Examples: 1. Quartus requires a generate-for loop to have a named begin-end block</span><br><span class="line">// attached (in this example, named &quot;my_block_name&quot;). 2. Inside the loop body, genvars are read only.</span><br><span class="line">generate</span><br><span class="line">genvar i;</span><br><span class="line">for (i=0; i&lt;8; i = i+1) begin: my_block_name</span><br><span class="line">assign out[i] = in[8-i-1];</span><br><span class="line">end</span><br><span class="line">endgenerate</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="重复操作">重复操作</h3><p>声明语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;num&#123;vector&#125;&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;5&#123;1&#x27;b1&#125;&#125;           // 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span><br><span class="line">&#123;2&#123;a,b,c&#125;&#125;          // The same as &#123;a,b,c,a,b,c&#125;</span><br><span class="line">&#123;3&#x27;d5, &#123;2&#123;3&#x27;d6&#125;&#125;&#125;   // 9&#x27;b101_110_110. It&#x27;s a concatenation of 101 with</span><br><span class="line">                    // the second vector, which is two copies of 3&#x27;b110.</span><br></pre></td></tr></table></figure><p>将8位数据扩展为32位，高24位为符号位（bit[7]），余下8位为输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input [7:0] in,</span><br><span class="line">output [31:0] out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Concatenate two things together:</span><br><span class="line">// 1: &#123;in[7]&#125; repeated 24 times (24 bits)</span><br><span class="line">// 2: in[7:0] (8 bits)</span><br><span class="line">assign out = &#123; &#123;24&#123;in[7]&#125;&#125;, in &#125;;</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>描述电路</p><p><img src="https://hdlbits.01xz.net/mw/images/a/ac/Vector5.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input a, b, c, d, e,</span><br><span class="line">output [24:0] out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire [24:0] top, bottom;</span><br><span class="line">assign top    = &#123; &#123;5&#123;a&#125;&#125;, &#123;5&#123;b&#125;&#125;, &#123;5&#123;c&#125;&#125;, &#123;5&#123;d&#125;&#125;, &#123;5&#123;e&#125;&#125; &#125;;</span><br><span class="line">assign bottom = &#123;5&#123;a,b,c,d,e&#125;&#125;;</span><br><span class="line">assign out = ~top ^ bottom;// Bitwise XNOR</span><br><span class="line"></span><br><span class="line">// This could be done on one line:</span><br><span class="line">// assign out = ~&#123; &#123;5&#123;a&#125;&#125;, &#123;5&#123;b&#125;&#125;, &#123;5&#123;c&#125;&#125;, &#123;5&#123;d&#125;&#125;, &#123;5&#123;e&#125;&#125; &#125; ^ &#123;5&#123;a,b,c,d,e&#125;&#125;;</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模块module">模块Module</h2><h3 id="基本使用-1">基本使用</h3><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mod_a ( input in1, input in2, output out );</span><br><span class="line">    // Module body</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>线与模块端口连接有两种方式：通过位置和通过名称</p><p>通过位置连接，模块实例<code>instance1</code>三个端口分别连接线<code>wa</code>,<code>wb</code>, <code>wc</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_a instance1 ( wa, wb, wc );</span><br></pre></td></tr></table></figure><p>通过名称连接，模块实例<code>instance2</code>三个端口名称与对应线连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );</span><br></pre></td></tr></table></figure><p>描述电路，其中模块<code>mod_a</code>在其他地方描述</p><p><img src="https://hdlbits.01xz.net/mw/images/c/c0/Module.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input a,</span><br><span class="line">input b,</span><br><span class="line">output out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Create an instance of &quot;mod_a&quot; named &quot;inst1&quot;, and connect ports by name:</span><br><span class="line">mod_a inst1 ( </span><br><span class="line">.in1(a), // Port&quot;in1&quot;connects to wire &quot;a&quot;</span><br><span class="line">.in2(b),// Port &quot;in2&quot; connects to wire &quot;b&quot;</span><br><span class="line">.out(out)// Port &quot;out&quot; connects to wire &quot;out&quot; </span><br><span class="line">// (Note: mod_a&#x27;s port &quot;out&quot; is not related to top_module&#x27;s wire &quot;out&quot;. </span><br><span class="line">// It is simply coincidence that they have the same name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">// Create an instance of &quot;mod_a&quot; named &quot;inst2&quot;, and connect ports by position:</span><br><span class="line">mod_a inst2 ( a, b, out );// The three wires are connected to ports in1, in2, and out, respectively.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="移位模块">移位模块</h3><p>给已经实现的D触发器（Dflip-flop）模块<code>module my_dff ( input clk, input d, output q );</code>，按下图描述电路</p><p><img src="https://hdlbits.01xz.net/mw/images/6/60/Module_shift.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module top_module ( input clk, input d, output q );</span><br><span class="line">    wire q1,q2;</span><br><span class="line">    </span><br><span class="line">    my_dff d1 (clk, d, q1);</span><br><span class="line">    my_dff d2 (clk, q1, q2);</span><br><span class="line">    my_dff d3 (clk, q2, q);</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="位移位器">8位移位器</h3><p>描绘电路</p><p><img src="https://hdlbits.01xz.net/mw/images/7/76/Module_shift8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input clk,</span><br><span class="line">input [7:0] d,</span><br><span class="line">input [1:0] sel,</span><br><span class="line">output reg [7:0] q</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire [7:0] o1, o2, o3;// output of each my_dff8</span><br><span class="line"></span><br><span class="line">// Instantiate three my_dff8s</span><br><span class="line">my_dff8 d1 ( clk, d, o1 );</span><br><span class="line">my_dff8 d2 ( clk, o1, o2 );</span><br><span class="line">my_dff8 d3 ( clk, o2, o3 );</span><br><span class="line"></span><br><span class="line">// This is one way to make a 4-to-1 multiplexer</span><br><span class="line">always @(*) begin// Combinational always block</span><br><span class="line">case(sel)</span><br><span class="line">2&#x27;h0: q = d;</span><br><span class="line">2&#x27;h1: q = o1;</span><br><span class="line">2&#x27;h2: q = o2;</span><br><span class="line">2&#x27;h3: q = o3;</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="全加器">全加器</h3><p>add16全加器已经定义<code>module add16 ( input[15:0] **a**, input[15:0] **b**, input **cin**, output[15:0] **sum**, output **cout** );</code>，它包含16个add1全加器，描述电路</p><p><img src="https://hdlbits.01xz.net/mw/images/f/f3/Module_fadd.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">    input [31:0] a,</span><br><span class="line">    input [31:0] b,</span><br><span class="line">    output [31:0] sum</span><br><span class="line">);</span><br><span class="line">wire o1,o2;</span><br><span class="line">    </span><br><span class="line">    add16 inst1(a[15:0],b[15:0],0,sum[15:0],o1);</span><br><span class="line">    add16 inst2(a[31:16],b[31:16],o1,sum[31:16],o2);</span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">module add1 ( input a, input b, input cin,   output sum, output cout );</span><br><span class="line">// Full adder module here</span><br><span class="line">    assign sum = cin ? ~(a^b) : a^b;</span><br><span class="line">    assign cout = cin ? a|b : a&amp;b;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="加减器">加减器</h3><p>减法器由全加器变化而来，只需将对第二个操作数取补码即可（反码加一）。等效的电路可以有两种效果：<code>a+b+0</code>和<code>a+~b+1</code>。</p><p><img src="https://hdlbits.01xz.net/mw/images/a/ae/Module_addsub.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module top_module(</span><br><span class="line">    input [31:0] a,</span><br><span class="line">    input [31:0] b,</span><br><span class="line">    input sub,</span><br><span class="line">    output [31:0] sum</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    wire o1,o2;</span><br><span class="line">    wire [31:0] b1 = b^&#123;32&#123;sub&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    add16 inst1(a[15:0],b1[15:0],sub,sum[15:0],o1);</span><br><span class="line">    add16 inst2(a[31:16],b1[31:16],o1,sum[31:16],o2);</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="过程procedure">过程Procedure</h2><p>对于综合硬件，有两种相关always块：</p><ul><li>组合型：<code>always @(*)</code></li><li>时序型：<code>always @(posedge clk)</code></li></ul><p>块语句需要使用<code>begin</code>和<code>end</code>标记出来，若语句只有“单句”时，块标记可以省略。</p><h3 id="always块">Always块</h3><p>对于简单的场景，组合型always块等价于assign语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assign out1 = a &amp; b | c ^ d;</span><br><span class="line">always @(*) out2 = a &amp; b | c ^ d;</span><br></pre></td></tr></table></figure><p>assign语句左边符号对应的类型是net（例如：wire），而过程赋值对应的类型是variable（例如：reg）。两者的差异不会对综合的电路产生任何影响，只是一种不成文的约定。</p><p>在VHDL中有三种赋值类型：</p><ul><li>持续赋值<code>assign x = y;</code></li><li>过程阻塞赋值，在过程中使用<code>x = y;</code></li><li>过程非阻塞赋值，在过程中使用<code>x &lt;= y;</code></li></ul><p>在组合alsways块中，使用阻塞赋值。在时序always块中，使用非阻塞赋值。</p><p>使用三种方式，用异或门构建电路。值得注意的是，第三种方式产生的结果会因为有触发器而产生延时。</p><p><img src="https://hdlbits.01xz.net/mw/images/4/40/Alwaysff.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module(</span><br><span class="line">    input clk,</span><br><span class="line">    input a,</span><br><span class="line">    input b,</span><br><span class="line">    output wire out_assign,</span><br><span class="line">    output reg out_always_comb,</span><br><span class="line">    output reg out_always_ff   );</span><br><span class="line"></span><br><span class="line">    assign out_assign = a^b;</span><br><span class="line">    always @(*) out_always_comb = a^b;</span><br><span class="line">    always @(posedge clk) out_always_ff &lt;= a^b;</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if语句">if语句</h3><p>描绘一个2-1选择器</p><p><img src="https://hdlbits.01xz.net/mw/images/9/9d/Always_if_mux.png"></p><p>对应的值表</p><table><thead><tr class="header"><th style="text-align: left;">sel_b1</th><th style="text-align: left;">sel_b2</th><th style="text-align: left;">out_assign out_always</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;">0</td><td style="text-align: left;">a</td></tr><tr class="even"><td style="text-align: left;">0</td><td style="text-align: left;">1</td><td style="text-align: left;">a</td></tr><tr class="odd"><td style="text-align: left;">1</td><td style="text-align: left;">0</td><td style="text-align: left;">a</td></tr><tr class="even"><td style="text-align: left;">1</td><td style="text-align: left;">1</td><td style="text-align: left;">b</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module(</span><br><span class="line">    input a,</span><br><span class="line">    input b,</span><br><span class="line">    input sel_b1,</span><br><span class="line">    input sel_b2,</span><br><span class="line">    output wire out_assign,</span><br><span class="line">    output reg out_always   ); </span><br><span class="line"></span><br><span class="line">    assign out_assign = sel_b1&amp;sel_b2 ? b : a;</span><br><span class="line">    </span><br><span class="line">    always @(*) begin</span><br><span class="line">        if (sel_b1&amp;sel_b2) begin</span><br><span class="line">            out_always = b;</span><br><span class="line">        end</span><br><span class="line">        else begin</span><br><span class="line">            out_always = a;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if语句锁存">if语句锁存</h3><p>修复下图错误，当<code>cpu_overheated</code>时，产生关闭信号（<code>shut_off_computer</code>设置为1）。</p><p>修改前，错误的示意图</p><p><img src="https://hdlbits.01xz.net/mw/images/d/d1/Always_if2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module (</span><br><span class="line">    input      cpu_overheated,</span><br><span class="line">    output reg shut_off_computer,</span><br><span class="line">    input      arrived,</span><br><span class="line">    input      gas_tank_empty,</span><br><span class="line">    output reg keep_driving  ); //</span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        if (cpu_overheated)</span><br><span class="line">           shut_off_computer = 1;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        if (~arrived)</span><br><span class="line">           keep_driving = ~gas_tank_empty;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module (</span><br><span class="line">    input      cpu_overheated,</span><br><span class="line">    output reg shut_off_computer,</span><br><span class="line">    input      arrived,</span><br><span class="line">    input      gas_tank_empty,</span><br><span class="line">    output reg keep_driving  ); //</span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        if (cpu_overheated)</span><br><span class="line">           shut_off_computer = 1;</span><br><span class="line">        else</span><br><span class="line">           shut_off_computer = 0;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        if (~arrived)</span><br><span class="line">           keep_driving = ~gas_tank_empty;</span><br><span class="line">        else</span><br><span class="line">           keep_driving = 0;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="case语句">case语句</h3><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case (cond)</span><br><span class="line">2&#x27;h0: statments0;</span><br><span class="line">2&#x27;h1: statments1;</span><br><span class="line">...</span><br><span class="line">default: statmentsx;</span><br><span class="line">endcase</span><br></pre></td></tr></table></figure><p>建立一个6-1选择器，否则输出0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module ( </span><br><span class="line">    input [2:0] sel, </span><br><span class="line">    input [3:0] data0,</span><br><span class="line">    input [3:0] data1,</span><br><span class="line">    input [3:0] data2,</span><br><span class="line">    input [3:0] data3,</span><br><span class="line">    input [3:0] data4,</span><br><span class="line">    input [3:0] data5,</span><br><span class="line">    output reg [3:0] out   );//</span><br><span class="line"></span><br><span class="line">    always@(*) begin  // This is a combinational circuit</span><br><span class="line">        case(sel)</span><br><span class="line">            4&#x27;h0: out = data0;</span><br><span class="line">            4&#x27;h1: out = data1;</span><br><span class="line">            4&#x27;h2: out = data2;</span><br><span class="line">            4&#x27;h3: out = data3;</span><br><span class="line">            4&#x27;h4: out = data4;</span><br><span class="line">            4&#x27;h5: out = data5;</span><br><span class="line">            default: out = 0;</span><br><span class="line">        endcase</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构建一个4bits的优先编码器，输出第一个1所在的比特位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input [3:0] in,</span><br><span class="line">output reg [1:0] pos</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(*) begin// Combinational always block</span><br><span class="line">case (in)</span><br><span class="line">4&#x27;h0: pos = 2&#x27;h0;// I like hexadecimal because it saves typing.</span><br><span class="line">4&#x27;h1: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;h2: pos = 2&#x27;h1;</span><br><span class="line">4&#x27;h3: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;h4: pos = 2&#x27;h2;</span><br><span class="line">4&#x27;h5: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;h6: pos = 2&#x27;h1;</span><br><span class="line">4&#x27;h7: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;h8: pos = 2&#x27;h3;</span><br><span class="line">4&#x27;h9: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;ha: pos = 2&#x27;h1;</span><br><span class="line">4&#x27;hb: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;hc: pos = 2&#x27;h2;</span><br><span class="line">4&#x27;hd: pos = 2&#x27;h0;</span><br><span class="line">4&#x27;he: pos = 2&#x27;h1;</span><br><span class="line">4&#x27;hf: pos = 2&#x27;h0;</span><br><span class="line">default: pos = 2&#x27;b0;// Default case is not strictly necessary because all 16 combinations are covered.</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">// There is an easier way to code this. See the next problem (always_casez).</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="casez">casez</h3><p>当部分比特位不关心时，可以使用<code>casez</code>。符号<code>z</code>和<code>?</code>在一下场景都是等价的。与<code>casez</code>类似的是<code>casex</code>，后者使用符号<code>x</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">always @(*) begin</span><br><span class="line">    casez (in[3:0])</span><br><span class="line">        4&#x27;bzzz1: out = 0;   // in[3:1] can be anything</span><br><span class="line">        4&#x27;bzz1z: out = 1;</span><br><span class="line">        4&#x27;b?1??: out = 2;</span><br><span class="line">        4&#x27;b1???: out = 3;</span><br><span class="line">        default: out = 0;</span><br><span class="line">    endcase</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>构建8bits优先编码器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module (</span><br><span class="line">    input [7:0] in,</span><br><span class="line">    output reg [2:0] pos );</span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        casez (in[7:0])</span><br><span class="line">            8&#x27;h0: pos = 0;</span><br><span class="line">            8&#x27;bzzzz_???1: pos = 0;</span><br><span class="line">            8&#x27;bzzzz_zz10: pos = 1;</span><br><span class="line">            8&#x27;bzzzz_z100: pos = 2;</span><br><span class="line">            8&#x27;bzzzz_1000: pos = 3;</span><br><span class="line">            8&#x27;bzzz1_0000: pos = 4;</span><br><span class="line">            8&#x27;bzz10_0000: pos = 5;</span><br><span class="line">            8&#x27;bz100_0000: pos = 6;</span><br><span class="line">            8&#x27;b1000_0000: pos = 7;</span><br><span class="line">            default: pos = 3&#x27;bzzz;</span><br><span class="line">        endcase</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="键盘扫描码">键盘扫描码</h3><p>处理如下四个按键</p><table><thead><tr class="header"><th style="text-align: left;">Scancode [15:0]</th><th style="text-align: left;">Arrow key</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>16'he06b</code></td><td style="text-align: left;">left arrow</td></tr><tr class="even"><td style="text-align: left;"><code>16'he072</code></td><td style="text-align: left;">down arrow</td></tr><tr class="odd"><td style="text-align: left;"><code>16'he074</code></td><td style="text-align: left;">right arrow</td></tr><tr class="even"><td style="text-align: left;"><code>16'he075</code></td><td style="text-align: left;">up arrow</td></tr><tr class="odd"><td style="text-align: left;">Anything else</td><td style="text-align: left;">none</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// synthesis verilog_input_version verilog_2001</span><br><span class="line">module top_module (</span><br><span class="line">    input [15:0] scancode,</span><br><span class="line">    output reg left,</span><br><span class="line">    output reg down,</span><br><span class="line">    output reg right,</span><br><span class="line">    output reg up  ); </span><br><span class="line"></span><br><span class="line">    always @(*) begin</span><br><span class="line">        left = 0; down = 0; right = 0; up = 0;</span><br><span class="line">        case (scancode)</span><br><span class="line">            16&#x27;he06b: left = 1;</span><br><span class="line">            16&#x27;he072: down = 1;</span><br><span class="line">            16&#x27;he074: right = 1;</span><br><span class="line">            16&#x27;he075: up = 1;</span><br><span class="line">            default: ;</span><br><span class="line">        endcase</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="更多特性">更多特性</h2><h3 id="条件">条件</h3><p>三元条件操作符<code>?:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(condition ? if_true : if_false)</span><br></pre></td></tr></table></figure><h3 id="逻辑操作简化">逻辑操作简化</h3><p>若需要对向量所有位进行门操作时，正常书写比较冗余，可以对与、或和异或操作简化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp; a[3:0]     // AND: a[3]&amp;a[2]&amp;a[1]&amp;a[0]. Equivalent to (a[3:0] == 4&#x27;hf)</span><br><span class="line">| b[3:0]     // OR:  b[3]|b[2]|b[1]|b[0]. Equivalent to (b[3:0] != 4&#x27;h0)</span><br><span class="line">^ c[2:0]     // XOR: c[2]^c[1]^c[0]</span><br></pre></td></tr></table></figure><p>实现奇偶校验位算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">    input [7:0] in,</span><br><span class="line">    output parity); </span><br><span class="line"></span><br><span class="line">    assign parity = ^in[7:0];</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bits翻转">100bits翻转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input [99:0] in,</span><br><span class="line">output reg [99:0] out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(*) begin</span><br><span class="line">for (int i=0;i&lt;$bits(out);i++)// $bits() is a system function that returns the width of a signal.</span><br><span class="line">out[i] = in[$bits(out)-i-1];// $bits(out) is 100 because out is 100 bits wide.</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="比特1计数">比特1计数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input [254:0] in,</span><br><span class="line">    output [7:0] out );</span><br><span class="line"></span><br><span class="line">    always @(*) begin// Combinational always block</span><br><span class="line">        out = 0;</span><br><span class="line">        for (int i=0; i&lt;$bits(in); i++)</span><br><span class="line">            out += in[i];</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bits全加器">100bits全加器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input [99:0] a, b,</span><br><span class="line">    input cin,</span><br><span class="line">    output [99:0] cout,</span><br><span class="line">    output [99:0] sum );</span><br><span class="line">    </span><br><span class="line">genvar i;</span><br><span class="line">generate</span><br><span class="line">    for (i=0; i&lt;$bits(a); ++i) begin: adder_gen</span><br><span class="line">        adder_1bit u_adder (</span><br><span class="line">            .a(a[i]),</span><br><span class="line">            .b(b[i]),</span><br><span class="line">            .cin(i==0?cin:cout[i-1]),</span><br><span class="line">            .sum(sum[i]),</span><br><span class="line">            .cout(cout[i])</span><br><span class="line">        );</span><br><span class="line">    end</span><br><span class="line">endgenerate</span><br><span class="line">    </span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">module adder_1bit (</span><br><span class="line">    input a,b,</span><br><span class="line">    input cin,</span><br><span class="line">    output cout,</span><br><span class="line">    output sum</span><br><span class="line">);</span><br><span class="line">    assign &#123;cout,sum&#125; = a+b+cin;</span><br><span class="line">    // assign sum = cin ? ~(a^b) : a^b;</span><br><span class="line">    // assign cout = cin ? a|b : a&amp;b;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="位bcd码全加器">100位BCD码全加器</h3><p>已经定义1位BCD码全加器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module bcd_fadd (</span><br><span class="line">    input [3:0] a,</span><br><span class="line">    input [3:0] b,</span><br><span class="line">    input     cin,</span><br><span class="line">    output   cout,</span><br><span class="line">    output [3:0] sum );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input [399:0] a, b,</span><br><span class="line">    input cin,</span><br><span class="line">    output cout,</span><br><span class="line">    output [399:0] sum );</span><br><span class="line"></span><br><span class="line">    wire [100:0] c;</span><br><span class="line">    assign cout = c[100];</span><br><span class="line">    assign c[0] = cin;</span><br><span class="line"></span><br><span class="line">    genvar i;</span><br><span class="line">    generate</span><br><span class="line">        for(i=0; i&lt;100; ++i) begin: bcd_gen</span><br><span class="line">            bcd_fadd u_bcd (</span><br><span class="line">                .a( a[(4*i+3):(4*i)] ),</span><br><span class="line">                .b( b[(4*i+3):(4*i)] ),</span><br><span class="line">                .cin( c[i] ),</span><br><span class="line">                .cout( c[i+1] ),</span><br><span class="line">                .sum( sum[(4*i+3):(4*i)] )</span><br><span class="line">            );</span><br><span class="line">        end</span><br><span class="line">    endgenerate</span><br><span class="line">    </span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="仿真">仿真</h2><h3 id="timescale">timescale</h3><p>定义仿真中时间单位的比例。它的作用是指定时序仿真中时间单位的大小，以便仿真器可以正确地模拟设计中的时序行为。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`timescale unit / precision</span><br></pre></td></tr></table></figure><p>其中，<code>unit</code>是时间单位，可以是<code>1ns</code>、<code>1ps</code>、<code>1us</code>等，表示一个时钟周期的时间长度；<code>precision</code>是时间精度，表示仿真的最小时间单位；</p><h3 id="num">#num</h3><p>等待num个时间单位后，执行后面的语句。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#num statement</span><br></pre></td></tr></table></figure><h3 id="task">task</h3><p>Verilog语言中具有类似C语言函数的结构有task和function，他们可以增加代码可读性和重复使用性。Function用来描述组合逻辑，只能有一个返回值，function的内部不能包含时序控制。Task类似procedure，执行一段verilog代码，task中可以有任意数量的输入和输出，task也可以包含时序控制。</p><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task TASK_NAME;</span><br><span class="line">endtask</span><br></pre></td></tr></table></figure><h3 id="ps2键盘设备仿真">PS/2键盘设备仿真</h3><p>当用户按键或松开时，键盘以每帧11位的格式串行传送数据给主机，同时在PS2_CLK时钟信号上传输对应的时钟（一般为10.0–16.7kHz）。第一位是开始位（逻辑0），后面跟8位数据位（低位在前），一个奇偶校验位（奇校验）和一位停止位（逻辑1）。每位都在时钟的<strong>下降沿</strong>有效，下图显示了键盘传送一字节数据的时序。在下降沿有效的主要原因是下降沿正好在数据位的中间，因此可以让数据位从开始变化到接收采样时能有一段信号建立时间。</p><figure><img src="https://nju-projectn.github.io/dlco-lecture-note/_images/ps01.png" alt="键盘输出数据时序图"><figcaption aria-hidden="true">键盘输出数据时序图</figcaption></figure><p>键盘通过PS2_DAT引脚发送的信息称为扫描码，每个扫描码可以由单个数据帧或连续多个数据帧构成。当按键被按下时送出的扫描码被称为<code>通码（Make Code）</code> ，当按键被释放时送出的扫描码称为<code>断码（Break Code）</code> 。以 <code>W</code> 键为例，<code>W</code> 键的通码是1Dh，如果 <code>W</code>键被按下，则PS2_DAT引脚将输出一帧数据，其中的8位数据位为1Dh，如果<code>W</code> 键一直没有释放，则不断输出扫描码1Dh 1Dh …1Dh，直到有其他键按下或者 <code>W</code>键被放开。某按键的断码是F0h加此按键的通码，如释放 <code>W</code>键时输出的断码为F0h 1Dh，分两帧传输。</p><p>多个键被同时按下时，将逐个输出扫描码，如：先按左 <code>Shift</code>键（扫描码为12h）、再按 <code>W</code> 键、放开 <code>W</code>键、再放开左 <code>Shift</code> 键，则此过程送出的全部扫描码为：12h 1DhF0h 1Dh F0h 12h。</p><p><strong>键盘扫描码</strong></p><p>每个键都有唯一的通码和断码。键盘所有键的扫描码组成的集合称为扫描码集。共有三套标准的扫描码集，所有现代的键盘默认使用第二套扫描码。下图显示了键盘各键的扫描码（以十六进制表示），如Caps键的扫描码是58h。下图可以看出，键盘上各按键的扫描码是随机排列的，如果想迅速的将键盘扫描码转换为ASCII码，一个最简单的方法就是利用查找表<a href="https://en.wikipedia.org/wiki/Lookup_table">LookUp Table,LUT</a> ，扫描码到ASCII码的转换表格请读者自己生成。</p><figure><img src="https://nju-projectn.github.io/dlco-lecture-note/_images/ps02.png" alt="键盘扫描码"><figcaption aria-hidden="true">键盘扫描码</figcaption></figure><figure><img src="https://nju-projectn.github.io/dlco-lecture-note/_images/ps03.png" alt="扩展键盘和数字键盘的扫描码"><figcaption aria-hidden="true">扩展键盘和数字键盘的扫描码</figcaption></figure><p>键盘控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">module ps2_keyboard(clk,clrn,ps2_clk,ps2_data,data,</span><br><span class="line">                    ready,nextdata_n,overflow);</span><br><span class="line">    input clk,clrn,ps2_clk,ps2_data;</span><br><span class="line">    input nextdata_n;</span><br><span class="line">    output [7:0] data;</span><br><span class="line">    output reg ready;</span><br><span class="line">    output reg overflow;     // fifo overflow</span><br><span class="line">    // internal signal, for test</span><br><span class="line">    reg [9:0] buffer;        // ps2_data bits</span><br><span class="line">    reg [7:0] fifo[7:0];     // data fifo</span><br><span class="line">    reg [2:0] w_ptr,r_ptr;   // fifo write and read pointers</span><br><span class="line">    reg [3:0] count;  // count ps2_data bits</span><br><span class="line">    // detect falling edge of ps2_clk</span><br><span class="line">    reg [2:0] ps2_clk_sync;</span><br><span class="line"></span><br><span class="line">    always @(posedge clk) begin</span><br><span class="line">        ps2_clk_sync &lt;=  &#123;ps2_clk_sync[1:0],ps2_clk&#125;;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    wire sampling = ps2_clk_sync[2] &amp; ~ps2_clk_sync[1];</span><br><span class="line"></span><br><span class="line">    always @(posedge clk) begin</span><br><span class="line">        if (clrn == 0) begin // reset</span><br><span class="line">            count &lt;= 0; w_ptr &lt;= 0; r_ptr &lt;= 0; overflow &lt;= 0; ready&lt;= 0;</span><br><span class="line">        end</span><br><span class="line">        else begin</span><br><span class="line">            if ( ready ) begin // read to output next data</span><br><span class="line">                if(nextdata_n == 1&#x27;b0) //read next data</span><br><span class="line">                begin</span><br><span class="line">                    r_ptr &lt;= r_ptr + 3&#x27;b1;</span><br><span class="line">                    if(w_ptr==(r_ptr+1&#x27;b1)) //empty</span><br><span class="line">                        ready &lt;= 1&#x27;b0;</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            if (sampling) begin</span><br><span class="line">              if (count == 4&#x27;d10) begin</span><br><span class="line">                if ((buffer[0] == 0) &amp;&amp;  // start bit</span><br><span class="line">                    (ps2_data)       &amp;&amp;  // stop bit</span><br><span class="line">                    (^buffer[9:1])) begin      // odd  parity</span><br><span class="line">                    fifo[w_ptr] &lt;= buffer[8:1];  // kbd scan code</span><br><span class="line">                    w_ptr &lt;= w_ptr+3&#x27;b1;</span><br><span class="line">                    ready &lt;= 1&#x27;b1;</span><br><span class="line">                    overflow &lt;= overflow | (r_ptr == (w_ptr + 3&#x27;b1));</span><br><span class="line">                end</span><br><span class="line">                count &lt;= 0;     // for next</span><br><span class="line">              end else begin</span><br><span class="line">                buffer[count] &lt;= ps2_data;  // store ps2_data</span><br><span class="line">                count &lt;= count + 3&#x27;b1;</span><br><span class="line">              end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    assign data = fifo[r_ptr]; //always set output data</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>键盘仿真模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns / 1ps</span><br><span class="line">module ps2_keyboard_model(</span><br><span class="line">    output reg ps2_clk,</span><br><span class="line">    output reg ps2_data</span><br><span class="line">    );</span><br><span class="line">parameter [31:0] kbd_clk_period = 60;</span><br><span class="line">initial ps2_clk = 1&#x27;b1;</span><br><span class="line"></span><br><span class="line">task kbd_sendcode;</span><br><span class="line">    input [7:0] code; // key to be sent</span><br><span class="line">    integer i;</span><br><span class="line"></span><br><span class="line">    reg[10:0] send_buffer;</span><br><span class="line">    begin</span><br><span class="line">        send_buffer[0]   = 1&#x27;b0;  // start bit</span><br><span class="line">        send_buffer[8:1] = code;  // code</span><br><span class="line">        send_buffer[9]   = ~(^code); // odd parity bit</span><br><span class="line">        send_buffer[10]  = 1&#x27;b1;  // stop bit</span><br><span class="line">        i = 0;</span><br><span class="line">        while( i &lt; 11) begin</span><br><span class="line">            // set kbd_data</span><br><span class="line">            ps2_data = send_buffer[i];</span><br><span class="line">            #(kbd_clk_period/2) ps2_clk = 1&#x27;b0;</span><br><span class="line">            #(kbd_clk_period/2) ps2_clk = 1&#x27;b1;</span><br><span class="line">            i = i + 1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>键盘测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns / 1ps</span><br><span class="line">module keyboard_sim;</span><br><span class="line"></span><br><span class="line">/* parameter */</span><br><span class="line">parameter [31:0] clock_period = 10;</span><br><span class="line"></span><br><span class="line">/* ps2_keyboard interface signals */</span><br><span class="line">reg clk,clrn;</span><br><span class="line">wire [7:0] data;</span><br><span class="line">wire ready,overflow;</span><br><span class="line">wire kbd_clk, kbd_data;</span><br><span class="line">reg nextdata_n;</span><br><span class="line"></span><br><span class="line">ps2_keyboard_model model(</span><br><span class="line">    .ps2_clk(kbd_clk),</span><br><span class="line">    .ps2_data(kbd_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ps2_keyboard inst(</span><br><span class="line">    .clk(clk),</span><br><span class="line">    .clrn(clrn),</span><br><span class="line">    .ps2_clk(kbd_clk),</span><br><span class="line">    .ps2_data(kbd_data),</span><br><span class="line">    .data(data),</span><br><span class="line">    .ready(ready),</span><br><span class="line">    .nextdata_n(nextdata_n),</span><br><span class="line">    .overflow(overflow)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">initial begin /* clock driver */</span><br><span class="line">    clk = 0;</span><br><span class="line">    forever</span><br><span class="line">        #(clock_period/2) clk = ~clk;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">    clrn = 1&#x27;b0;  #20;</span><br><span class="line">    clrn = 1&#x27;b1;  #20;</span><br><span class="line">    model.kbd_sendcode(8&#x27;h1C); // press &#x27;A&#x27;</span><br><span class="line">    #20 nextdata_n =1&#x27;b0; #20 nextdata_n =1&#x27;b1;//read data</span><br><span class="line">    model.kbd_sendcode(8&#x27;hF0); // break code</span><br><span class="line">    #20 nextdata_n =1&#x27;b0; #20 nextdata_n =1&#x27;b1; //read data</span><br><span class="line">    model.kbd_sendcode(8&#x27;h1C); // release &#x27;A&#x27;</span><br><span class="line">    #20 nextdata_n =1&#x27;b0; #20 nextdata_n =1&#x27;b1; //read data</span><br><span class="line">    model.kbd_sendcode(8&#x27;h1B); // press &#x27;S&#x27;</span><br><span class="line">    #20 model.kbd_sendcode(8&#x27;h1B); // keep pressing &#x27;S&#x27;</span><br><span class="line">    #20 model.kbd_sendcode(8&#x27;h1B); // keep pressing &#x27;S&#x27;</span><br><span class="line">    model.kbd_sendcode(8&#x27;hF0); // break code</span><br><span class="line">    model.kbd_sendcode(8&#x27;h1B); // release &#x27;S&#x27;</span><br><span class="line">    #20;</span><br><span class="line">    $stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h1 id="电路">电路</h1><h2 id="组合逻辑">组合逻辑</h2><h3 id="基本门">基本门</h3><p>GND</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign out = 1&#x27;b0;</span><br></pre></td></tr></table></figure><p>NOR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign out = ~(in1|in2);</span><br></pre></td></tr></table></figure><h3 id="多路选择器">多路选择器</h3><p>9路选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module top_module( </span><br><span class="line">    input [15:0] a, b, c, d, e, f, g, h, i,</span><br><span class="line">    input [3:0] sel,</span><br><span class="line">    output [15:0] out );</span><br><span class="line"></span><br><span class="line">// Case statements can only be used inside procedural blocks (always block)</span><br><span class="line">// This is a combinational circuit, so use a combinational always @(*) block.</span><br><span class="line">always @(*) begin</span><br><span class="line">out = &#x27;1;// &#x27;1 is a special literal syntax for a number with all bits set to 1.</span><br><span class="line">// &#x27;0, &#x27;x, and &#x27;z are also valid.</span><br><span class="line">// I prefer to assign a default value to &#x27;out&#x27; instead of using a</span><br><span class="line">// default case.</span><br><span class="line">case (sel)</span><br><span class="line">4&#x27;h0: out = a;</span><br><span class="line">4&#x27;h1: out = b;</span><br><span class="line">4&#x27;h2: out = c;</span><br><span class="line">4&#x27;h3: out = d;</span><br><span class="line">4&#x27;h4: out = e;</span><br><span class="line">4&#x27;h5: out = f;</span><br><span class="line">4&#x27;h6: out = g;</span><br><span class="line">4&#x27;h7: out = h;</span><br><span class="line">4&#x27;h8: out = i;</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4位256路选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module top_module (</span><br><span class="line">input [1023:0] in,</span><br><span class="line">input [7:0] sel,</span><br><span class="line">output [3:0] out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// We can&#x27;t part-select multiple bits without an error, but we can select one bit at a time,</span><br><span class="line">// four times, then concatenate them together.</span><br><span class="line">assign out = &#123;in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]&#125;;</span><br><span class="line"></span><br><span class="line">// Alternatively, &quot;indexed vector part select&quot; works better, but has an unfamiliar syntax:</span><br><span class="line">// assign out = in[sel*4 +: 4];// Select starting at index &quot;sel*4&quot;, then select a total width of 4 bits with increasing (+:) index number.</span><br><span class="line">// assign out = in[sel*4+3 -: 4];// Select starting at index &quot;sel*4+3&quot;, then select a total width of 4 bits with decreasing (-:) index number.</span><br><span class="line">// Note: The width (4 in this case) must be constant.</span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;语言简介&quot;&gt;语言简介&lt;/h1&gt;
&lt;p&gt;Verilog在线学习&lt;a href=&quot;https://hdlbits.01xz.net/wiki/Main_Page&quot;&gt;HDLBits主页&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本语句&quot;&gt;基本语句&lt;/h2&gt;
&lt;h3 id=&quot;常量</summary>
      
    
    
    
    <category term="硬件" scheme="https://oz1010.github.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Verilator-电路RTL仿真器使用</title>
    <link href="https://oz1010.github.com/2024/04/08/Verilator-%E7%94%B5%E8%B7%AFRTL%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://oz1010.github.com/2024/04/08/Verilator-%E7%94%B5%E8%B7%AFRTL%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2024-04-08T03:07:02.000Z</published>
    <updated>2026-01-21T06:34:01.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用示例">使用示例</h1><p>南京大学电路教学项目-<a href="https://github.com/NJU-ProjectN/nvboard.git">NVboard</a>，可以图形化显示过程状态和数据，同时也支持verilator。</p><h2 id="双控开关">双控开关</h2><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">VERILATOR_FLAGS := --build -j 0 -cc --exe -x-assign fast -Wall</span><br><span class="line"></span><br><span class="line">C_SRC   :=      <span class="variable">$(<span class="built_in">shell</span> ls csrc/*.cpp)</span></span><br><span class="line">V_SRC   :=  <span class="variable">$(<span class="built_in">shell</span> ls vsrc/*.v)</span></span><br><span class="line">OBJ_DIR :=      obj_dir</span><br><span class="line">TARGET  :=  obj_dir/Vtop</span><br><span class="line"><span class="comment">#TARGET_ARGS    := +trace</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: run clean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> TRACE</span><br><span class="line">VERILATOR_FLAGS += --trace</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: $&#123;TARGET&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="section">run: $&#123;TARGET&#125;</span></span><br><span class="line">        @rm -rf logs</span><br><span class="line">        @$&#123;TARGET&#125; $&#123;TARGET_ARGS&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">$&#123;TARGET&#125;: $&#123;V_SRC&#125; $&#123;C_SRC&#125;</span></span><br><span class="line">        <span class="comment">#@verilator --build -j 0 -cc --exe -x-assign fast -Wall --trace $^</span></span><br><span class="line">        @verilator $&#123;VERILATOR_FLAGS&#125; <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">        <span class="variable">$(<span class="built_in">call</span> git_commit, <span class="string">&quot;sim RTL&quot;</span>)</span> <span class="comment"># DO NOT REMOVE THIS LINE!!!</span></span><br><span class="line">        @echo <span class="string">&quot;Write this Makefile by your self.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> ../Makefile</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        @rm -rf logs</span><br><span class="line">        @rm -rf $&#123;OBJ_DIR&#125;</span><br></pre></td></tr></table></figure><p>verilog代码文件<code>top.v</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module top</span><br><span class="line">  (</span><br><span class="line">  input a,</span><br><span class="line">  input b,</span><br><span class="line">  output f</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assign f = a ^ b;</span><br><span class="line"></span><br><span class="line">  initial begin</span><br><span class="line">        $display(&quot;[%0t] Model running...\n&quot;, $time);</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>主体仿真文件<code>sim_main.cpp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VM_TRACE_VCD</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated_vcd_c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VerilatedContext&gt; contextp&#123;new VerilatedContext&#125;;</span><br><span class="line">        contextp-&gt;debug(<span class="number">0</span>); <span class="comment">// Set debug level, 0 is off, 9 is highest</span></span><br><span class="line">        contextp-&gt;randReset(<span class="number">2</span>); <span class="comment">// Randomization reset policy</span></span><br><span class="line">        contextp-&gt;commandArgs(argc, argv); <span class="comment">// Pass arguments so Verilated code can see them</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &quot;TOP&quot; will be hierarchical name of the module.</span></span><br><span class="line">        <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Vtop&gt; top&#123;new Vtop&#123;contextp.get(), <span class="string">&quot;TOP&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VM_TRACE_VCD</span></span><br><span class="line">        Verilated::mkdir(<span class="string">&quot;logs&quot;</span>);</span><br><span class="line">        contextp-&gt;traceEverOn(<span class="literal">true</span>); <span class="comment">// Verilator must compute traced signals</span></span><br><span class="line">        <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VerilatedVcdC&gt;tfp&#123;new VerilatedVcdC&#125;;</span><br><span class="line">        top-&gt;trace(tfp.get(), <span class="number">99</span>); <span class="comment">// Trace 99 levels of hierarchy (or see below)</span></span><br><span class="line">        tfp-&gt;open(<span class="string">&quot;logs/simu_top.vcd&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Start trace ...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> sim_time = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">while</span>(contextp-&gt;time()&lt;sim_time &amp;&amp; !contextp-&gt;gotFinish())</span><br><span class="line">        &#123;</span><br><span class="line">                contextp-&gt;timeInc(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> a = rand() &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> b = rand() &amp; <span class="number">1</span>;</span><br><span class="line">                top-&gt;a = a;</span><br><span class="line">                top-&gt;b = b;</span><br><span class="line">                top-&gt;eval();</span><br><span class="line">                <span class="comment">// printf(&quot;a = %d, b = %d, f = %d, time = %lu\n&quot;, a, b, top-&gt;f, contextp-&gt;time());</span></span><br><span class="line">                assert(top-&gt;f == (a ^ b));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VM_TRACE_VCD</span></span><br><span class="line">                tfp-&gt;dump(contextp-&gt;time());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        top-&gt;final();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Coverage analysis</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VM_COVERAGE</span></span><br><span class="line">        Verilated::mkdir(<span class="string">&quot;logs&quot;</span>);</span><br><span class="line">        contextp-&gt;converagep()-&gt;write(<span class="string">&quot;logs/coverage.dat&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Final simulation summary</span></span><br><span class="line">        contextp-&gt;statsPrintSummary();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用示例&quot;&gt;使用示例&lt;/h1&gt;
&lt;p&gt;南京大学电路教学项目-&lt;a href=&quot;https://github.com/NJU-ProjectN/nvboard.git&quot;&gt;NVboard&lt;/a&gt;，可以图形化显示过程状态和数据，同时也支持verilator。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="硬件" scheme="https://oz1010.github.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux命令使用与脚本编写简介</title>
    <link href="https://oz1010.github.com/2024/04/04/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AE%80%E4%BB%8B/"/>
    <id>https://oz1010.github.com/2024/04/04/Linux%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%AE%80%E4%BB%8B/</id>
    <published>2024-04-04T12:47:25.000Z</published>
    <updated>2026-01-21T06:34:01.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux命令">Linux命令</h1><h2 id="常用命令">常用命令</h2><h3 id="cd">cd</h3><h3 id="ls">ls</h3><h3 id="awk">awk</h3><h3 id="sed">sed</h3><h3 id="ps">ps</h3><h3 id="df">df</h3><h3 id="fdisk">fdisk</h3><h3 id="wc">wc</h3><h3 id="find">find</h3><h3 id="grepegrep">grep/egrep</h3><h3 id="top">top</h3><h3 id="vivim">vi/vim</h3><h3 id="diffvimdiff">diff/vimdiff</h3><h3 id="man">man</h3><p>查看内置帮助手册，不仅可以查看命令手册，还有系统调用、库函数、异常码、宏等等信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学习如何RTFM</span></span><br><span class="line">$ man man</span><br><span class="line"><span class="comment"># 学习如何使用库函数</span></span><br><span class="line">$ man 3 getopt</span><br><span class="line"><span class="comment"># 检索含有关键词xxx的命令</span></span><br><span class="line">$ man -k xxx</span><br><span class="line">$ man readline</span><br><span class="line">$ man bash</span><br></pre></td></tr></table></figure><h3 id="xargs">xargs</h3><h3 id="strace">strace</h3><p>system call trace, 记录程序运行过程中的系统调用信息</p><h3 id="netstat">netstat</h3><h3 id="ip">ip</h3><h3 id="ifconfig">ifconfig</h3><h3 id="ssh">ssh</h3><h3 id="telnet">telnet</h3><h3 id="sort">sort</h3><h3 id="history">history</h3><p><code>!n</code>再次执行编号n命令</p><p><code>!xxx</code>再次执行以<code>xxx</code>开头的最近一条命令</p><h3 id="yes">yes</h3><p>不断重复输出<code>y</code></p><h3 id="watch">watch</h3><p>在前台定时执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ watch -t -n 1 <span class="string">&quot;echo -n &#x27;第六期一生一芯 | 周六 15:00~17:00 | &#x27;; \</span></span><br><span class="line"><span class="string">  date; echo &#x27;课程主页 https://ysyx.oscc.cc/docs/&#x27;&quot;</span></span><br><span class="line">第六期一生一芯 | 周六 15:00~17:00 | Thu Apr  4 16:58:59 CST 2024</span><br><span class="line">课程主页 https://ysyx.oscc.cc/docs/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="crontab">crontab</h3><p>在后台定时执行命令，需要编写对应的配置文件</p><h3 id="timeout">timeout</h3><p>执行特定时间，返回超时或命令自身的返回值</p><ul><li>0：命令成功执行并完成。</li><li>124：命令因超时而终止。</li><li>其他：命令执行失败</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timeout 6 mkdir -p /mnt/dev0</span><br></pre></td></tr></table></figure><h1 id="脚本编写">脚本编写</h1><p>细节介绍参考<code>man bash</code></p><h2 id="基本语法">基本语法</h2><h3 id="简介">简介</h3><p>脚本的本质就是将众多Linux小工具按照一定的逻辑顺序依次执行处理，脚本文件内容就是这些命令的集合。</p><p>程序运行时都会打开3个文件</p><ul><li>0号文件，标准输入</li><li>1号文件，标准输出</li><li>2号文件，标准错误输出</li></ul><p>可以通过<code>lsof -p &lt;PID&gt;</code>查看进程打开的文件。</p><p><code>&gt;</code>重定向标准输出，<code>&gt;&gt;</code>追加方式重定向标准输出，<code>2&gt;&amp;1</code>将标准错误重定向到标准输出。</p><p>内置变量有</p><ul><li><code>$0 $1 ... $n</code>：脚本名称（有时会包含相对或绝对路径）、第1个参数……第n个参数</li><li><code>$?</code>：最后一条命令或函数的返回值</li><li><code>$@</code>：传递<code>$0</code>之外的所有参数，可以用数组保存其值：<code>ALL_ARGS=("$@")</code></li><li><code>$#</code>：传递给脚本或函数的参数个数</li></ul><h3 id="内置命令">内置命令</h3><h4 id="shift">shift</h4><p>基本格式：<code>shift [n]</code></p><p>将参数左移n位，默认值为1</p><h3 id="变量用法">变量用法</h3><h4 id="基本用法">基本用法</h4><p>使用示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量赋值</span></span><br><span class="line">var=<span class="string">&quot;/root/project/abc&quot;</span></span><br><span class="line"><span class="comment"># 变量使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure><h4 id="变量展开">变量展开</h4><p>又名shell参数展开，基本格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;变量##模式&#125;</span><br><span class="line">$&#123;变量#模式&#125;</span><br><span class="line">$&#123;变量%%模式&#125;</span><br><span class="line">$&#123;变量%模式&#125;</span><br></pre></td></tr></table></figure><p>模式支持的符号：</p><ul><li><code>*</code> 匹配任意字符串</li><li><code>?</code> 匹配任意单个字符</li><li><code>[...]</code>匹配字符集，比如：范围<code>[0-9a-z]</code>，取反<code>[!abc]</code>或<code>[^abc]</code></li><li><code>\</code> 匹配转义字符，比如：<code>*</code></li></ul><p>使用示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ var=<span class="string">&quot;/root/project/abc&quot;</span></span><br><span class="line"><span class="comment"># 从左开始，最小匹配模式删除匹配字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var#*/&#125;</span></span><br><span class="line">root/project/abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左开始，最大匹配模式删除匹配字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*/&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右开始，最小匹配模式删除匹配字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%/*&#125;</span></span><br><span class="line">/root/project</span><br><span class="line"><span class="comment"># 从右开始，最大匹配模式删除匹配字符串</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var%%/*&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交互界面">交互界面</h3><p>基本操作</p><ul><li><code>Tab</code>键自动补全</li><li>上下方向键遍历历史命令</li></ul><p>任务管理</p><ul><li><code>Ctrl+Z</code>最小化，或运行时命令末尾添加&amp;（但用户退出后后台任务也会退出，可以使用<code>nohup</code>命令避免）</li><li><code>jobs</code>任务栏</li><li><code>bg</code>后台执行任务，将指定任务2切换到后台执行<code>bg %2</code></li><li><code>fg</code>前台执行任务，将指定任务2切换到前台执行<code>fg %2</code></li></ul><p>shell可以通过快捷键操作光标快速移动，更多快捷键可以阅读<code>man readline</code>的<code>Commands for Moving</code>部分</p><ul><li><code>Ctrl+B</code>光标前移一个字符</li><li><code>Ctrl+F</code>光标后移一个字符</li><li><code>Ctrl+A</code>光标移到首字符处</li><li><code>Ctrl+E</code>光标移到首字符处</li></ul><h3 id="基本单元">基本单元</h3><p>shell都是基于文本进行处理，其中只有数字字符串在特定场景可以进行数学运算。</p><p>通配符</p><ul><li><code>*</code>任意长度的字符串</li><li><code>?</code>任意一个字符</li><li><code>[xxx]</code>集合中任意一个字符</li></ul><p>示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> Hello-&#123;a,bb,ccc&#125;-&#123;1,2&#125;!</span><br><span class="line">Hello-a-1! Hello-a-2! Hello-bb-1! Hello-bb-2! Hello-ccc-1! Hello-ccc-2!</span><br></pre></td></tr></table></figure><p>数组</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个数组</span><br><span class="line">array=()</span><br><span class="line">declare -a array</span><br><span class="line"></span><br><span class="line"># 添加元素</span><br><span class="line">array+=(&quot;item0&quot;)</span><br><span class="line">array+=(&quot;item1&quot;)</span><br><span class="line">array+=(&quot;item2&quot;)</span><br><span class="line"></span><br><span class="line"># 遍历一个数组</span><br><span class="line">for item in $array; do echo item is $item; done</span><br><span class="line">for i in &#123;1..$&#123;#array[@]&#125;&#125;; do item=$&#123;array[$i]&#125;; echo item is $item; done</span><br><span class="line">for item in $&#123;array[@]&#125;; do echo item is $item; done</span><br><span class="line"></span><br><span class="line"># 删除指定元素</span><br><span class="line">unset &#x27;array[1]&#x27; # 删除item0，但是索引依然保留</span><br><span class="line"># 重新创建一个新数组，通过过滤方式</span><br><span class="line">new_array=()</span><br><span class="line">for item in $&#123;array[@]&#125;; do</span><br><span class="line">if [ $item != &quot;item0&quot; ]; then</span><br><span class="line">new_array+=(&quot;$item&quot;)</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 删除整个数组</span><br><span class="line">unset array</span><br><span class="line">array=() # 清空整个数组</span><br></pre></td></tr></table></figure><h3 id="判断逻辑">判断逻辑</h3><p>if</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ if mkdir -p /mnt/dev0; then echo ok; else echo error; fi</span><br></pre></td></tr></table></figure><p>命令执行成功则打印ok，否则打印失败</p><p>case</p><h3 id="循环逻辑">循环逻辑</h3><p>while</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> [[ `<span class="built_in">seq</span> 1 10 | <span class="built_in">shuf</span> | <span class="built_in">head</span> -n 1` != <span class="string">&quot;1&quot;</span> ]]; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;retry&quot;</span>; <span class="keyword">done</span></span><br><span class="line">retry</span><br><span class="line">retry</span><br></pre></td></tr></table></figure><p>for</p><h3 id="捕获信号">捕获信号</h3><p><code>trap</code>命令用于捕获和处理信号或错误。当特定信号发生时，<code>trap</code>可以执行指定的命令。<code>trap</code>可以捕获多种信号，包括系统信号和错误。</p><p>一些常见的信号量包括：</p><ul><li><code>SIGINT</code> (2): 中断信号，通常由 Ctrl+C 触发。</li><li><code>SIGTERM</code> (15): 终止信号，通常由 <code>kill</code>命令发送，用于请求进程终止。</li><li><code>SIGKILL</code> (9):强制终止信号，无法被捕获或忽略，通常用于强制停止进程。</li><li><code>SIGQUIT</code> (3): 退出信号，通常由 Ctrl+ 触发，用于生成 coredump。</li><li><code>SIGSTOP</code> (19):停止信号，无法被捕获或忽略，通常用于挂起进程。</li><li><code>SIGCONT</code> (18): 恢复信号，用于恢复一个被<code>SIGSTOP</code> 停止的进程。</li><li><code>SIGHUP</code> (1): 挂起信号，通常是终端关闭时发送的。</li><li><code>SIGUSR1</code> 和 <code>SIGUSR2</code>:用户自定义信号，可以用来传递特定信息。</li><li><code>SIGSEGV</code> (11):段错误信号，通常在程序访问非法内存时触发。</li><li><code>SIGPIPE</code> (13):管道破裂信号，通常当向一个没有读取者的管道写数据时触发。</li></ul><p>常见的错误有：</p><ul><li><code>EXIT</code>：捕获脚本或命令退出时的状态（返回码）。例如，你可以捕获脚本退出时的状态码，或者通过<code>trap</code> 在脚本退出时执行清理工作。</li><li><code>ERR</code>：捕获任何命令的非零退出状态（发生错误时触发）。通过<code>trap 'command' ERR</code>，你可以在发生错误时执行指定的命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">exit_handler() &#123;</span><br><span class="line"># 具体处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap exit_handler SIGINT SIGTERM EXIT ERR</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入输出">输入输出</h3><h2 id="经典示例">经典示例</h2><h3 id="输入参数解析">输入参数解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入的参数可以包含以下几种情况的任意组合，&lt;xxx&gt;表示参数后必须跟对应的值：</span><br><span class="line">-n &lt;num&gt;</span><br><span class="line">--number &lt;num&gt; </span><br><span class="line">-v</span><br><span class="line">--version</span><br><span class="line">-h</span><br></pre></td></tr></table></figure><h4 id="case手动解析">case手动解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 手动解析参数</span><br><span class="line">while [ $# -gt 0 ]; do</span><br><span class="line">    case &quot;$1&quot; in</span><br><span class="line">        -n|--number)</span><br><span class="line">            # 确保后面有值</span><br><span class="line">            if [ -n &quot;$2&quot; ] &amp;&amp; [[ &quot;$2&quot; != -* ]]; then</span><br><span class="line">                number=&quot;$2&quot;</span><br><span class="line">                shift 2</span><br><span class="line">            else</span><br><span class="line">                echo &quot;错误: -n 或 --number 需要一个参数&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            fi</span><br><span class="line">            ;;</span><br><span class="line">        -v|--version) show_version=true; shift; ;;</span><br><span class="line">        -h|--help) show_help=true; shift; ;;</span><br><span class="line">        *)</span><br><span class="line">            echo &quot;忽略非选项参数: $1&quot;</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="自制cpu主频监视器">自制CPU主频监视器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch -n 1 <span class="string">&quot;cat /proc/cpuinfo | grep MHz | awk &#x27;&#123;print \$1 NR \$3 \$4 \$2&#125;&#x27;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="打包特定文件并上传到远端">打包特定文件并上传到远端</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">&quot;*.pdf&quot;</span> | xargs tar cj | ssh yzh@192.168.1.1 <span class="string">&#x27;cd ysyx; &gt; pdf.tar.bz2&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="统计工具类型分布">统计工具类型分布</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">tr</span> -t : <span class="string">&#x27;\n&#x27;</span> | xargs -I&#123;&#125; find &#123;&#125; -maxdepth 1 -<span class="built_in">type</span> f -executable | \</span><br><span class="line">  xargs file -b -e elf | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line">    835 ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class="line">    129 Perl script text executable</span><br><span class="line">    113 POSIX shell script, ASCII text executable</span><br><span class="line">     34 Python script, ASCII text executable</span><br><span class="line">     24 ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux)</span><br><span class="line">     20 Bourne-Again shell script, ASCII text executable</span><br><span class="line">     15 setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class="line">     12 setgid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class="line">     10 ELF 64-bit LSB executable, x86-64, version 1 (SYSV)</span><br><span class="line">      9 POSIX shell script, Unicode text, UTF-8 text executable</span><br><span class="line">      3 ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux)</span><br><span class="line">      2 Python script, Unicode text, UTF-8 text executable</span><br><span class="line">      2 PHP script, ASCII text executable</span><br><span class="line">      1 setuid, setgid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV)</span><br><span class="line">      1 Python script, ISO-8859 text executable</span><br><span class="line">      1 POSIX shell script, ASCII text executable, with very long lines (459)</span><br><span class="line">      1 PHP phar archive with SHA1 signature</span><br><span class="line">      1 Paul Falstad<span class="string">&#x27;s zsh script, ASCII text executable</span></span><br><span class="line"><span class="string">      1 JavaScript source, ASCII text</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux命令&quot;&gt;Linux命令&lt;/h1&gt;
&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;
&lt;h3 id=&quot;cd&quot;&gt;cd&lt;/h3&gt;
&lt;h3 id=&quot;ls&quot;&gt;ls&lt;/h3&gt;
&lt;h3 id=&quot;awk&quot;&gt;awk&lt;/h3&gt;
&lt;h3 id=&quot;sed&quot;&gt;sed&lt;/h3&gt;
&lt;h</summary>
      
    
    
    
    <category term="Linux" scheme="https://oz1010.github.com/categories/Linux/"/>
    
    
    <category term="命令" scheme="https://oz1010.github.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
    <category term="Shell" scheme="https://oz1010.github.com/tags/Shell/"/>
    
    <category term="脚本" scheme="https://oz1010.github.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>编程语言-C++</title>
    <link href="https://oz1010.github.com/2024/04/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    <id>https://oz1010.github.com/2024/04/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/</id>
    <published>2024-04-04T07:59:30.000Z</published>
    <updated>2026-01-21T06:34:01.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="告警">告警</h2><h3 id="变量初始化顺序">变量初始化顺序</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h: In constructor ‘AADL2C::AIT::CtxComponent::CtxComponent(AADL2C::AIT::NodeArchitecture&amp;, AADL2C::AIT::ASTBasePtr, AADL2C::AIT::NodeComponent&amp;)’:</span><br><span class="line">[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h:137:33: warning: ‘AADL2C::AIT::CtxComponent::mpnewInstance’ will be initialized after [-Wreorder]</span><br><span class="line">[build]      AADL2C::AIT::NodeComponent* mpnewInstance;</span><br><span class="line">[build]                                  ^~~~~~~~~~~~~</span><br><span class="line">[build] /root/project/tcl3/aadl2c/include/AADL2C/AIT/CtxUtility.h:136:33: warning:   ‘AADL2C::AIT::NodeComponent* AADL2C::AIT::CtxComponent::mpexistingInstance’ [-Wreorder]</span><br><span class="line">[build]      AADL2C::AIT::NodeComponent* mpexistingInstance;</span><br><span class="line">[build]                                  ^~~~~~~~~~~~~~~~~~</span><br><span class="line">[build] /root/project/tcl3/aadl2c/src/AIT/CtxUtility.cpp:49:1: warning:   when initialized here [-Wreorder]</span><br><span class="line">[build]  CtxComponent::CtxComponent(AADL2C::AIT::NodeArchitecture&amp; instanceRoot, ASTBasePtr component,</span><br><span class="line">[build]  ^~~~~~~~~~~~</span><br><span class="line">[build] In file included from /root/project/tcl3/aadl2c/src/AIT/CtxUtility.cpp:3:0:</span><br></pre></td></tr></table></figure><p>这几句告警说的是变量顺序问题，英文大意为：</p><blockquote><p>成员变量<code>mpnewInstance</code>将会在<code>mpexistingInstance</code>之后初始化，当调用类构造函数<code>CtxComponent::CtxComponent</code>进行初始化时。</p></blockquote><p><strong>解决方案</strong>：调整相关变量初始化顺序</p><h2 id="成员变量">成员变量</h2><p>可见性：</p><ul><li>private</li><li>protect</li><li>public</li></ul><p>静态成员变量 static</p><p>成员常量 const</p><p>volitle?</p><p>register?</p><p>auto?</p><h2 id="成员函数">成员函数</h2><p>构造函数 析构函数 拷贝构造函数</p><p>移动构造函数 移动赋值运算符</p><p>运算符（= &amp; + - * / ++ – += -= [] () &lt;&lt; &gt;&gt; …）</p><p>静态成员函数 static</p><p>只读成员函数 const</p><p>虚函数 纯虚函数 virtual =0</p><p>不可调用函数 =delete</p><p>默认类函数 =default</p><p>覆写函数 防止覆写函数 override final</p><p>单参数构造函数显示转换 explict</p><p>友元函数 friend</p><h2 id="枚举">枚举</h2><h3 id="字符串化">字符串化</h3><p>C语言宏定义可以有一些特殊用法：</p><ul><li>#: 预处理阶段，将宏参数转化为字符串</li><li>##: 预处理阶段，将两个标识符拼接成一个标识符</li></ul><p>具体步骤：</p><ol type="1"><li>将需要的枚举名放到固定的地方统一管理，使用特别的宏函数<code>ENUM_OR_STRING</code>封装，例如枚举文件<code>signal_list.gen</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal_list.gen</span></span><br><span class="line">ENUM_OR_STRING(LED_OPEN),                   \</span><br><span class="line">ENUM_OR_STRING(LED_CLOSE),                  \</span><br><span class="line">ENUM_OR_STRING(MSG_TEST),                   \</span><br><span class="line">ENUM_OR_STRING(MSG_BUTT)                    \</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>定义宏函数<code>ENUM_OR_STRING</code>，使用枚举文件声明枚举</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal_id.h</span></span><br><span class="line"><span class="comment">/* 消息ID转枚举 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENUM_OR_STRING</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ENUM_OR_STRING</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_OR_STRING(x) x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_list.gen&quot;</span></span></span><br><span class="line">&#125; E_MSG_ID;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>定义宏函数<code>ENUM_OR_STRING</code>，实现获取枚举字符串方法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENUM_OR_STRING</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ENUM_OR_STRING</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_OR_STRING(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH_MSG = <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> msgIdString[][MAX_LENGTH_MSG] = &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_list.gen&quot;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetMsgName</span><span class="params">(<span class="type">int</span> msgID)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgIdString[msgID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;告警&quot;&gt;告警&lt;/h2&gt;
&lt;h3 id=&quot;变量初始化顺序&quot;&gt;变量初始化顺序&lt;/h3&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    
  </entry>
  
</feed>
